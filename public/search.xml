<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode题解64：最小路径和</title>
      <link href="/2022/08/06/leetcode%E9%A2%98%E8%A7%A364/"/>
      <url>/2022/08/06/leetcode%E9%A2%98%E8%A7%A364/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/minimum-path-sum/">力扣第64题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>和<ahref="https://caoqinping.com/2022/08/06/leetcode题解62/">力扣第62题</a>的区别在于，试求最小和，还是用<code>dp[i][j]</code>表示达到<code>i,j</code>网格的最小和，那么转移方程为<code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code>，当然这是对<code>i&gt;0，j&gt;0</code>的情况，<code>i==0</code>或<code>j==0</code>的情况，就更简单了，具体可以参考代码。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPathSum</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(grid)</span><br><span class="line">        n = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            grid[i][<span class="number">0</span>] += grid[i-<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">                grid[i][j] += <span class="built_in">min</span>(grid[i-<span class="number">1</span>][j], grid[i][j-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解63：不同路径 II</title>
      <link href="/2022/08/06/leetcode%E9%A2%98%E8%A7%A363/"/>
      <url>/2022/08/06/leetcode%E9%A2%98%E8%A7%A363/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/unique-paths-ii/">力扣第63题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>与<ahref="https://caoqinping.com/2022/08/06/leetcode题解62/">力扣第62题</a>唯一不同的地方，在于有障碍物，不难发现，到达<code>i,j</code>网格的步数，依然是相邻左方与上方的步数之和，不过如果有一个相邻的区域是障碍物，那么该方向就失效，那么设置达到障碍物的步数为<code>0</code>就可以。所以转移方程为<br /><span class="math display">\[    dp[i][j] = \left\{        \begin{aligned}            &amp; 0 &amp; i,j\text{是障碍物}\\            &amp; dp[i][j-1] &amp; i,j\text{不是障碍物且 } i == 0 \text{and } j &gt; 0 \\            &amp; dp[i-1][j] &amp; i,j\text{不是障碍物且 } j == 0 \text{and } i &gt; 0 \\            &amp; dp[i-1][j] + dp[i][j-1] &amp; others        \end{aligned}    \right.\]</span><br />注意初始化<code>dp[0][0]=1</code></p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] += dp[i-<span class="number">1</span>][j]</span><br><span class="line">                    <span class="keyword">if</span> j &gt; <span class="number">0</span>:</span><br><span class="line">                        dp[i][j] += dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解62：不同路径</title>
      <link href="/2022/08/06/leetcode%E9%A2%98%E8%A7%A362/"/>
      <url>/2022/08/06/leetcode%E9%A2%98%E8%A7%A362/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/unique-paths/">力扣第62题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>最经典也最基础的动态规划题了，用<code>dp[i][j]</code>表示到达<code>i,j</code>这个网格的步数，这有转移方程<br /><span class="math display">\[    dp[i][j] = \left\{ \begin{aligned} &amp; 1 &amp; i == 0\text{ or }j== 0 \\ &amp; dp[i-1][j] + dp[i][j-1] &amp; others \end{aligned}\right.\]</span></p><p>即步数总是等于到达相邻的上方与左方的步数之和。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span>:</span><br><span class="line">                    dp[i][j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解61：旋转链表</title>
      <link href="/2022/08/06/leetcode%E9%A2%98%E8%A7%A361/"/>
      <url>/2022/08/06/leetcode%E9%A2%98%E8%A7%A361/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/rotate-list/">力扣第61题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>思路非常简单，将首尾相连，然后将<code>head</code>指向第<code>n-k</code>个结点的<code>next</code>结点，最后将第<code>n - k</code>个结点的<code>next</code>指向<code>NULL</code>；当然注意到<code>k</code>可能大于<code>n</code>，对令<code>k = k % n</code>就好了；比如下面这个例子：<br /><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span>-&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure><br />当<code>k=1</code>时，首先首尾相连得到<br /><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></span><br><span class="line">^                   |</span><br><span class="line">|<span class="comment">-------------------</span></span><br></pre></td></tr></table></figure><br />然后找到第4个结点，并将<code>head</code>指向该结点的<code>next</code>结点，然后将该结点的<code>next</code>指向<code>NULL</code><br /><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span>  <span class="number">5</span> &lt;-head</span><br><span class="line">^                 |</span><br><span class="line">|<span class="comment">-----------------</span></span><br></pre></td></tr></table></figure><br />这样链表不就变为了<br /><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">5 </span>-&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure></p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotateRight</span>(<span class="params">self, head: <span class="type">Optional</span>[ListNode], k: <span class="built_in">int</span></span>) -&gt; <span class="type">Optional</span>[ListNode]:</span><br><span class="line">        <span class="keyword">if</span> head <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        last_node = head</span><br><span class="line">        num_nodes = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> last_node.<span class="built_in">next</span> != <span class="literal">None</span>:</span><br><span class="line">            last_node = last_node.<span class="built_in">next</span></span><br><span class="line">            num_nodes += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        last_node.<span class="built_in">next</span> = head</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_nodes-k % num_nodes):</span><br><span class="line">            last_node = last_node.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        head = last_node.<span class="built_in">next</span></span><br><span class="line">        last_node.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解60：第k个排列</title>
      <link href="/2022/08/03/leetcode%E9%A2%98%E8%A7%A360/"/>
      <url>/2022/08/03/leetcode%E9%A2%98%E8%A7%A360/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/permutation-sequence/">力扣第60题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>最简单的思路，就是按照<ahref="https://caoqinping.com/2022/05/08/leetcode题解31/">力扣第31题</a>的思路，每次求下一个排列，直到第<spanclass="math inline">\(k\)</span>个。</p><p>但是有更高效的方法，我们知道如果首位是<code>1</code>，那么一共有<code>(n-1)!</code>种情况，所以如果首项是<code>2</code>，那么至少是<code>1 * (n-1)!</code>项之后了，一般地，如果首项是<code>i</code>，那么至少是<code>(i-1) * (n-1)!</code>项之后了。所以如果给定了<code>k</code>，则<code>(k-1) / (n-1)! + 1</code>就表示首项的数字，确定了首项，再使用类似的方法确定第二项，只不过这时数字应该去掉首项的数字后内选择，以此类推。整个公式可以写成：<br /><span class="math display">\[    k - 1 = a_n (n-1)! + a_{n-1} (n-2)! + \cdots + a_2 1! + a_1 1\]</span></p><p>依次求出<spanclass="math inline">\(a_i\)</span>，其表示的意思为剩下的数字按照大小排序后的<code>index</code>，即可得到答案。</p><ol type="1"><li>这里给出一个例子说明一些细节；比如<code>n=4, k=9</code>时，如何求解；首先需要计算到<spanclass="math inline">\((n-1)!\)</span>，即<spanclass="math inline">\(0!=1, 1!=1, 2!=2,3!=6\)</span>；剩下数字为<code>1 2 3 4</code>；</li><li>然后计算<span class="math inline">\(a_4=(k-1) / 3! =1\)</span>，所以首项是<code>2</code>，剩下的数字为<code>1 3 4</code>；</li><li>首项<code>2</code>确定后，即前面已经有<spanclass="math inline">\(a_4 \cdot3!=6\)</span>项了，那么就只要考虑<code>1 3 4</code>组成的排列的第<code>k-6=3</code>项了，同样的方法计算<spanclass="math inline">\(a_3 = (3 - 1) / 2! =1\)</span>，从而第二项是数字<code>3</code>；</li><li>前两项为<code>23</code>后，剩下的数字为<code>1 4</code>，前面已经确定<spanclass="math inline">\(a_4 3! + a_3 2! = 8\)</span>项，剩下<code>1</code>项，然后计算<code>a_2= (1 - 1) / 1! = 0</code>，即第三项数字为<code>1</code>；</li><li>最后一项只能是<code>4</code>；</li><li>所以排列是<code>2 3 1 4</code></li></ol><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        fractal = [<span class="number">1</span>]*n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">            fractal[i] = fractal[i-<span class="number">1</span>] * i</span><br><span class="line">        nlist = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ind = (k-<span class="number">1</span>) // fractal[n-i-<span class="number">1</span>]</span><br><span class="line">            k %= fractal[n-i-<span class="number">1</span>]</span><br><span class="line">            ans += <span class="built_in">str</span>(nlist[ind])</span><br><span class="line">            nlist.pop(ind)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解59：螺旋矩阵 II</title>
      <link href="/2022/08/03/leetcode%E9%A2%98%E8%A7%A359/"/>
      <url>/2022/08/03/leetcode%E9%A2%98%E8%A7%A359/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/spiral-matrix-ii/">力扣第59题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>该题与<ahref="https://caoqinping.com/2022/08/02/leetcode题解54/">力扣第54题</a>类似，依然是按照层数遍历，遍历到的位置将值赋给数组即可。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateMatrix</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        max_layer = (n + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        ans = [[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        number = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(max_layer):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layer, n-layer):</span><br><span class="line">                ans[layer][i] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layer+<span class="number">1</span>, n-layer):</span><br><span class="line">                ans[i][n-layer-<span class="number">1</span>] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == n *n:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-layer-<span class="number">2</span>, layer-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                ans[n-layer-<span class="number">1</span>][i] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-layer-<span class="number">2</span>, layer, -<span class="number">1</span>):</span><br><span class="line">                ans[i][layer] = number</span><br><span class="line">                number += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解57：插入区间</title>
      <link href="/2022/08/02/leetcode%E9%A2%98%E8%A7%A357/"/>
      <url>/2022/08/02/leetcode%E9%A2%98%E8%A7%A357/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/insert-interval/">力扣第57题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>这里最简单的思路就是找到区间插入的位置，然后利用上一题的思路合并区间即可。但是发现写起来不是那么方便；</p><p>本质是找到需要合并的起始区间和结束区间，当没有到达起始区间时，什么都不需要改，直接将当前区间加入到结果中；当到达起始区间时，开始合并，直到最后一个需要合并的区间结束，并将合并后的区间加入到结果中，然后将剩余的区间加入到结果中即可。也就是说只要加入一个标志位，标识是否到达的结束区间，即合并结束。</p><p>这里合并区间时，有个小优化，就是记录并更新区间的左端点和右端点即可。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], newInterval: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        left, right = newInterval</span><br><span class="line">        ans = []</span><br><span class="line">        placed = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> first, second <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> first &gt; right:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">                    ans.append([left, right])</span><br><span class="line">                    placed = <span class="literal">True</span></span><br><span class="line">                ans.append([first, second])</span><br><span class="line">            <span class="keyword">elif</span> second &lt; left:</span><br><span class="line">                ans.append([first, second])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = <span class="built_in">min</span>(left, first)</span><br><span class="line">                right = <span class="built_in">max</span>(right, second)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> placed:</span><br><span class="line">            ans.append([left, right])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解56：合并区间</title>
      <link href="/2022/08/02/leetcode%E9%A2%98%E8%A7%A356/"/>
      <url>/2022/08/02/leetcode%E9%A2%98%E8%A7%A356/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/merge-intervals/">力扣第56题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>首先两个区间能不能合并，就是判断左端点和右端点的大小关系即可；</p><p>大致思路也挺简单，首先对区间按左端点从小到大排序，然后新建一个栈存放合并好的区间，可以现将原始区间的第一个元素压入栈中，然后遍历原始区间，如果栈顶的元素与当前区间有重叠，那么就先弹出栈顶元素，将两个区间合并后压入栈中；如果没有重叠，那么就直接将当前区间压入栈中。</p><p>还有一种方法支持只在原数组上修改即可，遍历数组，判断当前第<code>i</code>个区间和第<code>i-1</code>个区间是否可以合并，如果可以合并，那么就将前一个区间的右端点修改为当前区间的右端点，并删掉第<code>i</code>个区间，保持<code>i</code>不变；如果不能合并，<code>i++</code>。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        intervals.sort()</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; <span class="built_in">len</span>(intervals):</span><br><span class="line">            <span class="keyword">if</span> intervals[i-<span class="number">1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]:</span><br><span class="line">                intervals[i-<span class="number">1</span>][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i-<span class="number">1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">                intervals.pop(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> intervals</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解55：跳跃游戏</title>
      <link href="/2022/08/02/leetcode%E9%A2%98%E8%A7%A355/"/>
      <url>/2022/08/02/leetcode%E9%A2%98%E8%A7%A355/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/jump-game/">力扣第55题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>比起<ahref="https://leetcode-cn.com/problems/jump-game-ii/">力扣第45题</a>，这道题更简单，只需要判断能否到达最后一个位置即可。每次只需记录能到达的最远位置即可。如果当前位置超过了最远位置，说明无法到达当前位置，也就无法到达最后一个位置；如果最远位置超过了最后一个位置，说明可以到达最后一个位置。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canJump</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        max_, i = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        max_ = i + nums[i]</span><br><span class="line">        <span class="keyword">while</span> (i + <span class="number">1</span>) &lt;= max_ <span class="keyword">and</span> max_ &lt; <span class="built_in">len</span>(nums) - <span class="number">1</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt;= max_:</span><br><span class="line">                max_ = <span class="built_in">max</span>(max_, i + nums[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> max_ &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解54：螺旋矩阵</title>
      <link href="/2022/08/02/leetcode%E9%A2%98%E8%A7%A354/"/>
      <url>/2022/08/02/leetcode%E9%A2%98%E8%A7%A354/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/spiral-matrix/">力扣第54题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>该题思路很简单，就是模拟螺旋遍历的过程，首先遍历最外面一圈，然后缩小一层，继续遍历这一圈，直到遍历完所有圈。遍历的总层数由矩阵的行数和列数的最小值的一半决定。确定层数后，计算出每一圈的四个角位置，然后按照顺序遍历即可。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        m = <span class="built_in">len</span>(matrix)</span><br><span class="line">        n = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        max_layer = (<span class="built_in">min</span>(m, n) + <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(max_layer):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layer, n-layer):</span><br><span class="line">                ans.append(matrix[layer][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layer+<span class="number">1</span>, m-layer):</span><br><span class="line">                ans.append(matrix[i][n-layer-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(ans) == n * m:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-layer-<span class="number">2</span>, layer-<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                ans.append(matrix[m-layer-<span class="number">1</span>][i])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-layer-<span class="number">2</span>, layer, -<span class="number">1</span>):</span><br><span class="line">                ans.append(matrix[i][layer])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题7</title>
      <link href="/2022/07/27/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%987/"/>
      <url>/2022/07/27/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%987/</url>
      
        <content type="html"><![CDATA[<p>$501. $ 在棱长都为<spanclass="math inline">\(a\)</span>cm的四面体纸盒内放一个正方体，并且能使正方体在纸盒中任意转动，则正方体棱长最大为多少cm？</p><span id="more"></span><p>$502. $ 设<span class="math inline">\(S_n\)</span>是数列<spanclass="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和，<span class="math inline">\(S_n =2a_n-3n+5 (n \in \mathbb{N^+})\)</span>，证明：不存在正整数<spanclass="math inline">\(p,q,r(p&lt;q&lt;r)\)</span>使得<spanclass="math inline">\(p,q,r\)</span>和<spanclass="math inline">\(S_p,S_q,S_r\)</span>同时成等差数列。</p><p>$503. $ 设<span class="math inline">\(A\)</span>为双曲线<spanclass="math inline">\(\displaystyle \frac{x^2}{16} - \frac{y^2}{9} =1\)</span>右支上一动点，<spanclass="math inline">\(F\)</span>双曲线的右焦点，连接<spanclass="math inline">\(AF\)</span>交双曲线右支于点<spanclass="math inline">\(B\)</span>，过<spanclass="math inline">\(B\)</span>作直线<spanclass="math inline">\(BC\)</span>垂直于直线<spanclass="math inline">\(x=\dfrac{16}{5}\)</span>，垂足为<spanclass="math inline">\(C\)</span>，则直线<spanclass="math inline">\(AC\)</span>必过定点？，如果是，求出定点坐标，否则说明原因。</p><p>$504. $ 已知<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(a=10,c-b=8\)</span>，则<span class="math inline">\(\dfrac{\tan\frac{B}{2}}{\tan \frac{C}{2}}=\)</span>?</p><p>$505. $ 设函数<span class="math inline">\(f(x) = (x+1)\ln(x+1)\)</span>，若对所有的<span class="math inline">\(x \ge0\)</span>都有<span class="math inline">\(f(x) \geax\)</span>成立，则实数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$506. $ 已知直线<span class="math inline">\(l_1: x - y = 0, l_2 x + y= 0\)</span>，点<spanclass="math inline">\(P\)</span>是线性约束条件<spanclass="math inline">\(\left\{ \begin{aligned} x - y \ge 0 \\ x + y \ge 0\end{aligned} \right.\)</span>所表示区域内一动点，<spanclass="math inline">\(PM \perp l_1, PN \perpl_2\)</span>，垂足分别为<spanclass="math inline">\(M,N\)</span>，且<spanclass="math inline">\(S_{\triangle OMN} = \dfrac{1}{2}\)</span>（<spanclass="math inline">\(O\)</span>为坐标原点）；<br />（1）求动点<span class="math inline">\(P\)</span>的轨迹方程；<br />（2）是否存在过点<span class="math inline">\((2,0)\)</span>的直线<spanclass="math inline">\(l\)</span>与（1）中的轨迹交于点<spanclass="math inline">\(A,B\)</span>，线段<spanclass="math inline">\(AB\)</span>的垂直平分线交<spanclass="math inline">\(y\)</span>轴与点<spanclass="math inline">\(Q\)</span>，且使得<spanclass="math inline">\(\triangleABQ\)</span>是等边三角形？若存在，求出<spanclass="math inline">\(l\)</span>的方程；若不存在，请说明理由。</p><p>$507. $ 设函数<span class="math inline">\(f(x) = ax - (a+1)\ln(x+1)\)</span>，当<span class="math inline">\(a&gt;0\)</span>时，设<spanclass="math inline">\(f(x)\)</span>的最小值为<spanclass="math inline">\(g(a)\)</span>，若<span class="math inline">\(g(a)&lt; t\)</span>恒成立，求实数<spanclass="math inline">\(t\)</span>的最小值。</p><p>$508. $ 已知函数<span class="math inline">\(f(x) = \left\{\begin{aligned} &amp;(x^2-2x)e^x &amp; (x&gt;0) \\ &amp;bx\end{aligned}\right.\)</span>，<span class="math inline">\(g(x) = c\ln x+ b\)</span>；<br />（1）若方程<spanclass="math inline">\(f(x)=m\)</span>有两个不相等的实数根，求<spanclass="math inline">\(m\)</span>的取值范围；<br />（2）若直线<span class="math inline">\(l\)</span>是函数<spanclass="math inline">\(f(x)\)</span>在点<span class="math inline">\((2,f(2))\)</span>出的切线，且直线<spanclass="math inline">\(l\)</span>与函数<span class="math inline">\(y =g(x)\)</span>的图像相切于点<span class="math inline">\(P(x_0,y_0), x_0\in [e^{-1}, e]\)</span>，求实数<spanclass="math inline">\(b\)</span>的取值范围。</p><p>$509. $ 已知函数<span class="math inline">\(f(x) = \dfrac{a+\sin x}{2+ \cos x}-bx, (a, b \in \mathbb{R})\)</span>，若<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(\mathbb{R}\)</span>上存在最大值，最小值，且其最大值与最小值的和为<spanclass="math inline">\(2680\)</span>，求<spanclass="math inline">\(a\)</span>和<spanclass="math inline">\(b\)</span>的值。</p><p>$510. $ 如图在<span class="math inline">\(\triangleABC\)</span>和<span class="math inline">\(\triangleAEF\)</span>中，<span class="math inline">\(B\)</span>是<spanclass="math inline">\(EF\)</span>的中点，<spanclass="math inline">\(AB=EF=1, CA=CB=2\)</span>，若<spanclass="math inline">\(\overrightarrow{AB}\cdot \overrightarrow{AE} +\overrightarrow{AC} \cdot \overrightarrow{AF}=2\)</span>，则<spanclass="math inline">\(\overrightarrow{EF}\)</span>与<spanclass="math inline">\(\overrightarrow{BC}\)</span>的夹角等于？</p><p>$511. $ 对于任意<span class="math inline">\(x \in\mathbb{R}\)</span>，函数<spanclass="math inline">\(f(x)\)</span>满足<spanclass="math inline">\(f(x+1)=\sqrt{f(x) - [f(x)]^2} +\dfrac{1}{2}\)</span>，设<span class="math inline">\(a_n = [f(x)]^2 -f(x)\)</span>，数列<span class="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(15\)</span>项和为<spanclass="math inline">\(-\dfrac{31}{16}\)</span>，则<spanclass="math inline">\(f(15)=\)</span>？</p><p>$512. $ 已知四面体<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(DA=DB=DC=3\sqrt2\)</span>，且<spanclass="math inline">\(DA，DB，DC\)</span>两两互相垂直，点<spanclass="math inline">\(O\)</span>是<span class="math inline">\(\triangleABC\)</span>的中点，将<span class="math inline">\(\triangleDAO\)</span>绕直线<spanclass="math inline">\(DO\)</span>旋转一周，则在旋转过程中，直线<spanclass="math inline">\(DA\)</span>与直线<spanclass="math inline">\(BC\)</span>所成角的余弦值的取值范围是？</p><p>$513. $ 函数<span class="math inline">\(y = -k |x-a| +b\)</span>的图像与函数<span class="math inline">\(y = k|x- c| +d\)</span>的图像（<span class="math inline">\(k&gt;0\)</span>且<spanclass="math inline">\(k \ne \dfrac{1}{3}\)</span>）交于两点<spanclass="math inline">\((2,5),(8,3)\)</span>，则<spanclass="math inline">\(\dfrac{a+c}{b+d}\)</span>的值为？</p><p>$514. $ 已知直线<span class="math inline">\(l\perp\)</span>平面<spanclass="math inline">\(\alpha\)</span>，<spanclass="math inline">\(O\)</span>为垂足，长方体<spanclass="math inline">\(ABCD-A_1B_1C_1D_1\)</span>中<spanclass="math inline">\(AD=5, AB=6,AA_1=8, A \in l, B_1 \in\alpha\)</span>，则<spanclass="math inline">\(OC_1\)</span>的最大值为？</p><p>$515. $ 若<span class="math inline">\(g(x) = |\ln x| + \dfrac{a}{x+1}(a&gt;0)\)</span>，且对任意<span class="math inline">\(x_1,x_2 \in [0,2], x_1 \ne x_2\)</span>，都有<span class="math inline">\(\dfrac{g(x_2)- g(x_1)}{x_2 - x_1} &lt; -1\)</span>，求<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$516. $ 有四根长都为<spanclass="math inline">\(2\)</span>的直铁条，若再选两根长为<spanclass="math inline">\(2\)</span>的直铁条，使这六根直铁条端点处相连能够焊接成一个三棱锥的铁架，则<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$517. $ 在<span class="math inline">\(\triangleABC\)</span>中，三边长<spanclass="math inline">\(a,b,c\)</span>满足<spanclass="math inline">\(a+c=3b\)</span>，则<spanclass="math inline">\(\tan \dfrac{A}{2} \tan\dfrac{C}{2}\)</span>的值为？</p><p>$518. $ 已知函数<span class="math inline">\(f(x) = 2 \ln x - 2x - 3,h(x) = (p-2)x - \dfrac{p+2e}{x}-3\)</span>，若在区间<spanclass="math inline">\([1,e]\)</span>上至少存在一个<spanclass="math inline">\(x_0\)</span>使得<span class="math inline">\(h(x_0)&gt; f(x_0)\)</span>处成立，求<spanclass="math inline">\(p\)</span>的取值范围。</p><p>$519. $ 设有一组圆<span class="math inline">\(C_k: (x-k+1)^2 +(y-3k)^2 = 2k^4 (k \in\mathbb{N^+})\)</span>，下列四个命题中真命题有？<br />（1）存在一条直线与所有圆相切；<br />（2）存在一条直线与所有圆相交；<br />（3）存在一条直线与所有圆都不相交；<br />（4）所有圆不经过任何圆点；</p><p>$520. $ 集合<spanclass="math inline">\(W\)</span>是满足下列两个条件的无穷数列<spanclass="math inline">\(\{a_n\}\)</span>的集合；<br />（1）<span class="math inline">\(\dfrac{a_n + a_{n+2}}{2} \lea_{n+1}\)</span>；<br />（2）<span class="math inline">\(a_n \le M; M\)</span>是与<spanclass="math inline">\(n\)</span>无关的常数；<br />设数列<spanclass="math inline">\(\{c_n\}\)</span>的各项都为正整数，且<spanclass="math inline">\(\{c_n\} \in W\)</span>，求证<spanclass="math inline">\(c_n \le C_{n+1}\)</span>。</p><p>$521. $ 设函数<span class="math inline">\(f(x) = x^2 + ax + b (a,b\in \mathbb{R})\)</span>，满足不等式<span class="math inline">\(|f(x)|\le |x^2 + 2x - 3|\)</span>恒成立，定义数列<spanclass="math inline">\(\{a_n\}\)</span>和数列<spanclass="math inline">\(\{b_n\}\)</span>，<span class="math inline">\(a_1= 3, 2a_n=f(a_{n-1}) + 3 (n \ge 3, n \in \mathbb{N^+}), b_n =\dfrac{1}{a_n + 2}(n \in \mathbb{N^+})\)</span>，数列<spanclass="math inline">\(\{b_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>；<br />（1）求证：<span class="math inline">\(S_n &lt;\dfrac{1}{3}\)</span>；<br />（2）求证：<span class="math inline">\(a_n &gt; 2^{2^{n-1}} -1\)</span>。</p><p>$522. $ 已知数列<span class="math inline">\(a_n\)</span>的前<spanclass="math inline">\(n\)</span>项和<span class="math inline">\(S_n =\dfrac{n}{2}a_n (n \in \mathbb{N+})\)</span>，且<spanclass="math inline">\(a_2=1, b_n = (1 + \dfrac{1}{2a_n+2})^{a_{n+1}} (n\in \mathbb{N+})\)</span>；<br />（1）已知定理：若函数<spanclass="math inline">\(f(x)\)</span>在区域<spanclass="math inline">\(D\)</span>是凹函数，且<spanclass="math inline">\(f^\prime(x)\)</span>存在，则当<spanclass="math inline">\(x&gt;y (x,y \in D)\)</span>时，总有<spanclass="math inline">\(\dfrac{f(x) - f(y)}{x-y} \lef^\prime(x)\)</span>，若函数<span class="math inline">\(y = x^{n+1} (n\in \mathbb{N}^+)\)</span>在<span class="math inline">\((0,+\infty)\)</span>上是凹函数，试判断<spanclass="math inline">\(b_n,b_{n+1}\)</span>的大小；<br />（2）求证：<span class="math inline">\(\dfrac{3}{2} \le b_n &lt;2\)</span>。</p><p>$523. $ 已知函数<span class="math inline">\(f(x) = x^2 + x -1\)</span>，<span class="math inline">\(\alpha,\beta\)</span>是方程<spanclass="math inline">\(f(x)=0\)</span>的两个根（<spanclass="math inline">\(\alpha &gt; \beta\)</span>），<spanclass="math inline">\(f^\prime(x)\)</span>是<spanclass="math inline">\(f(x)\)</span>的导数，设<spanclass="math inline">\(a_1 = 1, a_{n+1} - \dfrac{f(a_n)}{f^\prime(a_n)}(n=1,2,\cdots)\)</span>；<br />（1）证明：对任意的正整数<span class="math inline">\(n\)</span>都有<spanclass="math inline">\(a_n &gt; \alpha\)</span>；<br />（2）记<span class="math inline">\(b_n = \ln \dfrac{a_n - \beta}{a_n -\alpha}\)</span>，求数列<spanclass="math inline">\(\{b_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和。</p><p>$524. $ 已知<span class="math inline">\(A,B\)</span>分别为曲线<spanclass="math inline">\(C: \dfrac{x^2}{a^2} + y^2 = 1 (y \ge 0, a &gt;0)\)</span>与<spanclass="math inline">\(x\)</span>轴的左右两个交点，直线<spanclass="math inline">\(l\)</span>过点<spanclass="math inline">\(B\)</span>且与<spanclass="math inline">\(x\)</span>轴垂直，<spanclass="math inline">\(S\)</span>为<spanclass="math inline">\(l\)</span>上异于<spanclass="math inline">\(B\)</span>的一点，连接<spanclass="math inline">\(AS\)</span>交曲线<spanclass="math inline">\(l\)</span>于点<spanclass="math inline">\(T\)</span>，点<spanclass="math inline">\(M\)</span>是以<spanclass="math inline">\(SB\)</span>为直径的圆与线段<spanclass="math inline">\(TB\)</span>的交点，试问：是否存在<spanclass="math inline">\(a\)</span>，使得<spanclass="math inline">\(O,M,S\)</span>三点共线？若存在，求出<spanclass="math inline">\(a\)</span>的值。</p><p>$525. $ 已知双曲线<span class="math inline">\(C: \dfrac{x^2}{a^2} -\dfrac{y^2}{b^2} = 1 (a &gt; 0, b&gt;0)\)</span>，<spanclass="math inline">\(B\)</span>是右顶点，<spanclass="math inline">\(F\)</span>是右焦点，<spanclass="math inline">\(A\)</span>点在<spanclass="math inline">\(x\)</span>轴正半轴上，且满足<spanclass="math inline">\(|\overrightarrow{OA}|, |\overrightarrow{OB}|,|\overrightarrow{OF}|\)</span>成等比数列，过点<spanclass="math inline">\(F\)</span>作双曲线在一、三象限的渐近线的垂线<spanclass="math inline">\(l\)</span>，垂足为<spanclass="math inline">\(P\)</span>；<br />（1）求证：<span class="math inline">\(\overrightarrow{PA} \cdot\overrightarrow{OP} = \overrightarrow{PA} \cdot\overrightarrow{FP}\)</span>；<br />（2）若<span class="math inline">\(l\)</span>与双曲线<spanclass="math inline">\(C\)</span>的左右两支分别交于<spanclass="math inline">\(D,E\)</span>，求双曲线<spanclass="math inline">\(C\)</span>的离心率<spanclass="math inline">\(e\)</span>的取值范围。</p><p>$526. $ 在棱长为<spanclass="math inline">\(1\)</span>的正方体中，有两个球相外切并且分别于正方体的面相切，球的半径为多少时，两球体积之和最小？</p><p>$527. $ 已知<span class="math inline">\(f(x) = x^2 + (a-3)x + a^2 -3a\)</span>；<br />（1）设实数<span class="math inline">\(p,q,r\)</span>满足<spanclass="math inline">\(p,q,r\)</span>中的某一个数为<spanclass="math inline">\(a\)</span>，且另外两个恰为方程<spanclass="math inline">\(f(x)=0\)</span>的两实根，判断<spanclass="math inline">\(\textcircled 1 \ p + q + r\)</span>，<spanclass="math inline">\(\textcircled 2 \ p^2 + q^2 + r^2\)</span>，<spanclass="math inline">\(\textcircled 3 \ p^3 + q^3 +r^3\)</span>是否为定值，若是定值，请求出；若不是定值，请把不是定值的表示为函数<spanclass="math inline">\(g(a)\)</span>，并求<spanclass="math inline">\(g(a)\)</span>的最小值；<br />（2）对于（1）中的<span class="math inline">\(g(a)\)</span>，设<spanclass="math inline">\(H(a) = -\dfrac{1}{6}[g(a) -27]\)</span>，数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_{n+1} = H(a_n) (n \in \mathbb{N^+}), a_n \in (0,1)\)</span>，试判断<span class="math inline">\(a_{n+1}\)</span>与<spanclass="math inline">\(a_n\)</span>的大小。并证明。</p><p>$528. $ 设<span class="math inline">\(V\)</span>是已知平面<spanclass="math inline">\(M\)</span>上所有向量的集合，对于映射<spanclass="math inline">\(f: V \to V, \vec a \in V\)</span>，记<spanclass="math inline">\(\vec a\)</span>的象为<spanclass="math inline">\(f(\vec a)\)</span>，若映射<spanclass="math inline">\(f\)</span>满足：对所有<spanclass="math inline">\(\vec a, \vec b \in V\)</span>及任意实数<spanclass="math inline">\(\lambda, \mu\)</span>，都有<spanclass="math inline">\(f(\lambda \vec a + \mu \vec b) = \lambda f(\vec a)+ \mu f(\vec a)\)</span>，则称<spanclass="math inline">\(f\)</span>为平面<spanclass="math inline">\(M\)</span>上的线性变换，现有下列命题：<br /><span class="math inline">\(\textcircled{1}\)</span> 设<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(M\)</span>上的线性变换，则<spanclass="math inline">\(f(\vec 0) = \vec 0\)</span>；<br /><span class="math inline">\(\textcircled{2}\)</span> 对于<spanclass="math inline">\(\vec a \in V\)</span>，则<spanclass="math inline">\(f(\vec a) = 2 \vec a\)</span>，则<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(M\)</span>上的线性变换；<br /><span class="math inline">\(\textcircled{3}\)</span> 若<spanclass="math inline">\(\vec e\)</span>是平面<spanclass="math inline">\(M\)</span>上的单位向量，对<spanclass="math inline">\(\vec a \in V\)</span>，设<spanclass="math inline">\(f(\vec a) = \vec a - \vec e\)</span>，则<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(M\)</span>上的线性变换；<br /><span class="math inline">\(\textcircled{4}\)</span> 设<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(M\)</span>上的线性变换，<spanclass="math inline">\(\vec a, \vec b \in V\)</span>，若<spanclass="math inline">\(vec a, \vec b\)</span>共线，则<spanclass="math inline">\(f(\vec a)\)</span>与<spanclass="math inline">\(f(\vec b)\)</span>也共线；<br />其中真命题有?</p><p>$529. $ 已经集合<span class="math inline">\(A = \{a_1,a_2,\dots,a_k\} (k \ge 2)\)</span>，其中<span class="math inline">\(a_i \in\mathbb{Z} (i=1,2,\cdots,k)\)</span>，有<spanclass="math inline">\(A\)</span>中的元素构成两个相应的集合：<spanclass="math inline">\(S = \{ (a, b) \mid a \in A, b \in A , a+b \in A\},T = \{(a,b) \mid a \in A, b \in A, a - b \in A\}\)</span>，其中<spanclass="math inline">\((a,b)\)</span>是有序数对，集合<spanclass="math inline">\(S\)</span>和<spanclass="math inline">\(T\)</span>中的元素个数分别为<spanclass="math inline">\(m,n\)</span>，若对任意的<spanclass="math inline">\(a \in A\)</span>，总有<spanclass="math inline">\(-a \in A\)</span>，则称集合具有性质<spanclass="math inline">\(P\)</span>；<br />（1）对任何具有性质<span class="math inline">\(P\)</span>的集合<spanclass="math inline">\(A\)</span>，证明<span class="math inline">\(n \le\dfrac{k(k-1)}{2}\)</span>；<br />（2）判断<span class="math inline">\(m\)</span>和<spanclass="math inline">\(n\)</span>的大小关系，并证明你的结论。</p><p>$530. $ 若对给定的实数<span class="math inline">\(a(a \ne0)\)</span>函数<span class="math inline">\(y = f(x+a)\)</span>与<spanclass="math inline">\(y = f^{-1}(x+a)\)</span>互为反函数，则称<spanclass="math inline">\(y = f(x)\)</span>满足<spanclass="math inline">\(a\)</span>和性质；若对函数<spanclass="math inline">\(y = f(ax)\)</span>和<span class="math inline">\(y= f^{-1}(ax)\)</span>互为反函数，则称<span class="math inline">\(y =f(x)\)</span>满足<span class="math inline">\(a\)</span>积性质；<br />（1）求所有满足<spanclass="math inline">\(2\)</span>和性质的一次函数；<br />（2）设函数<span class="math inline">\(y = f(x) (x&gt;0)\)</span>，对任何<span class="math inline">\(a &gt;0\)</span>，满足<span class="math inline">\(a\)</span>积性质，求<spanclass="math inline">\(y = f(x)\)</span>的表达式。</p><p>$531. $ 若<span class="math inline">\(x^4 + ax - 4 =0\)</span>的各个实根<span class="math inline">\(x_1,x_2,\cdots,x_k (k\le4)\)</span>，所对应的点<span class="math inline">\((x_i, \dfrac{4}{x_i})(i=1,2,\cdots,k)\)</span>均在直线<spanclass="math inline">\(y=x\)</span>的同侧，则实数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$532. $ 若<span class="math inline">\(x_1\)</span>满足<spanclass="math inline">\(2x + 2^x = 5\)</span>，<spanclass="math inline">\(x_2\)</span>满足<span class="math inline">\(2x +2\log_2 (x-1) = 5\)</span>，则<spanclass="math inline">\(x_1+x_2=\)</span>？</p><p>$533. $ 设函数<span class="math inline">\(f_1(x) =3^{|x-p_1|}\)</span>，<span class="math inline">\(f_2(x) = 2 \cdot 3^{|x- p_2|}\)</span>，<span class="math inline">\(x \in\mathbb{R}\)</span>，<spanclass="math inline">\(p_1,p_2\)</span>为常数，函数<spanclass="math inline">\(f(x)\)</span>定义为，对任意的实数<spanclass="math inline">\(x\)</span>，<span class="math inline">\(f(x) =\left\{ \begin{aligned} &amp; f_1(x) &amp; f_1(x) \le f_2(x) \\&amp;f_2(x) &amp; f_1(x) &gt; f_2(x)\end{aligned}\right.\)</span>；<br />（1）求<span class="math inline">\(f(x) =f_1(x)\)</span>对任意的实数<spanclass="math inline">\(x\)</span>都成立的充分必要条件；<br />（2）设<span class="math inline">\(a,b\)</span>为两个实数，<spanclass="math inline">\(a&lt;b\)</span>，且<spanclass="math inline">\(p_1,p_2 \in (a, b)\)</span>，若<spanclass="math inline">\(f(a) = f(b)\)</span>，求证：<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([a,b]\)</span>上的单调增区间的长度和为<spanclass="math inline">\(\dfrac{b-a}{2}\)</span>。</p><p>$534. $ 在锐角三角形<span class="math inline">\(ABC\)</span>中，<spanclass="math inline">\(BC=1, B=2A\)</span>，则<spanclass="math inline">\(AC\)</span>的取值范围是？</p><p>$535. $ 若有穷数列<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>（<spanclass="math inline">\(n\)</span>是正整数），满足<spanclass="math inline">\(a_1 = a_n, a_2 = a_{n-1}, \cdots a_n =a_1\)</span>，即<span class="math inline">\(a_i =a_{n-i+1}\)</span>（<spanclass="math inline">\(i\)</span>是正整数，且<spanclass="math inline">\(1 \le i \len\)</span>），就称数列为对称数列。对于给定的正整数<spanclass="math inline">\(m&gt;1\)</span>，试写出所有项数不超过<spanclass="math inline">\(2m\)</span>的对称数列，使得<spanclass="math inline">\(1,2,2^2,\cdots,2^{m-1}\)</span>依次是数列中连续的项，当<spanclass="math inline">\(m&gt;1500\)</span>时，求其中一个数列的前<spanclass="math inline">\(2008\)</span>项和<spanclass="math inline">\(S_{2008}\)</span>。</p><p>$536. $ 设<span class="math inline">\(S_n\)</span>是数列<spanclass="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和，<span class="math inline">\(a_1 =a, S_n^2 = 3n^2a_n + S_{n-1}^2, a_n \ne 0,n=2,3,\cdots\)</span>，试找出一个奇数<spanclass="math inline">\(a\)</span>，使以<spanclass="math inline">\(18\)</span>为首项，<spanclass="math inline">\(7\)</span>为公比的等比数列<spanclass="math inline">\(\{b_n\}\)</span>中所有项都是数列<spanclass="math inline">\(\{a_n\}\)</span>中的项并指出<spanclass="math inline">\(b_n\)</span>是数列<spanclass="math inline">\(\{a_n\}\)</span>中的第几项。</p><p>$537. $ 设<span class="math inline">\(m\)</span>个不全相等的正数<spanclass="math inline">\(a_1,a_2,\cdots,a_m (m \ge7)\)</span>依次围成一个圈，若每个数<span class="math inline">\(a_n (n\le m)\)</span>是其左右相邻两数的平分的等比中项，求证<spanclass="math inline">\(a_1 + \cdots + a_6 + a_7^2 + \cdots + a_m^2 &gt; ma_1 \cdots a_m\)</span>。</p><p>$538. $ 对于数列<spanclass="math inline">\(\{\mu_n\}\)</span>，若存在常数<spanclass="math inline">\(M &gt; 0\)</span>，对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，恒有<spanclass="math inline">\(|\mu_{n+1} - \mu_n| + |\mu_n - \mu_{n-1}| + \cdots+ |\mu_2 - \mu_1| \le M\)</span>，则称该数列<spanclass="math inline">\(\{\mu_n\}\)</span>为<spanclass="math inline">\(B-\)</span>数列；<br />（1）设<span class="math inline">\(S_n\)</span>是数列<spanclass="math inline">\(\{x_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和，给出下列两组论断：<br />A组：<span class="math inline">\(\textcircled{1}\)</span> 数列<spanclass="math inline">\(\{x_n\}\)</span>是<spanclass="math inline">\(B-\)</span>数列；<spanclass="math inline">\(\textcircled{2}\)</span> 数列<spanclass="math inline">\(\{x_n\}\)</span>不是<spanclass="math inline">\(B-\)</span>数列；<br />B组：<span class="math inline">\(\textcircled{1}\)</span> 数列<spanclass="math inline">\(\{S_n\}\)</span>是<spanclass="math inline">\(B-\)</span>数列；<spanclass="math inline">\(\textcircled{2}\)</span> 数列<spanclass="math inline">\(\{S_n\}\)</span>不是<spanclass="math inline">\(B-\)</span>数列；<br />请以其中一组中的一个论断为条件，另一组中的一个论断为结论，组成一个命题，判断所给命题的真假，并证明你的结论；<br />（2）若数列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>都是<spanclass="math inline">\(B-\)</span>数列；证明数列<spanclass="math inline">\(\{a_nb_n\}\)</span>也是<spanclass="math inline">\(B-\)</span>数列。</p><p>$539. $ 如图，过圆<span class="math inline">\(C: (x - 1)^2 + (y-1)^2= 1\)</span>的圆心作直线分别于<spanclass="math inline">\(x,y\)</span>正半轴交于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(\triangleAOB\)</span>被圆分成四部分，若这四部分图像的面积满足<spanclass="math inline">\(S_{\mathrm{I}} + S_{\mathrm{IV}} = S_{\mathrm{II}}+ S_{\mathrm{III}}\)</span>，证明这样的直线只有一条。</p><p>$540. $ 点<span class="math inline">\(P(x_0,y_0)\)</span>在椭圆<spanclass="math inline">\(\dfrac{x^2}{a^2} + \dfrac{y^2}{b^2} = 1 (a &gt;b&gt; 0)\)</span>上，<span class="math inline">\(x_0 = a\cos \beta, y_0= a \sin \beta, 0 &lt; \beta &lt; \dfrac{\pi}{2}\)</span>，直线<spanclass="math inline">\(l_2\)</span>与直线<span class="math inline">\(l_1:\dfrac{x_0x}{a^2} + \dfrac{y_0y}{b^2}=1\)</span>垂直，<spanclass="math inline">\(O\)</span>为坐标原点；直线<spanclass="math inline">\(OP\)</span>的倾斜角为<spanclass="math inline">\(\alpha\)</span>，直线<spanclass="math inline">\(l_2\)</span>的倾斜角为<spanclass="math inline">\(\gamma\)</span>；<br />（1）证明：点<span class="math inline">\(P\)</span>是椭圆<spanclass="math inline">\(\dfrac{x^2}{a^2} +\dfrac{y^2}{b^2}=1\)</span>与直线<spanclass="math inline">\(l_1\)</span>的唯一交点；<br />（2）证明：<span class="math inline">\(\tan \alpha, \tan \beta, \tan\gamma\)</span>构成等比数列。</p><p>$541. $ 已知椭圆<span class="math inline">\(\dfrac{x^2}{a^2} +\dfrac{y^2}{b^2} = 1 (a &gt; b &gt;0)\)</span>的两个焦点分别为<spanclass="math inline">\(F_1(-c,0), F_2(c,0) (c&gt;0)\)</span>，过点<spanclass="math inline">\(E(\dfrac{a^2}{c},0)\)</span>的直线与椭圆相交于<spanclass="math inline">\(A,B\)</span>两点，且<spanclass="math inline">\(\overrightarrow{F_1A} \parallel\overrightarrow{F_2B}, |\overrightarrow{F_1A}| =2|\overrightarrow{F_2B}|\)</span>；<br />（1）求椭圆的离心率与直线<spanclass="math inline">\(AB\)</span>的斜率；<br />（2）设点<span class="math inline">\(C\)</span>是<spanclass="math inline">\(A\)</span>点关于坐标原点的对称点，直线<spanclass="math inline">\(F_2B\)</span>上有一点<spanclass="math inline">\(H(m,n)(m \ne 0)\)</span>在<spanclass="math inline">\(\triangle AF_1C\)</span>的外接圆上，求<spanclass="math inline">\(\dfrac{n}{m}\)</span>的值。</p><p>$542. $ 过双曲线<span class="math inline">\(x^2 - y^2 =4\)</span>的右焦点<span class="math inline">\(F\)</span>作倾斜角为<spanclass="math inline">\(105^\circ\)</span>的直线交双曲线于<spanclass="math inline">\(P,Q\)</span>两点，则<spanclass="math inline">\(|FP| \cdot |FQ|\)</span>的值为？</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解53：最大子序和</title>
      <link href="/2022/07/24/leetcode%E9%A2%98%E8%A7%A353/"/>
      <url>/2022/07/24/leetcode%E9%A2%98%E8%A7%A353/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/maximum-subarray/">力扣第53题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>先说一种相对直观的思路：初始化当前和为0，遍历数组，求当前和，与全局最大和比较大小，并更新全局最大和；如果当前和小于0，则表示包含当前值得子数组的和一定不可能是最大值，所以当前和重置为0。</p><p>另一种等价的思路是动态规划，记<code>dp[i]</code>是以第<code>i</code>个数结尾的子数组的最大和，那么考虑以第<code>i+1</code>个数结尾的子数组的最大和，以第<code>i+1</code>个数结尾的子数组的最大和有两种情况，一种是<code>dp[i]+nums[i+1]</code>，一种是<code>nums[i+1]</code>；从而<code>dp[i+1]=max(nums[i], dp[i]+nums[i+1])</code>。然后再求<code>dp</code>数组的最大值就可以，这里也可以用全局最大来更新。这里可以看到<code>dp[i+1]</code>只与<code>dp[i]</code>有关，所以可以压缩数组，用一个数表示就好了。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans, curr = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">            curr = <span class="built_in">max</span>(nums[i], curr+nums[i])</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, curr)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解52：N皇后 II</title>
      <link href="/2022/07/24/leetcode%E9%A2%98%E8%A7%A352/"/>
      <url>/2022/07/24/leetcode%E9%A2%98%E8%A7%A352/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/n-queens-ii/">力扣第52题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>思路和<ahref="https://caoqinping.com/2022/07/24/leetcode%E9%A2%98%E8%A7%A351/">第51题</a>一样，只不过不是输出数组，而是计数</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.dfs([], n)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, all_cols, n</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.find_candidates(all_cols, n):</span><br><span class="line">            all_cols.append(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(all_cols) == n:</span><br><span class="line">                self.ans += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            self.dfs(all_cols, n)</span><br><span class="line">            all_cols.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_candidates</span>(<span class="params">self, all_cols, n</span>):</span><br><span class="line">        all_valid = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isvalid(all_cols, i):</span><br><span class="line">                all_valid.append(i)</span><br><span class="line">        <span class="keyword">return</span> all_valid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isvalid</span>(<span class="params">self, all_cols, col</span>):</span><br><span class="line">        row = <span class="built_in">len</span>(all_cols)</span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_cols):</span><br><span class="line">            <span class="keyword">if</span> c == col <span class="keyword">or</span> <span class="built_in">abs</span>(row - r) == <span class="built_in">abs</span>(col - c):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解51：N皇后</title>
      <link href="/2022/07/24/leetcode%E9%A2%98%E8%A7%A351/"/>
      <url>/2022/07/24/leetcode%E9%A2%98%E8%A7%A351/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/n-queens/">力扣第51题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>首先每个皇后只能在一行，同一行的不行，那么就可以用一个长度为<code>n</code>的数组记录当前的状态，比如<code>[1, 3, 0, 2]</code>表示，第<code>0</code>、<code>1</code>、<code>2</code>，<code>3</code>个皇后分别在<code>1</code>、<code>3</code>、<code>0</code>、<code>2</code>列；要放置<code>n</code>个皇后，大致用一下过程解决：<br />1.由于每行必有且只有一个皇后，所以在第一行放置一个，可以放置到任意列；<br />2.考虑下一行的皇后能够放到的位置，即可以放置的列有哪些？遍历所有可能，并继续考虑下一行</p><p>这样的过程，可以考虑为一棵树，然后深度优先遍历这棵树，得到的就是所有可能的方案；考虑遍历到其中某个结点<code>node</code>时，当前<code>k</code>个皇后的放置状态为数组<code>arr</code>，那么先找出第<code>k+1</code>个皇后的所有可能列<code>candidates</code>，然后遍历<code>candidates</code>，首先将第<code>k+1</code>个皇后的状态更新到<code>arr</code>，然后判断<code>arr</code>的长度是否达到了<code>n</code>，如果是，表明找到了一个解，记录下来；没有继续放置<code>k+2</code>，当<code>node</code>结点下面的所有可能都遍历完后，表示<code>node</code>结点已经完成了，应该要更新<code>node</code>结点的兄弟结点了，这是需要还原第<code>k</code>个皇后放置前的状态，即回溯下<code>arr</code>。</p><p>在已知前<code>k</code>个皇后状态数组<code>arr</code>的情况下，如何找到第<code>k+1</code>个皇后的所有可能列呢？仔细推导下发现，同一列的去掉，同一斜线的去掉，同一列的简单，就是<code>arr</code>中的值，同一斜线的就是列之差的绝对值和行之差的绝对值相等。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs([], n, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, all_cols, n, ans</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> self.find_candidates(all_cols, n):</span><br><span class="line">            all_cols.append(c)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(all_cols) == n:</span><br><span class="line">                ans.append(self.format_ans(all_cols))</span><br><span class="line"></span><br><span class="line">            self.dfs(all_cols, n, ans)</span><br><span class="line">            all_cols.pop()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_candidates</span>(<span class="params">self, all_cols, n</span>):</span><br><span class="line">        all_valid = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> self.isvalid(all_cols, i):</span><br><span class="line">                all_valid.append(i)</span><br><span class="line">        <span class="keyword">return</span> all_valid</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isvalid</span>(<span class="params">self, all_cols, col</span>):</span><br><span class="line">        row = <span class="built_in">len</span>(all_cols)</span><br><span class="line">        <span class="keyword">for</span> r, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(all_cols):</span><br><span class="line">            <span class="keyword">if</span> c == col <span class="keyword">or</span> <span class="built_in">abs</span>(row - r) == <span class="built_in">abs</span>(col - c):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">format_ans</span>(<span class="params">self, ans</span>):</span><br><span class="line">        s = [<span class="string">&#x27;.&#x27;</span>*i + <span class="string">&#x27;Q&#x27;</span> + <span class="string">&#x27;.&#x27;</span>*(<span class="built_in">len</span>(ans)-i-<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> ans]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解50：Pow(x, n)</title>
      <link href="/2022/07/23/leetcode%E9%A2%98%E8%A7%A350/"/>
      <url>/2022/07/23/leetcode%E9%A2%98%E8%A7%A350/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/powx-n/">力扣第50题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>一个非常简单的思路就是递归，当<code>n</code>是偶数时，计算<code>pow(x,n/2)*pow(x,n/2)</code>，则<code>n</code>是奇数时，计算<code>x * pow(x,(n-1)/2) * pow(x, (n-1)/2)</code>，一直递归直到<code>n</code>为1。</p><p>这里介绍另一种方法，使用迭代。考虑<spanclass="math inline">\(x^n\)</span>时，将<spanclass="math inline">\(n\)</span>表示成二进制<spanclass="math inline">\(a_k \times 2^k + a_{k-1} \times 2^(k-1) + \cdots +a_0 \times 2^0\)</span>，从而<br /><span class="math display">\[    x^n = x^{a_k 2^k} \times x^{a_{k-1} 2^{k-1}} \times \cdots \timesx^{a_0 2^0}\]</span><br />其中<span class="math inline">\(a_i (i=0,1,\cdots,k)\)</span>取值为<spanclass="math inline">\(0\)</span>或<spanclass="math inline">\(1\)</span>；</p><p>又因为<span class="math inline">\(x^{2^k} =(x^{2^{k-1}})^2\)</span>，所以只需要依次计算<spanclass="math inline">\(x^{2^i}\)</span>，当第<spanclass="math inline">\(i\)</span>为二进制位<spanclass="math inline">\(a_i=1\)</span>时，将<spanclass="math inline">\(x^{2^i}\)</span>计入结果就好。</p><p>那<span class="math inline">\(x^{10}\)</span>为例，<spanclass="math inline">\(10\)</span>的二进制为<spanclass="math inline">\(1010\)</span>，计算每个<spanclass="math inline">\(x^{2^i}\)</span>，就是<spanclass="math inline">\(x^8 \quad x^4 \quad x^2 \quadx\)</span>，二进制位为1的有<span class="math inline">\(2^8 \quad2^2\)</span>，所以<span class="math inline">\(x^{10} = x^8 \timesx^2\)</span>。</p><h2 id="算法">算法</h2><ol type="1"><li>初始化结果为<code>ans = 1</code>，循环直到<code>n == 0</code>;</li><li>判断<code>n</code>的末尾是不是1，如果是1，则执行第3步；</li><li>记录结果，<code>ans *= x</code></li><li>更新<code>x</code>，<code>x *= x</code></li><li>将<code>n</code>右移一位</li></ol><p>上述算法只考虑<code>n&gt;=0</code>的情况，若<code>n&lt;0</code>，则计算<code>1 / pow(x, -n)</code>即可</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mypow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> n &amp; <span class="number">1</span>:</span><br><span class="line">                ans *= x</span><br><span class="line">            x *= x</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myPow</span>(<span class="params">self, x: <span class="built_in">float</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.mypow(x, -n)</span><br><span class="line">        <span class="keyword">return</span> self.mypow(x, n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解49：字母异位词分组</title>
      <link href="/2022/07/23/leetcode%E9%A2%98%E8%A7%A349/"/>
      <url>/2022/07/23/leetcode%E9%A2%98%E8%A7%A349/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/group-anagrams/">力扣第49题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>该题思路很简单，就是如何判断两个字符串是字母异位词，就是两个单词含有的字符串是一样的，有很多判断方法，比如两个字符串排序后相等，又比如两个字符串含有的不同字母的个数是一样的，等等；将计算的值作为字典的key，然后key相等的就放到一起。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            k = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(s))</span><br><span class="line">            d[k] = d.get(k, []) + [s]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(d.values())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解48：旋转图像</title>
      <link href="/2022/07/23/leetcode%E9%A2%98%E8%A7%A348/"/>
      <url>/2022/07/23/leetcode%E9%A2%98%E8%A7%A348/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/rotate-image/">力扣第48题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>通过观察示例可以发现，本质是<spanclass="math inline">\((i,j)\)</span>替换到<spanclass="math inline">\((j, n-i-1)\)</span>，如<spanclass="math inline">\((0,0)\rightarrow(0,n-1) \rightarrow (n-1, n-1)\rightarrow (n-1, 0) \rightarrow(0, 0)\)</span>；</p><p>以示例2为例，<spanclass="math inline">\(5,11,16,15\)</span>构成一个循环替换，之后是<spanclass="math inline">\(1,10,12,13\)</span>，然后<spanclass="math inline">\(9, 7, 14, 2\)</span>，这样最外面一圈就替换完成了，然后缩小一圈重复上面操作就好。</p><h2 id="算法">算法</h2><ol type="1"><li>遍历所有层layer，从第0层遍历到<span class="math inline">\(n //2\)</span>层就好；</li><li>利用上面的替换公式开始循环替换，<code>matrix[layer][i] -&gt; matrix[i][n-layer-1]-&gt;matrix[n-layer-1][n-i-1]-&gt;matrix[n-i-1][layer]-&gt;matrix[layer][i]</code>；其中<code>i</code>从<code>layer</code>到<code>n-layer-2</code>；</li></ol><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> <span class="built_in">range</span>(n // <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(layer, n-layer-<span class="number">1</span>):</span><br><span class="line">                t = matrix[layer][i]</span><br><span class="line">                matrix[layer][i] = matrix[n-i-<span class="number">1</span>][layer]</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][layer] = matrix[n-layer-<span class="number">1</span>][n-i-<span class="number">1</span>]</span><br><span class="line">                matrix[n-layer-<span class="number">1</span>][n-i-<span class="number">1</span>] = matrix[i][n-layer-<span class="number">1</span>]</span><br><span class="line">                matrix[i][n-layer-<span class="number">1</span>] = t</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解47：全排列 II</title>
      <link href="/2022/07/16/leetcode%E9%A2%98%E8%A7%A347/"/>
      <url>/2022/07/16/leetcode%E9%A2%98%E8%A7%A347/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/permutations-ii/">力扣第47题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>类似<ahref="https://caoqinping.com/2022/05/21/leetcode%E9%A2%98%E8%A7%A340/">第40题</a>对于<ahref="https://caoqinping.com/2022/05/21/leetcode%E9%A2%98%E8%A7%A339/">第39题</a>的改变一样，在<ahref="https://caoqinping.com/2022/07/16/leetcode%E9%A2%98%E8%A7%A346/">第46题</a>的基础上，每次遍历的时候，注意跳过重复数字就好，至于跳过重复数组的方法，有很多种；比如先对数组排序，然后判断前后两个数字是否一样，一样就跳过；又或者初始化一个集合，然后判断集合中是否包含遍历到的数字，包含就跳过。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums = <span class="built_in">sorted</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> subres <span class="keyword">in</span> self.permuteUnique(nums[:i] + nums[i+<span class="number">1</span>:]):</span><br><span class="line">                res.append([nums[i]] + subres)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解46：全排列</title>
      <link href="/2022/07/16/leetcode%E9%A2%98%E8%A7%A346/"/>
      <url>/2022/07/16/leetcode%E9%A2%98%E8%A7%A346/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/permutations/">力扣第46题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>子问题分解，比如说要排列<code>1 2 3</code>，那就先取<code>1</code>，全排列<code>2 3</code>，得到<code>1 2 3</code>和<code>1 3 2</code>，依次下去，直到取完所有的数字。相当于全排列<code>n</code>个数，可以先求<code>n-1</code>个数的全排列，分解成一个子问题，显然用递归求解非常简单。</p><p>至于代码上的编写技巧，非<code>python</code>，取第<code>i</code>个数时，可以先与第<code>0</code>个数交换，然后排列数组的后<code>n-1</code>位，最后再交换回来就可以了。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permute</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> subres <span class="keyword">in</span> self.permute(nums[:i] + nums[i+<span class="number">1</span>:]):</span><br><span class="line">                res.append([nums[i]] + subres)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解45：跳跃游戏 II</title>
      <link href="/2022/07/16/leetcode%E9%A2%98%E8%A7%A345/"/>
      <url>/2022/07/16/leetcode%E9%A2%98%E8%A7%A345/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/jump-game-ii/">力扣第45题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>仔细想想，如果从当前位置<spanclass="math inline">\(i\)</span>最远可以第<spanclass="math inline">\(i+k\)</span>个位置，那么从当前位置跳到<spanclass="math inline">\(i+1\)</span>到<spanclass="math inline">\(i+k\)</span>位置的步数是一样的，比如<code>nums=[2,3,1,1,4]</code>，那么从<spanclass="math inline">\(i=0\)</span>开始跳，最远可以跳跃到<spanclass="math inline">\(i+nums[i]=2\)</span>个位置，即要到达<code>3 1</code>只需一步，那么写算法的时候，可以一次更新每个位置要达到的最小步数，但是显然可以继续优化；</p><p>有必要每次往后更新每个位置的步数吗？因为从位置<code>0</code>最远能跳到位置<code>2</code>，所以位置<code>1,2</code>都是<code>1</code>步到达，只有当超过位置<code>2</code>位置时，步数才去更新（+1），这样就好了；</p><p>此时考虑另一个问题，到达位置<code>1,2</code>的最小步数确定了，那后面的位置怎么确定呢？显然是位置<code>1,2</code>之中能跳到的最远距离了，所以遍历时，还需要计算<code>j+nums[j]</code>的最大值，即跳<code>2</code>步能达到的最大距离，其中<code>j</code>是跳<code>1</code>步能达到的最远距离。</p><h2 id="算法">算法</h2><ol type="1"><li>首先令<code>step</code>为到达当前位置所需的步数，显然到达初始位置只需<code>0</code>步，从而设置初始<code>step=0</code>；令<code>currReach</code>为当前能达到的最远位置，显然设置初始<code>currReach=0</code>；令<code>nextReach</code>为下一个能达到的最远位置，同样初始<code>nextReach=0</code>；</li><li>遍历数组<code>i in [0, n-1]</code></li><li>判断当前位置<code>i</code>是否超过了<code>currReach</code>，如果是，则执行第4步，否则执行第5步；</li><li>超过了，那么<code>step=step+1</code>，且<code>currReach = nextReach</code>，即当前能到达的最远距离更新为下一次能到达的最远距离；</li><li>没超过，继续找下一次能到达的最远距离，即更新<code>nextReach = max(nextReach, i+nums[i])</code>；</li><li>遍历结束，返回<code>step</code></li></ol><h2 id="代码">代码</h2><details open><summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> currReach = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxReach = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; canReach) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                currReach = maxReach;</span><br><span class="line">            &#125;</span><br><span class="line">            maxReach = maxReach &gt; nums[i] + i ? maxReach : nums[i] + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解44：通配符匹配</title>
      <link href="/2022/07/10/leetcode%E9%A2%98%E8%A7%A344/"/>
      <url>/2022/07/10/leetcode%E9%A2%98%E8%A7%A344/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/wildcard-matching/">力扣第44题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>类似于<ahref="https://caoqinping.com/2020/12/05/leetcode%E9%A2%98%E8%A7%A310/">leetcode题解10</a>，同样使用动态规划来解，定义<code>dp[i][j]</code>为字符串<code>s</code>的前<code>i</code>位与字符串<code>p</code>的前<code>j</code>为匹配的结果，则<code>dp[0][0]</code>表示两个空串的比较，自然为<code>True</code>；对于<code>i&gt;=1</code>和<code>j&gt;=1</code>不难知道状态转移方程为<br /><span class="math display">\[    dp[i][j] = \left\{        \begin{aligned} &amp; dp[i-1][j-1] &amp; p[j-1]=?  \\                        &amp; dp[i-1][j] \quad \text{or} \quaddp[i][j-1] &amp; p[j-1]=* \\                        &amp; dp[i-1][j-1] \quad \text{and} \quads[i-1][j-1] &amp; \text{others}        \end{aligned} \right.\]</span></p><p>最后注意边界，主要是<code>dp[0][j]</code>这种情况。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s: <span class="built_in">str</span>, p: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(p)+<span class="number">1</span>)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p) + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">1</span>] <span class="keyword">and</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> p[j-<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j] <span class="keyword">or</span> dp[i][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> s[i-<span class="number">1</span>]== p[j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解43：字符串相乘</title>
      <link href="/2022/07/10/leetcode%E9%A2%98%E8%A7%A343/"/>
      <url>/2022/07/10/leetcode%E9%A2%98%E8%A7%A343/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/multiply-strings/">力扣第43题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>经典大数乘法，回顾我们如何计算乘法，拿<code>123x45</code>为例，<br /><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">    123</span></span><br><span class="line"><span class="section">x    45</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line"><span class="code">     15</span></span><br><span class="line"><span class="code">    10</span></span><br><span class="line"><span class="code">    5</span></span><br><span class="line"><span class="code">    12</span></span><br><span class="line"><span class="code">    8</span></span><br><span class="line"><span class="section">   4</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line"><span class="code">    615</span></span><br><span class="line"><span class="section">   492</span></span><br><span class="line"><span class="section">--------</span></span><br><span class="line"><span class="code">   5535</span></span><br></pre></td></tr></table></figure></p><p>总结就是将各位相乘的结果按照一定方式对齐后，直接按位相加即可。假设一个数的长度为<code>m</code>，一个数的长度为<code>n</code>，那么乘积的长度一定不超过<code>m+n</code>，取<code>i,j</code>其中<code>1&lt;=i&lt;=m, 1&lt;=j&lt;=n</code>，则第一数的第<code>i</code>位与第二个数的第<code>j</code>位相乘的结果放到<code>i+j</code>位（从右往左数），对所有<code>i,j</code>进行以上操作然后按位相加，最后依次进位就好。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, num1: <span class="built_in">str</span>, num2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">if</span> num1 == <span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> num2 == <span class="string">&#x27;0&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span></span><br><span class="line">        total_len = <span class="built_in">len</span>(num1) + <span class="built_in">len</span>(num2)</span><br><span class="line">        arr = [<span class="number">0</span>]*total_len</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num1)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(num2)-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                arr[i+j+<span class="number">1</span>] += <span class="built_in">int</span>(num1[i]) * <span class="built_in">int</span>(num2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total_len-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            arr[i-<span class="number">1</span>] += arr[i] // <span class="number">10</span></span><br><span class="line">            arr[i] %= <span class="number">10</span></span><br><span class="line"></span><br><span class="line">        start = <span class="number">1</span> <span class="keyword">if</span> arr[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="built_in">str</span>, arr[start:]))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题六：高中篇5</title>
      <link href="/2022/07/05/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%986/"/>
      <url>/2022/07/05/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<p>$401. $ 已知椭圆<span class="math inline">\(\displaystyle M:\frac{x^2}{6} + \frac{y^2}{2} = 1\)</span>，<spanclass="math inline">\(P\)</span>为<spanclass="math inline">\(M\)</span>上一点，<spanclass="math inline">\(EF\)</span>是圆<span class="math inline">\(N: x^2+ (y - 2)^2 = 1\)</span>的任意一条直径，<spanclass="math inline">\(E,F\)</span>为直径的两个端点，求<spanclass="math inline">\(\overrightarrow{PE} \cdot\overrightarrow{PF}\)</span>的最大值。</p><span id="more"></span><p>$402. $ 已知定义域为<spanclass="math inline">\([a,b]\)</span>的函数<spanclass="math inline">\(f(x)\)</span>，其图像是一条连续不断的曲线，且满足下列条件：（1）<spanclass="math inline">\(f(x)\)</span>的值域为<span class="math inline">\(G\subset [a, b]\)</span>；（2）对任意不同的<spanclass="math inline">\(x,y \in [a, b]\)</span>，都有<spanclass="math inline">\(|f(x) - f(y)| &lt; |x - y|\)</span>，那么<spanclass="math inline">\(f(x)=x\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有多少个实数解。</p><p>$403. $ 已知<spanclass="math inline">\(F_1,F_2\)</span>分别是椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{a^2} +\frac{y^2}{b^2}=1(a &gt; b &gt; 0)\)</span>的左右焦点，其左准线与<spanclass="math inline">\(x\)</span>轴交于点<spanclass="math inline">\(N\)</span>，并且满足<spanclass="math inline">\(\overrightarrow{F_1F_2} = 2\overrightarrow{NF_1},|\overrightarrow{F_1F_2}|=2\)</span>，设<spanclass="math inline">\(A,B\)</span>是上半椭圆上满足<spanclass="math inline">\(\overrightarrow{NA} = \lambda\overrightarrow{NB}\)</span>的两点，其中<spanclass="math inline">\(\displaystyle N \in [\frac{1}{5},\frac{1}{3}]\)</span>；<br />（1）求直线<spanclass="math inline">\(AB\)</span>的斜率的取值范围；<br />（2）过<spanclass="math inline">\(A,B\)</span>两点分别作椭圆的切线，两切线交于点<spanclass="math inline">\(P\)</span>，求证<spanclass="math inline">\(P\)</span>在一定直线上，并求点<spanclass="math inline">\(P\)</span>的纵坐标的取值范围。</p><p>$404. $ 已知<span class="math inline">\(f(x) = \ln (1 + e^x) - m x (m\ge 1)\)</span>；<br />（1）若<span class="math inline">\(x_1, x_2 \in \mathbb{R}, x_1 \nex_2\)</span>，当<span class="math inline">\(m=1\)</span>时，比较<spanclass="math inline">\(f(\dfrac{x_1+x_2}{2})\)</span>与<spanclass="math inline">\(\dfrac{f(x_1) + f(x_2)}{2}\)</span>的大小；<br />（2）设<span class="math inline">\(A,B,C\)</span>是函数<spanclass="math inline">\(f(x)\)</span>图像上不同的三点，求证<spanclass="math inline">\(ABC\)</span>是钝角三角形。</p><p>$405. $ 已知双曲线<span class="math inline">\(\dfrac{x^2}{a^2} -\dfrac{y^2}{b^2} = 1\)</span>的左右焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，<spanclass="math inline">\(O\)</span>为双曲线的中心，<spanclass="math inline">\(P\)</span>为双曲线右支上一点，<spanclass="math inline">\(\triangle PF_1F_2\)</span>的内切圆的圆心为<spanclass="math inline">\(I\)</span>，且<span class="math inline">\(\odotI\)</span>与<span class="math inline">\(x\)</span>轴相切于点<spanclass="math inline">\(A\)</span>，过<spanclass="math inline">\(F_2\)</span>作直线<spanclass="math inline">\(PI\)</span>的垂线，垂足为<spanclass="math inline">\(B\)</span>，则<spanclass="math inline">\(\dfrac{OA}{OB}=\)</span>？</p><p>$406. $ 已知抛物线的方程<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>，直线<spanclass="math inline">\(l\)</span>与抛物线交于两点<spanclass="math inline">\(A,B\)</span>，且以弦<spanclass="math inline">\(AB\)</span>为直径的圆<spanclass="math inline">\(M\)</span>与抛物线准线相切，则弦<spanclass="math inline">\(AB\)</span>的中点<spanclass="math inline">\(M\)</span>的轨迹方程为？</p><p>$407. $ 设<span class="math inline">\(a_0 + a_1 (x+1) + a_2 (x+1)^2 +\cdots + a_{2013} (x+1)^{2013} = (x^2 + x +1)^{1006}(x+2)\)</span>，则<span class="math inline">\(a_1 + a_2 +\cdots + a_{2012}=\)</span>？</p><p>$408. $ 已知<span class="math inline">\(P(4,0)\)</span>，<spanclass="math inline">\(A,B\)</span>为抛物线<spanclass="math inline">\(y^2 = 4x\)</span>上两点，且<spanclass="math inline">\(\overrightarrow{PA} \cdot \overrightarrow{PB} =0\)</span>，则<span class="math inline">\(\overrightarrow{PA} \cdot\overrightarrow{BA}\)</span>的最小值为？</p><p>$409. $ 已知定义在<span class="math inline">\((0,+\infty)\)</span>上的单调函数<spanclass="math inline">\(f(x)\)</span>，且<spanclass="math inline">\(f(x)f(f(x) + \dfrac{1}{x})=1\)</span>，则<spanclass="math inline">\(f(1)=\)</span>？</p><p>$410. $ 底面边长为<spanclass="math inline">\(4\)</span>的正四棱柱高<spanclass="math inline">\(h&gt;6\)</span>形的容器，先放入一个半径为<spanclass="math inline">\(2\)</span>的球，然后再放入一个半径为<spanclass="math inline">\(1\)</span>的小球，则小球最高点距棱柱底面距离为？</p><p>$411. $ 已知函数<span class="math inline">\(f(x) = |\log_2 |x|| -(\dfrac{1}{2})^x\)</span>，则<spanclass="math inline">\(f(x)\)</span>有几个零点，且所有零点之和与<spanclass="math inline">\(-1\)</span>的大小关系是？</p><p>$412. $ 设椭圆<span class="math inline">\(C: \dfrac{x^2}{25} +\dfrac{y^2}{16} = 1\)</span>，圆<span class="math inline">\(O: x^2 + y^2= 1\)</span>，直线<span class="math inline">\(l: mx + ny =1\)</span>，试证：当<spanclass="math inline">\(P(m,n)\)</span>在椭圆上运动时，直线<spanclass="math inline">\(l\)</span>与圆<spanclass="math inline">\(O\)</span>恒相交，并求直线<spanclass="math inline">\(l\)</span>被圆<spanclass="math inline">\(O\)</span>所截得的弦长<spanclass="math inline">\(L\)</span>的取值范围。</p><p>$413. $ 已知函数<span class="math inline">\(f(x) = \left\{\begin{aligned} &amp;-x^3 + x^2 &amp;x&lt;1 \\ &amp;a \ln x &amp;x \ge1\end{aligned} \right.\)</span>，对任意给定的正实数<spanclass="math inline">\(a\)</span>，曲线<spanclass="math inline">\(y=f(x)\)</span>上是否存在两点<spanclass="math inline">\(P,Q\)</span>使得<spanclass="math inline">\(\triangle POQ\)</span>是以<spanclass="math inline">\(O\)</span>为直角顶点的直角三角形，且此三角形斜边的中点在<spanclass="math inline">\(y\)</span>轴上。</p><p>$414. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1 (a&gt; b &gt; 0)\)</span>和圆<spanclass="math inline">\(O: x^2 + y^2 = b^2\)</span>，过椭圆上一点<spanclass="math inline">\(P\)</span>引圆<spanclass="math inline">\(O\)</span>的两条切线，切点分别为<spanclass="math inline">\(A,B\)</span>，设直线<spanclass="math inline">\(AB\)</span>与<spanclass="math inline">\(x,y\)</span>轴分别交于<spanclass="math inline">\(M,N\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{a^2}{|ON|^2} +\frac{b^2}{|OM|^2}\)</span>为定值。</p><p>$415. $ 函数<span class="math inline">\(f(x)= (-x^2 + ax) e^x (x \in\mathbb{R})\)</span>是否可能为<spanclass="math inline">\(\mathbb{R}\)</span>上的单调函数。</p><p>$416. $ 已知数列<span class="math inline">\(\{a_n\}, a_n \ge 0, a_1 =0, a_{n+1}^2 + a_{n+1} - 1 = a_n^2 (n \in\mathbb{N^+})\)</span>，记<span class="math inline">\(\displaystyle S_n= a_1 + a_2 + \cdots + a_n\)</span>，<spanclass="math inline">\(\displaystyle T_n = \frac{1}{1+a_1} +\frac{1}{(1+a_1)(1+a_2)} + \cdots +\frac{1}{(1+a_1)(1+a_2)\cdots(1+a_n)}\)</span>；<br />（1）证明：<span class="math inline">\(a_n &lt; a_{n+1}\)</span>；<br />（2）<span class="math inline">\(S_n &gt; n-2\)</span>；<br />（3）<span class="math inline">\(T_n &lt; 3\)</span>。</p><p>$417. $ 已知<span class="math inline">\(f(x) = \dfrac{\sin \pix}{(x^2+1)(x^2 - 2x + 2)}\)</span>，对于下列命题：<br />（1）<span class="math inline">\(f(x)\)</span>是周期函数；<br />（2）<spanclass="math inline">\(f(x)\)</span>既有最大值，又有最小值；<br />（3）<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\(R\)</span>且其图像有对称轴；<br />（4）对于任意的<span class="math inline">\(x \in (-1, 0), f^\prime(x)&lt; 0\)</span>；<br />其中真命题的序号为？</p><p>$418. $ 双曲线<span class="math inline">\(W: x^2 - \dfrac{y^2}{3} =1\)</span>的左右焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，过<spanclass="math inline">\(Q(0, -2)\)</span>的直线<spanclass="math inline">\(l\)</span>交双曲线<spanclass="math inline">\(W\)</span>的右支于<spanclass="math inline">\(A,B\)</span>两个不同点（<spanclass="math inline">\(B\)</span>在<spanclass="math inline">\(A,Q\)</span>之间），若点<spanclass="math inline">\(H(7, 0)\)</span>在以线段<spanclass="math inline">\(AB\)</span>为直径的圆的外部，试求<spanclass="math inline">\(\triangle AQH\)</span>与<spanclass="math inline">\(\triangle BQH\)</span>面积之比的取值范围。</p><p>$419. $ <span class="math inline">\(f(x) = [x[x]]\)</span>，当<spanclass="math inline">\(x \in [0, n] (n \in\mathbb{N^+})\)</span>时，设函数<spanclass="math inline">\(f(x)\)</span>的值域为集合<spanclass="math inline">\(A\)</span>，记<spanclass="math inline">\(A\)</span>中的元素个数为<spanclass="math inline">\(a_n\)</span>，则使<spanclass="math inline">\(\dfrac{a_n + 71}{n}\)</span>为最小时的<spanclass="math inline">\(n\)</span>是？</p><p>$420. $ 已知<span class="math inline">\(f(x) = \dfrac{4x - a}{1 +x^2}\)</span>，若<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([m,n]\)</span>上为增函数，且<spanclass="math inline">\(f(m)f(n) = -4\)</span>，当<spanclass="math inline">\(f(n) - f(m)\)</span>取最小值时；<br />（1）求<span class="math inline">\(a\)</span>和<spanclass="math inline">\(n\)</span>的值；<br />（2）如果<span class="math inline">\(P(x_1,y_1), Q(x_2,y_2) (a &lt; x_1&lt; x_2 &lt; n)\)</span>是<spanclass="math inline">\(f(x)\)</span>图像上两点，且存在实数<spanclass="math inline">\(x_0\)</span>使得<spanclass="math inline">\(f^\prime(x_0) = \dfrac{f(x_2) -f(x_1)}{x_2 -x_1}\)</span>，求证<span class="math inline">\(x_1 &lt; x_0 &lt;x_2\)</span>。</p><p>$421. $ <span class="math inline">\(a_n = 2n + 1, b_n =3^n\)</span>，试确定所有的<span class="math inline">\(p \in\mathbb{N^+}\)</span>，是数列<spanclass="math inline">\(\{b_n\}\)</span>中存在某个连续<spanclass="math inline">\(p\)</span>项的和为数列<spanclass="math inline">\(\{a_n\}\)</span>中的某一项，试证明。</p><p>$422. $ 设<span class="math inline">\(M\)</span>是圆<spanclass="math inline">\(x^2 + y^2 - 6x - 8y = 0\)</span>上的动点，<spanclass="math inline">\(O\)</span>是坐标原点，<spanclass="math inline">\(N\)</span>是射线<spanclass="math inline">\(OM\)</span>上的点，若<spanclass="math inline">\(|OM||ON|=150\)</span>，求点<spanclass="math inline">\(N\)</span>的轨迹方程。</p><p>$423. $ 若关于<spanclass="math inline">\(x\)</span>的实系数方程不等式<spanclass="math inline">\(ax^2 + bx + c \ge 0 (a &lt;b)\)</span>的解集为<spanclass="math inline">\(\mathbb{R}\)</span>，则<spanclass="math inline">\(\dfrac{a+2b+4c}{b-a}\)</span>的最小值是？</p><p>$424. $ 已知与圆<span class="math inline">\(C: x^2 + y^2 - 2x - 2y +1 = 0\)</span>的相切的直线<span class="math inline">\(l\)</span>与<spanclass="math inline">\(x,y\)</span>轴的正半轴交于点<spanclass="math inline">\(A,B\)</span>，点<spanclass="math inline">\(O\)</span>是坐标原点，则<spanclass="math inline">\(\triangle ABC\)</span>面积的最小值为？</p><p>$425. $ 已知过点<spanclass="math inline">\(P(0,-1)\)</span>的直线<spanclass="math inline">\(l\)</span>与抛物线<span class="math inline">\(x^2= 4y\)</span>相交于<span class="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(l_1,l_2\)</span>分别是抛物线在<spanclass="math inline">\(A,B\)</span>两点处的切线，<spanclass="math inline">\(M,N\)</span>分别是<spanclass="math inline">\(l_1,l_2\)</span>与直线<spanclass="math inline">\(y=-1\)</span>的交点，试比较<spanclass="math inline">\(|PM|\)</span>与<spanclass="math inline">\(|PN|\)</span>的大小。</p><p>$426. $ 已知<span class="math inline">\(f(x) = ax - \ln(-x), x \in[-e, 0]\)</span>，<span class="math inline">\(g(x) =-\dfrac{\ln(-x)}{x}\)</span>；<br />（1）当<span class="math inline">\(a=-1\)</span>时，证明<spanclass="math inline">\(|f(x)| &gt; g(x) + \dfrac{1}{2}\)</span>；<br />（2）是否存在实数<span class="math inline">\(a\)</span>，使得<spanclass="math inline">\(f(x)\)</span>的最小值为<spanclass="math inline">\(3\)</span>？</p><p>$427. $ 对于任意函数<span class="math inline">\(f(x), x\inD\)</span>（定义域），现给出一个数列构造法，若<spanclass="math inline">\(x_1 \in D\)</span>，令<spanclass="math inline">\(x_2 = f(x_1)\)</span>，依此类推，现定义<spanclass="math inline">\(f(x) = \dfrac{4x - 2}{x +1}\)</span>，若初始数据为<spanclass="math inline">\(x_0\)</span>时，产生无穷数列<spanclass="math inline">\(\{x_n\}\)</span>满足，对任意正整数<spanclass="math inline">\(n\)</span>，均有<span class="math inline">\(x_n&lt; x_{n+1}\)</span>，求<spanclass="math inline">\(x_0\)</span>的值。</p><p>$428. $ 若<span class="math inline">\(f(x) = e^x - 1, g(x) =\ln(x+1)\)</span>，当<spanclass="math inline">\(x_1&gt;x_2&gt;0\)</span>时，试比较<spanclass="math inline">\(f(x_1-x_2), g(x_1-x_2), g(x_1) -g(x_2)\)</span>的大小。</p><p>$429. $ 在<span class="math inline">\(\triangleABC\)</span>中，角<spanclass="math inline">\(A,B,C\)</span>所对的边为<spanclass="math inline">\(a,b,c\)</span>，且<spanclass="math inline">\(BC\)</span>边上的高为<spanclass="math inline">\(\dfrac{a}{2}\)</span>，则<spanclass="math inline">\(\dfrac{c}{b} +\dfrac{b}{c}\)</span>的取值范围是？</p><p>$430. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1 = 0, a_2 = 2\)</span>，且对任意<spanclass="math inline">\(m,n \in \mathbb{N^+}\)</span>，都有<spanclass="math inline">\(a_{2m-1} + a_{2n-1} = 2a_{m+n-1} +2(m-n)^2\)</span>，设<span class="math inline">\(c_n = (a_{n+1} -a_n)q^{n-1} (q \ne 0, n \in \mathbb{N^+})\)</span>，求数列<spanclass="math inline">\(\{c_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和。</p><p>$431. $ 若数列<span class="math inline">\(\{b_n\}\)</span>满足：<spanclass="math inline">\(b_{n+1} = b_n^2 - (n-2)b_n + 3\)</span>，且<spanclass="math inline">\(b_1 \ge 1, n\in \mathbb{N^+}, a_n =n\)</span>；<br />（1）证明<span class="math inline">\(b_n \ge a_n, n\in\mathbb{N^+}\)</span>；<br />（2）记<span class="math inline">\(\displaystyle T_n = \frac{1}{3+b_1} +\frac{1}{3+b_2} + \cdots + \frac{1}{3+b_n}\)</span>，证明<spanclass="math inline">\(T_n &lt; \dfrac{1}{2}\)</span>。</p><p>$432. $ 已知二次函数<span class="math inline">\(f(x) = ax^2 + x(a \ne0, a\in \mathbb{R})\)</span>；<br />（1）对任意的<span class="math inline">\(x \in\mathbb{R}\)</span>，总有<span class="math inline">\(|f(\sin x \cos x)|\le 1\)</span>，试求<spanclass="math inline">\(a\)</span>的取值范围；<br />（2）令<span class="math inline">\(a=1\)</span>，求证：<spanclass="math inline">\(\displaystyle 1 &lt; \sum_{i=n}^{3n}\frac{i}{f(i)} &lt; 2\)</span>。</p><p>$433. $ 是否存在各项都是正整数的无穷数列<spanclass="math inline">\(\{c_n\}\)</span>，使得<spanclass="math inline">\(c_{n+1}^2 &gt; 2 c_n c_{n+2}\)</span>都一切<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>都成立。</p><p>$434. $ 已知函数<span class="math inline">\(f(x) = \dfrac{1+x}{1-x}e^{-ax}\)</span>，若对任意的<span class="math inline">\(x \in (0,1)\)</span>，恒有<span class="math inline">\(f(x)&gt;1\)</span>，求<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$435. $ 已知<span class="math inline">\(f(x) = \dfrac{\lnx}{x}\)</span>，对于定义在<span class="math inline">\((e,+\infty)\)</span>上的函数<spanclass="math inline">\(h(x)\)</span>有<span class="math inline">\(h(x) =(f(x) - e)(x-e)^2\)</span>，已知<spanclass="math inline">\(a_1,a_2,a_3,a_4 \in (e, +\infty), a_1 &lt; a_2,a_3 = ta_1 + (1-t)a_2, a_4 = (1-t)a_1 + ta_2\)</span>，若<spanclass="math inline">\(\displaystyle \left| \dfrac{h(a_3) -h(a_4)}{h(a_1) - h(a_2)} \right| &lt; 1\)</span>，求<spanclass="math inline">\(t\)</span>的取值范围。</p><p>$436. $ 是否存在过点<spanclass="math inline">\((-1,1)\)</span>的直线与函数<spanclass="math inline">\(f(x) = \ln x -\dfrac{x-1}{x}\)</span>的图像相切？若存在，有多少条？若不存在，请说明理由。</p><p>$437. $ 已知<span class="math inline">\(x,y\)</span>满足约束条件<span class="math inline">\(\left\{\begin{aligned} x + y &amp; \le 3 \\ x - y &amp; \ge -1 \\ y &amp; \ge 1\end{aligned} \right.\)</span>，若<span class="math inline">\(0 \le ax +by \le 2\)</span>，则<spanclass="math inline">\(\dfrac{b+2}{a+1}\)</span>的取值范围是？</p><p>$438. $ 已知圆<span class="math inline">\(M: x^2 + y^2 =\dfrac{2}{3}\)</span>的切线<spanclass="math inline">\(l\)</span>与椭圆<spanclass="math inline">\(\dfrac{x^2}{2} + y^2 = 1\)</span>相交于<spanclass="math inline">\(A,B\)</span>两点，那么以<spanclass="math inline">\(AB\)</span>为直径的圆是否经过定点？</p><p>$439. $ 在<span class="math inline">\(\triangleABC\)</span>中，角<spanclass="math inline">\(A,B,C\)</span>所对的边为<spanclass="math inline">\(a,b,c\)</span>，面积<span class="math inline">\(S= \dfrac{1}{4}(b^2 + c^2 - a^2)\)</span>，若<spanclass="math inline">\(a = 10\)</span>，则<spanclass="math inline">\(bc\)</span>的最大值为？</p><p>$440. $ 求证：对任意不小于<spanclass="math inline">\(3\)</span>的正整数<spanclass="math inline">\(n\)</span>，不等式<spanclass="math inline">\(\displaystyle (\frac{2}{n!})^2 &lt; \ln\frac{n+1}{3} &lt; \frac{2}{n!}\)</span>都成立。</p><p>$441. $ 已知<span class="math inline">\(f(x) = x^2 + bx + 2, x \in\mathbb{R}\)</span>；<br />（1）若函数<span class="math inline">\(F(x) = f(f(x))\)</span>与<spanclass="math inline">\(f(x)\)</span>在<span class="math inline">\(x \in\mathbb{R}\)</span>上有相同的值域，求<spanclass="math inline">\(b\)</span>的取值范围；<br />（2）若方程<span class="math inline">\(f(x) + |x^2 - 1| =2\)</span>在<spanclass="math inline">\((0,2)\)</span>上有两个不同的解<spanclass="math inline">\(x_1,x_2\)</span>，求<spanclass="math inline">\(b\)</span>的取值范围，并证明<spanclass="math inline">\(\dfrac{1}{x_1} + \dfrac{1}{x_2} &lt;4\)</span>。</p><p>$442. $ 已知角<spanclass="math inline">\(\alpha\)</span>为锐角，求证<spanclass="math inline">\(\displaystyle (1 + \frac{1}{\sin \alpha})(1 +\frac{1}{\sin \alpha}) \ge 3 + 2 \sqrt 2\)</span>。</p><p>$443. $ 已知<span class="math inline">\(\alpha, \beta \in (0,\pi)\)</span>，且<span class="math inline">\(\cos \alpha + \cos \beta -\cos(\alpha + \beta) = \dfrac{2}{3}\)</span>，试求<spanclass="math inline">\(\alpha, \beta\)</span>的值。</p><p>$444. $ 已知<spanclass="math inline">\(x_1,x_2,x_3,x_4\)</span>为实数，且<spanclass="math inline">\(x_1 + x_2 + x_3 + x_4 = 6, x_1^2 + x_2^2 + x_3^2 +x_4^2 = 12\)</span>，求证<span class="math inline">\(0 \le x_i \le 3, i= 1,2,3,4\)</span>。</p><p>$445. $ 设<span class="math inline">\(a_i \in \mathbb{R}_+(i=1,2,\cdots,n), a_1 + a_2 + \cdots + a_n = 1\)</span>，求证：<spanclass="math inline">\(\displaystyle (a_1 + \frac{1}{a_1})^2 + (a_2 +\frac{1}{a_2})^2 + \cdots + (a_n + \frac{1}{a_n})^2 \ge \frac{(n^2 +1)^2}{n}\)</span>。</p><p>$446. $ <spanclass="math inline">\(a,b,c\)</span>为三角形三边，求证<spanclass="math inline">\((a^2 + b^2 + c^2)^2 \ge 2 (a^4 + b^4 +c^4)\)</span>。</p><p>$447. $ 已知<span class="math inline">\(i, m,n\)</span>是正整数，且<span class="math inline">\(1 &lt; i \le m \len\)</span>，证明<span class="math inline">\(n^i A_{m}^i &lt; m^iA_n^i\)</span>。</p><p>$448. $ 已知圆<span class="math inline">\(M: x^2 + (y - 2)^2 =1\)</span>，<span class="math inline">\(Q\)</span>是<spanclass="math inline">\(x\)</span>轴上的动点，<spanclass="math inline">\(QA,QB\)</span>分别切圆<spanclass="math inline">\(M\)</span>于<spanclass="math inline">\(A,B\)</span>两点；<br />（1）若<span class="math inline">\(|AB| = \dfrac{4 \sqrt2}{3}\)</span>，求直线<spanclass="math inline">\(MQ\)</span>的方程；<br />（2）求证：直线<span class="math inline">\(AB\)</span>恒过定点。</p><p>$449. $ 已知抛物线<span class="math inline">\(x^2 =4y\)</span>的焦点<span class="math inline">\(F\)</span>，过焦点<spanclass="math inline">\(F\)</span>且不平行于<spanclass="math inline">\(x\)</span>轴的直线<spanclass="math inline">\(l\)</span>交抛物线于<spanclass="math inline">\(A,B\)</span>两点，抛物线在<spanclass="math inline">\(A,B\)</span>两点处的切线交于点<spanclass="math inline">\(M\)</span>；<br />（1）求证：<spanclass="math inline">\(A,M,B\)</span>三点的横坐标成等差数列；<br />（2）设直线<span class="math inline">\(MF\)</span>交抛物线<spanclass="math inline">\(C,D\)</span>两点，求四边形<spanclass="math inline">\(ABCD\)</span>的面积。</p><p>$450. $ 对于直角坐标系内任意两点<spanclass="math inline">\(P_1,P_2\)</span>，定义运算<spanclass="math inline">\(P_1 \otimes P_1 = (x_1, y_2) \otimes (x_2, y_2) =(x_1x_2 - y_1y_2, x_1y_2 + x_2y_1)\)</span>，若点<spanclass="math inline">\(M\)</span>是与坐标原点<spanclass="math inline">\(O\)</span>相异的点，且<spanclass="math inline">\(M \otimes (1, 1) = N\)</span>，则<spanclass="math inline">\(\angle MON=\)</span>？</p><p>$451. $ <span class="math inline">\(O\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>内任意一点，若存在实数<spanclass="math inline">\(k, \lambda\)</span>，使得<spanclass="math inline">\(\overrightarrow{AE} = k \overrightarrow{EC},\overrightarrow{OA} + 2 \overrightarrow{OC} = \lambda\overrightarrow{OE}\)</span>，则<spanclass="math inline">\(k,\lambda\)</span>的值分别为？</p><p>$452. $ 设锐角三角形<span class="math inline">\(\triangleABC\)</span>的内角<spanclass="math inline">\(A,B,C\)</span>所对的边为<spanclass="math inline">\(a,b,c\)</span>且<span class="math inline">\(\cos C= a - \dfrac{1}{2}c, b = 1\)</span>，求<spanclass="math inline">\(\triangle ABC\)</span>周长<spanclass="math inline">\(l\)</span>的取值范围。</p><p>$453. $ 若方程<span class="math inline">\(\ln (x + 1) =\dfrac{1}{6}x^3 + b\)</span>在<span class="math inline">\((0,+\infty)\)</span>上有且仅有两个不同的实数解<spanclass="math inline">\(x_1,x_2\)</span>，比较<spanclass="math inline">\(x_1x_2+1\)</span>与<span class="math inline">\(x_1+ x_2\)</span>的大小。</p><p>$454. $ 求证：<span class="math inline">\(\displaystyle \frac{\ln2}{2!} + \frac{\ln 3}{3!} + \cdots + \frac{\ln n}{n!} &lt;1\)</span>。</p><p>$455. $ 求证：<span class="math inline">\(\displaystyle \frac{\ln2}{2^4} + \frac{\ln 3}{3^4} + \cdots + \frac{\ln n}{n^4} &lt;\frac{1}{2e}\)</span>。</p><p>$456. $ 求证：<span class="math inline">\(\displaystyle \frac{\ln2^2}{2^2} + \frac{\ln 3^2}{3^2} + \cdots + \frac{\ln (n + 1)^2}{(n+1)^2}&gt; \frac{n}{2(n+1)(n+2)}, n \in \mathbb{N^+}\)</span>。</p><p>$457. $ 设抛物线过定点<spanclass="math inline">\(A(2,0)\)</span>且以直线<spanclass="math inline">\(x=-2\)</span>为准线；<br />（1）求抛物线顶点的轨迹<spanclass="math inline">\(C\)</span>的方程；<br />（2）若<span class="math inline">\(A,B\)</span>是轨迹<spanclass="math inline">\(C\)</span>上的两个动点，且<spanclass="math inline">\(OA \perp OB\)</span>，<spanclass="math inline">\(O\)</span>为坐标原点，过点<spanclass="math inline">\(D\)</span>作直线<spanclass="math inline">\(AB\)</span>的垂线<spanclass="math inline">\(OD\)</span>，垂足为<spanclass="math inline">\(D\)</span>，求证点<spanclass="math inline">\(D\)</span>在定圆上。</p><p>$458. $ 数列<span class="math inline">\(\{a_n\}\)</span>中，<spanclass="math inline">\(a_1 = \dfrac{1}{2}, a_{n+1} =\dfrac{na_n}{(n+1)(na_n + 1)}\)</span>，若其前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，求证<spanclass="math inline">\(\displaystyle \sum_{i=1}^{n}(1 -\frac{S_i}{S_{i+1}})\frac{1}{\sqrt{S_i + 1}} &lt; 2(2\sqrt2-1)\)</span>。</p><p>$459. $ 从数列<spanclass="math inline">\(\{a_n\}\)</span>中取出部分项，并将它们按原来的顺序组成一个新的数列<spanclass="math inline">\(a_{n_1}, a_{n_2}, a_{n_3},\dots\)</span>，称之为数列<spanclass="math inline">\(\{a_n\}\)</span>的一个子数列，设数列<spanclass="math inline">\(\{a_n\}\)</span>是一个公差不为零的等差数列，且<spanclass="math inline">\(a_3 = 6\)</span>，取<spanclass="math inline">\(n_1 = 1, n_2 = 3\)</span>；<br />（1）若<span class="math inline">\(a_1 = 4\)</span>，那么数列<spanclass="math inline">\(\{a_n\}\)</span>中是否存在以<spanclass="math inline">\(a_1,a_3\)</span>为首前<spanclass="math inline">\(2\)</span>项的无穷等比数列<spanclass="math inline">\(\{a_{n_k}\}\)</span>，若存在，求<spanclass="math inline">\(n_k\)</span>的表达式；<br />（2）在（1）问中，若<spanclass="math inline">\(a_1\)</span>未知，也满足（1）中的其他条件，试求<spanclass="math inline">\(a_1\)</span>的最小正整数值及<spanclass="math inline">\(n_k\)</span>的表达式。</p><p>$460. $ 已知数列<span class="math inline">\(a_n = \dfrac{n}{2^n}, b_n= \ln (1 + a_n) + \dfrac{1}{2}a_n^2\)</span>，记数列<spanclass="math inline">\(\{a_n^2\}, \{b_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和分别为<spanclass="math inline">\(A_n,B_n\)</span>，证明<spanclass="math inline">\(2B_n - A_n &lt; 4\)</span>。</p><p>$461. $ 在<span class="math inline">\((0 + \infty)\)</span>上，<spanclass="math inline">\(xg^\prime(x) &gt; g(x)\)</span>恒成立（<spanclass="math inline">\(g^\prime(x)\)</span>为<spanclass="math inline">\(g(x)\)</span>的导函数），当<spanclass="math inline">\(x_1&gt;0,x_2&gt;0\)</span>时，求证<spanclass="math inline">\(g(x_1) + g(x_2) &lt; g(x_1 + x_2)\)</span>。</p><p>$462. $ 已知<span class="math inline">\(A,B\)</span>为椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{4} +\frac{y^2}{3}=1\)</span>上的两点且直线<span class="math inline">\(AB\perp x\)</span>轴，点<spanclass="math inline">\(N(4,0)\)</span>，直线<spanclass="math inline">\(AF\)</span>与<spanclass="math inline">\(BN\)</span>交于点<spanclass="math inline">\(M\)</span>，<br />（1）求证点<span class="math inline">\(M\)</span>在椭圆上；<br />（2）求<span class="math inline">\(\triangleAMN\)</span>面积的最大值。</p><p>$463. $ 在平面直角坐标系中，定义点<spanclass="math inline">\(P(x_1,x_2),Q(x_2,y_2)\)</span>之间的交通距离<spanclass="math inline">\(\rho(P,Q) = |x_1-x_2| +|y_1-y_2|\)</span>，则与点<spanclass="math inline">\(A(2,3),B(-6,9),C(-3,-8)\)</span>的交通距离均相等的交通距离为？</p><p>$464. $ 已知双曲线<span class="math inline">\(C:\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1(a&gt;b&gt;0)\)</span>和圆<spanclass="math inline">\(O: x^2+y^2 = b^2\)</span>，过双曲线<spanclass="math inline">\(C\)</span>上一点<spanclass="math inline">\(P\)</span>引圆<spanclass="math inline">\(O\)</span>的切线，切点分别为<spanclass="math inline">\(A,B\)</span>；<br />（1）若双曲线上存在点<span class="math inline">\(P\)</span>，使得<spanclass="math inline">\(\angle APB =\dfrac{\pi}{2}\)</span>，求双曲线离心率的取值范围；<br />（2）设直线<span class="math inline">\(AB\)</span>与<spanclass="math inline">\(x,y\)</span>轴分别交于<spanclass="math inline">\(M,N\)</span>点，求<spanclass="math inline">\(\displaystyle \frac{a^2}{|ON|^2} -\frac{b^2}{|OM|^2}\)</span>的值。</p><p>$465. $ 已知函数<span class="math inline">\(f(x) =\dfrac{9^x+k3^x+1}{9^x+3^x+1}\)</span>，若对任意的实数<spanclass="math inline">\(x_1,x_2,x_3\)</span>均存在<spanclass="math inline">\(f(x_1),f(x_2),f(x_3)\)</span>为三边长的三角形，则<spanclass="math inline">\(k\)</span>的取值范围是？</p><p>$466. $ 过直线<span class="math inline">\(y = -m(m&gt;0)\)</span>上一动点<span class="math inline">\(Q\)</span>作<spanclass="math inline">\(x\)</span>轴的垂线交抛物线<spanclass="math inline">\(C: y = x^2\)</span>相交于点<spanclass="math inline">\(P\)</span>，抛物线上两点<spanclass="math inline">\(A,B\)</span>满足<spanclass="math inline">\(\overrightarrow{PA} + \overrightarrow{PB} =2\overrightarrow{QP}\)</span>；<br />（1）求证：直线<span class="math inline">\(AB\)</span>与抛物线<spanclass="math inline">\(C\)</span>在在点<spanclass="math inline">\(P\)</span>出的切线<spanclass="math inline">\(l\)</span>平行，且直线<spanclass="math inline">\(AB\)</span>恒过定点；<br />（2）是否存在<span class="math inline">\(m\)</span>，使得点<spanclass="math inline">\(Q\)</span>在直线<spanclass="math inline">\(y=-m\)</span>上运动时，恒有<spanclass="math inline">\(\overrightarrow{QA} \perp\overrightarrow{QB}\)</span>？</p><p>$467. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1=1,a_n+a_{n+1}+(-1)^{n+1}a_na_{n+1}=0\)</span>；<br />（1）证明：当<span class="math inline">\(n&gt;1\)</span>时，<spanclass="math inline">\(\dfrac{1}{2} \le a_1 + a_2 + \cdots + a_n &lt;1\)</span>；<br />（2）设<span class="math inline">\(b_n = |a_1a_2\cdotsa_n|\)</span>，函数<span class="math inline">\(f_n(x)=1+b_1x+b_2x^2+\cdots b_{2n}x^{2n}, n \in \mathbb{N^+}\)</span>，证明对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，函数<spanclass="math inline">\(f_n(x)\)</span>无零点。</p><p>$468. $ 已知<span class="math inline">\(f(x) = x^2 +\dfrac{8}{x}\)</span>，证明：当<spanclass="math inline">\(a&gt;3\)</span>时，关于<spanclass="math inline">\(x\)</span>的方程<spanclass="math inline">\(f(x)=f(a)\)</span>有三个实数解。</p><p>$469. $ 已知定义在<spanclass="math inline">\(\mathbb{R}\)</span>上的函数<spanclass="math inline">\(f(x)\)</span>满足以下条件，（1）对任意<spanclass="math inline">\(x \in \mathbb{R},f(x)&gt;0\)</span>；（2）对任意<span class="math inline">\(x \in\mathbb{R}, y \in \mathbb{R}\)</span>，有<spanclass="math inline">\(f(xy) = [f(x)]^y\)</span>；（3）<spanclass="math inline">\(f(\dfrac{1}{3})&gt;1\)</span>；<br />（1）求证：<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\(\mathbb{R}\)</span>上为递增函数；<br />（2）若<span class="math inline">\(a&gt;b&gt;c&gt;0\)</span>且<spanclass="math inline">\(b^2=ac\)</span>，求证<spanclass="math inline">\(f(a)+f(c)&gt;2f(b)\)</span>。</p><p>$470. $ 函数<span class="math inline">\(f(x)=2x^2 + (x-a)|x-a|, a \in\mathbb{R}\)</span>，求<spanclass="math inline">\(f(x)\)</span>的最小值。</p><p>$471. $ 如果函数<span class="math inline">\(f(x) = a^x(a^x - 3a^2 -1) (a&gt;0\)</span>且<span class="math inline">\(a \ne1)\)</span>在区间<span class="math inline">\([0,+\infty)\)</span>上是增函数，那么实数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$472. $ 等差数列的前<span class="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，若<spanclass="math inline">\(S_n-S_m=a (n &gt;m )\)</span>，则<spanclass="math inline">\(S_{n+m}=\)</span>？</p><p>$473. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1=1, a_{n+1}=\left\{ \begin{aligned} &amp;\dfrac{1}{2}a_n+n &amp; n\text{为奇数}\\ &amp; a_n-2n &amp;n\text{为偶数} \end{aligned}\right.\)</span>，且<spanclass="math inline">\(b_n = a_n -2\)</span>；<br />（1）求证<span class="math inline">\(\{b_n\}\)</span>为等比数列；<br />（2）求<spanclass="math inline">\(S_{2n+1}=a_1+a_2+\cdots+a_{2n+1}\)</span>。</p><p>$474. $ 证明：两个公比不相等的等比数列<spanclass="math inline">\(\{a_n\}, \{b_n\}\)</span>的和<spanclass="math inline">\(\{a_n + b_n\}\)</span>不是等比数列。</p><p>$475. $ 已知<span class="math inline">\(P(4,0)\)</span>是圆<spanclass="math inline">\(x^2+y^2=36\)</span>内一点，<spanclass="math inline">\(A,B\)</span>是圆上两动点且满足<spanclass="math inline">\(\angle APB = 90^\circ\)</span>，求矩形<spanclass="math inline">\(APBQ\)</span>的顶点<spanclass="math inline">\(Q\)</span>的轨迹方程。</p><p>$476. $ 已知双曲线<span class="math inline">\(C: \dfrac{x^2}{4} - y^2= 1\)</span>，如图过点<spanclass="math inline">\(M(x_1,y_1)\)</span>的直线<spanclass="math inline">\(l_1: x_1x+4y_1y=4\)</span>与过点<spanclass="math inline">\(N(x_2,y_2)\)</span>的直线<spanclass="math inline">\(l_2: x_2x+4y_2y=4\)</span>的交点<spanclass="math inline">\(E\)</span>在双曲线<spanclass="math inline">\(C\)</span>上，直线<spanclass="math inline">\(MN\)</span>与双曲线的两条渐近线分别交于<spanclass="math inline">\(G,H\)</span>两点，求<spanclass="math inline">\(\overrightarrow{OG} \cdot\overrightarrow{OH}\)</span>的值。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.1fa7sh0gyb5s.webp" width="30%"></p><p>$477. $ 已知<spanclass="math inline">\(A(-1,1),B(1,-1)\)</span>，点<spanclass="math inline">\(P\)</span>是抛物线<span class="math inline">\(x^2+ 3y^2=4\)</span>的一动点，直线<spanclass="math inline">\(AP\)</span>和<spanclass="math inline">\(BP\)</span>分别与<spanclass="math inline">\(x=3\)</span>交于点<spanclass="math inline">\(M,N\)</span>，是否存在点<spanclass="math inline">\(P\)</span>使得<spanclass="math inline">\(\triangle PAB\)</span>与<spanclass="math inline">\(\triangle PMN\)</span>的面积相等？</p><p>$478. $ 已知<span class="math inline">\(E\)</span>的方程为<spanclass="math inline">\(\dfrac{x^2}{4}+y^2=1\)</span>， 设直线<spanclass="math inline">\(l\)</span>与圆<span class="math inline">\(C: x^2 +y^2 = R^2 (1&lt;R&lt;2)\)</span>相切于<spanclass="math inline">\(A_1\)</span>，且<spanclass="math inline">\(l\)</span>与轨迹<spanclass="math inline">\(E\)</span>只有一个公共点<spanclass="math inline">\(B_1\)</span>，当<spanclass="math inline">\(R\)</span>为何值时，<spanclass="math inline">\(|A_1B_1|\)</span>取得最大值？</p><p>$479. $ 已知复平面内一个点列<span class="math inline">\(z_n =\dfrac{n+1}{2n}+i\dfrac{3+n}{4n}\)</span>（<spanclass="math inline">\(n\)</span>为正整数），是否存在一个圆使得<spanclass="math inline">\(\{z_n\}\)</span>中任意一点都不在圆内？若存在，求出半径最小的圆的方程，若不存在，请说明理由。</p><p>$480. $ 已知椭圆方程<spanclass="math inline">\(\dfrac{x^2}{36}+\dfrac{y^2}{27}=1\)</span>，在椭圆内任取三个不同点<spanclass="math inline">\(P_1,P_2,P_3\)</span>使得<spanclass="math inline">\(\angle P_1FP_2=\angle P_2FP_3 = \angleP_3FP_1\)</span>，证明<span class="math inline">\(\displaystyle\frac{1}{|FP_1|} + \frac{1}{|FP_2|} +\frac{1}{|FP_3|}\)</span>为定值，并求出此定值。（<spanclass="math inline">\(F\)</span>为右焦点）</p><p>$481. $ 如果<span class="math inline">\(x \in [0,1]\)</span>时，<span class="math inline">\(|ax^2+x| \le1\)</span>恒成立，试求<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$482. $ 设函数<span class="math inline">\(f(x) = \ln[(x-1)(2-x)]\)</span>的定义域为<spanclass="math inline">\(A\)</span>，函数<spanclass="math inline">\(g(x)=\lg(\sqrt{a^2-2^x}-1)\)</span>的定义域是<spanclass="math inline">\(B\)</span>，若<span class="math inline">\(A\subset B\)</span>，则正数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$483. $ 设<span class="math inline">\(f(x) =x^2-1\)</span>，对任意<span class="math inline">\(x \in [\dfrac{3}{2},+\infty]\)</span>，<span class="math inline">\(f(\dfrac{x}{m}) -4m^2f(x) \le f(x-1) + 4f(m)\)</span>恒成立，则实数<spanclass="math inline">\(m\)</span>的取值范围是？</p><p>$484. $ 关于<span class="math inline">\(x\)</span>的不等式组<spanclass="math inline">\(\left\{ \begin{aligned} &amp;x^2-x-2&gt;0 \\&amp;2x^2+(2k+5)x+5k&lt;0 \end{aligned}\right.\)</span>的整数解的集合为<span class="math inline">\(\{-2\}\)</span>，则实数<spanclass="math inline">\(k\)</span>的取值范围是？</p><p>$485. $ 不等式<spanclass="math inline">\(e^x-x&gt;ax\)</span>的解集为<spanclass="math inline">\(P\)</span>，且<span class="math inline">\([0,2]\subset P\)</span>，则实数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$486. $ 已知<span class="math inline">\(f(x) = x + \dfrac{1}{x}-2\)</span>，若方程<span class="math inline">\(f(k^x-1) +k(\dfrac{2}{|2^x-1|}-3)=0\)</span>有三个不同的实数解，则<spanclass="math inline">\(k\)</span>的取值范围是？</p><p>$487. $ 若数列<span class="math inline">\(\{x_n\}\)</span>满足<spanclass="math inline">\(x_{n+1} = \dfrac{2x_n}{x_n^2+1} (n \in\mathbb{N^+})\)</span>，求证<spanclass="math inline">\(\dfrac{(x_1-x_2)^2}{x_1x_2} +\dfrac{(x_2-x_3)^2}{x_2x_3} + \cdots +\dfrac{(x_n-x_{n+1})^2}{x_nx_{n+1}} &lt; \dfrac{5}{16}\)</span>。</p><p>$488. $ 已知函数<span class="math inline">\(f(x) = 1 - \dfrac{\sinx}{1 + |x|} (x \in \mathbb{R})\)</span>的最大值为<spanclass="math inline">\(M\)</span>，最小值为<spanclass="math inline">\(m\)</span>，则<spanclass="math inline">\(M+m=\)</span>？</p><p>$489. $ 已知函数<span class="math inline">\(f(x) = \ln x + 2x, g(x) =a(x^2+x)\)</span>，若<span class="math inline">\(f(x) \leg(x)\)</span>恒成立，则<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$490. $ 已知函数<span class="math inline">\(f(x) = ax^3 -\dfrac{1}{2}\sin \theta \cdot x^2 - 2x + C\)</span>的图像过点<spanclass="math inline">\((1, \dfrac{37}{6})\)</span>，且在<spanclass="math inline">\([-2,1)\)</span>内单调递减，在<spanclass="math inline">\([1, +\infty)\)</span>内单调递增；<br />（1）求<span class="math inline">\(f(x)\)</span>的解析式；<br />（2）若对任意的<span class="math inline">\(x_1,x_2 \in [m, m+3] (m \ge0)\)</span>不等式<span class="math inline">\(|f(x_1) - f(x_2)| \le\frac{45}{2}\)</span>恒成立，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$491. $ 设<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>是各项均不为<spanclass="math inline">\(0\)</span>的等差数列，<spanclass="math inline">\(n \ge 4\)</span>且公差<spanclass="math inline">\(d \ne0\)</span>，若将数列删去一项后所得（按原来顺序）的数列为等比数列；<br />（1）求<span class="math inline">\(n\)</span>的所有可能取值；<br />（2）求证：对于给定的正整数<span class="math inline">\(n (n \ge4)\)</span>，存在一个各项及公差均不为<spanclass="math inline">\(0\)</span>的数列<spanclass="math inline">\(b_1,b_2,\cdots,b_n\)</span>，其中任意三项不能成等比数列。</p><p>$492. $ 数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1=1\)</span>，且<span class="math inline">\(n\ge 2\)</span>时，<span class="math inline">\(\displaystyle a_n = n^2(\frac{1}{1^2} + \frac{1}{2^2} + \dfrac{1}{(n+1)^2})\)</span>；<br />（1）证明：当<span class="math inline">\(n \ge 2\)</span>时，<spanclass="math inline">\(\displaystyle \frac{a_{n+1}}{(n+1)^2} -\frac{a_n}{n^2} = \frac{1}{n^2}\)</span>；<br />（2）证明：<span class="math inline">\(\displaystyle(1+\frac{1}{a_1})(1+\frac{1}{a_2})\cdots(1+\frac{1}{a_n}) &lt;4\)</span>。</p><p>$493. $ 对于各项均为整数的数列<spanclass="math inline">\(\{a_n\}\)</span>，如果<spanclass="math inline">\(a_i+i(i=1,2,\cdots,n)\)</span>为完全平方数，则称数列<spanclass="math inline">\(\{a_n\}\)</span>具有“P性质”，不论数列<spanclass="math inline">\(\{a_n\}\)</span>是否具有“P性质”，如果存在与<spanclass="math inline">\(\{a_n\}\)</span>不是同一数列的<spanclass="math inline">\(\{b_n\}\)</span>，且满足（1）<spanclass="math inline">\(b_1,b_2,\cdots,b_n\)</span>是<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>的一个排列，（2）数列<spanclass="math inline">\(\{b_n\}\)</span>具有“P性质”，则称数列具有变换“P性质”；对于有限数列<spanclass="math inline">\(A: 1,2,\cdots,n\)</span>，某人已验证当$ n (m)<span class="math inline">\(时，数列\)</span>A<spanclass="math inline">\(具有变换“P性质”，试证明当\)</span>n <spanclass="math inline">\(时数列\)</span>A<spanclass="math inline">\(也具有变换“P性质”。（\)</span>m$为常数）</p><p>$494. $ 对于各数互不相等的整数数组<spanclass="math inline">\((i_1,i_2,\cdots,i_n)(n \ge3)\)</span>，对于任意的<span class="math inline">\(p,q \in \{1, 2,\cdots, n\}\)</span>，当<spanclass="math inline">\(p&lt;q\)</span>时，有<spanclass="math inline">\(i_p &gt; i_q\)</span>，则称<spanclass="math inline">\(i_p,i_q\)</span>是该数组的一个逆序，一个数组中的所有逆序的个数成为逆序数，若数组<spanclass="math inline">\((i_1,i_2,\cdots,i_n)\)</span>中的逆序数为<spanclass="math inline">\(n\)</span>，则数组<spanclass="math inline">\(i_n,i_{n-1},\cdots,i_1\)</span>中的逆序数为？</p><p>$495. $ 一个数字生成器，生成规则如下：第1次生成一个数<spanclass="math inline">\(x\)</span>，以后每次生成的结果可将上一次生成的每一个数<spanclass="math inline">\(x\)</span>生成两个数，一个是<spanclass="math inline">\(-x\)</span>，另一个是<spanclass="math inline">\(x+3\)</span>，若<spanclass="math inline">\(x=1\)</span>，前<spanclass="math inline">\(n\)</span>次生成所有数中不同的数的个数为<spanclass="math inline">\(T_n\)</span>，则<spanclass="math inline">\(T_n=\)</span>？</p><p>$496. $ 对于数列<span class="math inline">\(A:a_1,a_2,\cdots,a_n\)</span>，若满足<span class="math inline">\(a_i \in\{0, 1\} (i=1,2,\cdots,n)\)</span>，则称数列<spanclass="math inline">\(A\)</span>为“0-1数列”，定义变换<spanclass="math inline">\(T\)</span>，<spanclass="math inline">\(T\)</span>将"0-1"数列<spanclass="math inline">\(A\)</span>中原有的每个<spanclass="math inline">\(1\)</span>都变成<spanclass="math inline">\(0,1\)</span>，原有的每个<spanclass="math inline">\(0\)</span>都变成<spanclass="math inline">\(1,0\)</span>，例如<span class="math inline">\(A:1,0,1\)</span>，则<span class="math inline">\(T(A):0,1,1,0,0,1\)</span>，设<spanclass="math inline">\(A_0\)</span>是"0-1"数列，令<spanclass="math inline">\(A_k = T(A_{k-1}) (k=1,2,\cdots)\)</span>；<br />（1）若数列<span class="math inline">\(A_0\)</span>共有<spanclass="math inline">\(10\)</span>项，这数列<spanclass="math inline">\(A_2\)</span>中连续两项相等的数对至少有多少对？请说明理由。<br />（2）若<span class="math inline">\(A_0\)</span>为<spanclass="math inline">\(0,1\)</span>，记数列<spanclass="math inline">\(A_k\)</span>中连续两项都是<spanclass="math inline">\(0\)</span>的数对的个数为<spanclass="math inline">\(l_k(k=1,2,3\cdots)\)</span>，求<spanclass="math inline">\(l_k\)</span>关于<spanclass="math inline">\(k\)</span>的表达式。</p><p>$497. $ 如图，<spanclass="math inline">\(O,A,B\)</span>是平面上的三点，向量<spanclass="math inline">\(\overrightarrow{OA}=\vec{a}, \overrightarrow{OB} =\vec b\)</span>，设<span class="math inline">\(P\)</span>是线段<spanclass="math inline">\(AB\)</span>的垂直平分线上的一点，向量<spanclass="math inline">\(\overrightarrow{OP} = \vec p\)</span>，若<spanclass="math inline">\(|\vec a| = 4, |\vec b|=2\)</span>，则<spanclass="math inline">\(\vec p (\vec a - \vec p)=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.49jak0312hy0.webp" width="30%"></p><p>$498. $ 已知直线<span class="math inline">\(l:x=my+1\)</span>，过椭圆<span class="math inline">\(C: \dfrac{x^2}{a^2} +\dfrac{y^2}{b^2}=1\)</span>的右焦点<spanclass="math inline">\(F\)</span>且交椭圆<spanclass="math inline">\(C\)</span>于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(AB\)</span>在直线<span class="math inline">\(l_1:x=a^2\)</span>上的射影依次为<spanclass="math inline">\(D,E\)</span>，连接<spanclass="math inline">\(AE,BD\)</span>，试证明<spanclass="math inline">\(AE,BD\)</span>交于一定点，并求出定点坐标。</p><p>$499. $ 抛物线定点为坐标原点<spanclass="math inline">\(O\)</span>，焦点为<spanclass="math inline">\(F\)</span>，<spanclass="math inline">\(M\)</span>是抛物线上的动点，则<spanclass="math inline">\(\frac{MO}{MF}\)</span>的最大值为？</p><p>$500. $ 在一个棱长为<spanclass="math inline">\(6\)</span>厘米的密封正方体盒子中，放一个半径为<spanclass="math inline">\(1\)</span>厘米的小球，任意滚动盒子，小球不能到达的空间为<spanclass="math inline">\(G\)</span>，则这个正方体盒子中的任意一点属于<spanclass="math inline">\(G\)</span>的概率是？</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题五：高中篇4</title>
      <link href="/2022/06/10/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%985/"/>
      <url>/2022/06/10/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<p>$301. $ 已知<span class="math inline">\(\displaystyle a_n =\frac{3^n+1}{4}\)</span>且<span class="math inline">\(S_n = \sum\limits_{k=1}^n a_k\)</span>，证明：当<span class="math inline">\(n \ge2\)</span>时，<span class="math inline">\(\displaystyle\frac{8}{3}(n+1)S_n &gt; (n+1)C_{n+1}^02^n + n C_{n+1}^1 2^{n-1} +\cdots + C_{n+1}^n 2^0\)</span>。</p><span id="more"></span><p>$302. $ 若长度为定值的线段<spanclass="math inline">\(AB\)</span>的两端点分别在<spanclass="math inline">\(x\)</span>轴正半轴与<spanclass="math inline">\(y\)</span>轴正半轴上移动，<spanclass="math inline">\(O\)</span>为坐标原点，则<spanclass="math inline">\(\triangleAOB\)</span>的垂心，内心，外心，重心得轨迹不可能是？（点、夏暖、圆弧、抛物线的一半部分）</p><p>$303. $ 已知<spanclass="math inline">\(f(x)\)</span>为奇函数，当<spanclass="math inline">\(x \le 0\)</span>时，<spanclass="math inline">\(f(x) = |x - a^2| - a^2\)</span>，且<spanclass="math inline">\(f(x+4) \ge f(x)\)</span>恒成立，则<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$304. $ 椭圆<span class="math inline">\(\displaystyle \frac{x^2}{16}+ \frac{y^2}{b^2} = 1 (4 &gt; b &gt; 0)\)</span>的左右焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，点<spanclass="math inline">\(P\)</span>为椭圆上一点，当<spanclass="math inline">\(P\)</span>不在<spanclass="math inline">\(x\)</span>轴上时，过<spanclass="math inline">\(F_1\)</span>作<span class="math inline">\(\angleF_1PF_2\)</span>的外角平分线的垂线<spanclass="math inline">\(F_1M\)</span>，垂足为<spanclass="math inline">\(M\)</span>，当点<spanclass="math inline">\(P\)</span>在<spanclass="math inline">\(x\)</span>轴上时，定义<spanclass="math inline">\(M\)</span>与<spanclass="math inline">\(P\)</span>点重合，求<spanclass="math inline">\(M\)</span>点的轨迹方程。</p><p>$305. $ 设<span class="math inline">\(\displaystyle f(x) =\frac{4x}{x^2 + 1}, g(x) = ax - \ln x\)</span>，若对任意的<spanclass="math inline">\(\displaystyle x_1 \in [\frac{1}{2},2]\)</span>，总存在唯一的<span class="math inline">\(\displaystyle x_2\in [\frac{1}{e^2}, \frac{1}{e}]\)</span>，使得<spanclass="math inline">\(g(x_2) = f(x_1)\)</span>，求实数<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$306. $ 在直三棱锥<spanclass="math inline">\(ABC-A_1B_1C_1\)</span>中，<spanclass="math inline">\(\displaystyle \angle BAC = \frac{\pi}{2},AB=AC=AA_1=1\)</span>，已知<spanclass="math inline">\(G,E\)</span>分别为<spanclass="math inline">\(A_1B_1\)</span>和<spanclass="math inline">\(CC_1\)</span>的中点，<spanclass="math inline">\(D\)</span>与<spanclass="math inline">\(F\)</span>分别为线段<spanclass="math inline">\(AC\)</span>和<spanclass="math inline">\(AB\)</span>上的动点（不包括端点），若<spanclass="math inline">\(GD \perp EF\)</span>，则线段<spanclass="math inline">\(|PF|\)</span>的取值范围是？</p><p>$307. $ 抛物线<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>的焦点为<span class="math inline">\(F\)</span>，点<spanclass="math inline">\(A,B\)</span>在抛物线上，且<spanclass="math inline">\(\angle AFB = 120^\circ\)</span>，过弦<spanclass="math inline">\(AB\)</span>的中点<spanclass="math inline">\(M\)</span>向准线<spanclass="math inline">\(l\)</span>作垂线，垂足为<spanclass="math inline">\(M_1\)</span>，则<spanclass="math inline">\(\displaystyle\frac{|MM_1|}{AB}\)</span>的最大值为？</p><p>$308. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_{n+1} + a_n = 4n - 3 (n \in\mathbb{N}^+)\)</span>；<br />（1）当<span class="math inline">\(a_1=2\)</span>时，求数列<spanclass="math inline">\(\{a_n\}\)</span>的通项；<br />（2）若<span class="math inline">\(\displaystyle \frac{a_n^2 +a_{n+1}^2}{a_n + a_{n+1}} \ge 5\)</span>恒成立，求<spanclass="math inline">\(a_1\)</span>的取值范围。</p><p>$309. $ 设<span class="math inline">\(0 &lt; \alpha \le \beta \le\gamma\)</span>且<span class="math inline">\(\alpha + \beta + \gamma =\pi\)</span>，则<span class="math inline">\(\displaystyle \min \{\frac{\sin \beta}{\sin \alpha}, \frac{\sin \gamma}{\sin \beta}\}\)</span>的取值范围是？</p><p>$310. $ 设<span class="math inline">\(\displaystyle f(x) = \frac{\sinx}{x}\)</span>；<br />（1）判断<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\((0, \pi)\)</span>上的增减性，并证明之；<br />（2）若<span class="math inline">\(0 \le a \le \sqrt{x-3} +\sqrt{4-x}\)</span>对一切<span class="math inline">\(x \in (3,4)\)</span>成立，求证<span class="math inline">\((2a-1)\sin x +(1-a)\sin(1-a) x \ge 0\)</span>。</p><p>$311. $ 若定义在<span class="math inline">\([-2010,2010]\)</span>上的函数<spanclass="math inline">\(f(x)\)</span>满足对任意的<spanclass="math inline">\(x_1,x_2 \in [-2010,2010]\)</span>有<spanclass="math inline">\(f(x_1+x_2) = f(x_1) + f(x_2)\)</span>，且<spanclass="math inline">\(x&gt;0\)</span>时，有<spanclass="math inline">\(f(x) &gt; 2009\)</span>，则<spanclass="math inline">\(f(x)\)</span>的最大值与最小值之和为？</p><p>$312. $ 已知数列<spanclass="math inline">\(\{a_n\}\)</span>的相邻两项<spanclass="math inline">\(a_n,a_{n+1}\)</span>是关于方程<spanclass="math inline">\(x^2 - 2^nx+b_n=0 (n \in\mathbb{N^+})\)</span>的两个实根，且<spanclass="math inline">\(a_1=1\)</span>；<br />（1）求<span class="math inline">\(S_n = a_1 + a_2 + \cdots +a_n\)</span>；<br />（2）是否存在<span class="math inline">\(\lambda\)</span>使得<spanclass="math inline">\(b_n &gt; \lambda S_n\)</span>对任意<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>都成立？</p><p>$313. $ 已知<span class="math inline">\(\displaystyle x, y \in[-\frac{\pi}{4}, \frac{\pi}{4}], a \in \mathbb{R}\)</span>，且<spanclass="math inline">\(\left\{ \begin{aligned} &amp;x^3 + \sin x - 2a = 0\\ &amp;4y^3 + \frac{1}{2} \sin 2y + a =0\end{aligned}\right.\)</span>，则<spanclass="math inline">\(\cos(x+2y)\)</span>的值为？</p><p>$314. $ 直线<span class="math inline">\(x - y =1\)</span>与双曲线<span class="math inline">\(\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2}=1(a&gt;0, b&gt;0\)</span>且<spanclass="math inline">\(a \ne b)\)</span>交于<spanclass="math inline">\(M,N\)</span>两点，且以<spanclass="math inline">\(M,N\)</span>为直径的圆过原点，若双曲线的离心率不大于<spanclass="math inline">\(\sqrt3\)</span>，则双曲线的实轴长的取值范围是？</p><p>$315. $ 已知向量<span class="math inline">\(\vec \alpha, \vec \beta,\vec \gamma\)</span>满足<span class="math inline">\(|\vec \alpha = 1|,|\vec \alpha - \vec \beta| = |\vec \beta|, (\vec \alpha - \vec\gamma)(\vec \beta - \vec \gamma) = 0\)</span>，若对于每一个确定的<spanclass="math inline">\(\vec \beta\)</span>，<spanclass="math inline">\(|\vec \gamma|\)</span>的最大值和最小值分别为<spanclass="math inline">\(m,n\)</span>，则对任意的<spanclass="math inline">\(\vec \beta\)</span>，<spanclass="math inline">\(m-n\)</span>的最小值是？</p><p>$316. $ 已知等差数列<spanclass="math inline">\(\{a_n\}\)</span>的首项为<spanclass="math inline">\(a\)</span>，公差为<spanclass="math inline">\(b\)</span>，等比数列<spanclass="math inline">\(\{b_n\}\)</span>首项为<spanclass="math inline">\(b\)</span>，公比为<spanclass="math inline">\(a\)</span>，其中<spanclass="math inline">\(a,b\)</span>都是大于<spanclass="math inline">\(1\)</span>的正整数，且<spanclass="math inline">\(a_1 &lt; b_1, b_2 &lt; a_3\)</span>，对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，总存在<spanclass="math inline">\(m \in \mathbb{N^+}\)</span>，使得<spanclass="math inline">\(a_m + 3 = b_n\)</span>成立，则<spanclass="math inline">\(a_n\)</span>为？</p><p><span class="math inline">\(317.\)</span> 已知<spanclass="math inline">\(f(x) = |\sin x|\)</span>；<br />（1）若<span class="math inline">\(g(x) = ax - f(x) \ge0\)</span>对任意<span class="math inline">\(x \in [0,+\infty)\)</span>恒成立，求实数<spanclass="math inline">\(a\)</span>的取值范围；<br />（2）若函数<span class="math inline">\(f(x)\)</span>与直线<spanclass="math inline">\(y=kx(k&gt;0)\)</span>的图像有且仅有三个公共点，且公共点横坐标最大值为<spanclass="math inline">\(\alpha\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{\cos \alpha}{\sin \alpha +\cos \alpha} = \frac{1 + \alpha^2}{4\alpha}\)</span>。</p><p>$318. $ 已知椭圆方程<span class="math inline">\(\displaystyle\frac{x^2}{2} + y^2 = 1\)</span>，若过点<spanclass="math inline">\(M(2,0)\)</span>的直线与椭圆<spanclass="math inline">\(E\)</span>相交于两点<spanclass="math inline">\(A,B\)</span>，设<spanclass="math inline">\(P\)</span>为椭圆上一点，且满足<spanclass="math inline">\(\overrightarrow{OA} + \overrightarrow{OB} = t\overrightarrow{OP}\)</span>（<spanclass="math inline">\(O\)</span>为坐标原点），当<spanclass="math inline">\(|\overrightarrow{PA} - \overrightarrow{PB}| &lt;\dfrac{2\sqrt 5}{3}\)</span>时，求实数<spanclass="math inline">\(t\)</span>的取值范围。</p><p>$319. $ 已知<span class="math inline">\(f(x) = x + \dfrac{x}{c}(x&gt;0)\)</span>，过点<spanclass="math inline">\(P(1,0)\)</span>作曲线<span class="math inline">\(y= f(x)\)</span>的两条切线<spanclass="math inline">\(PM,PN\)</span>，切点分别<spanclass="math inline">\(M,N\)</span>；<br />（1）设<span class="math inline">\(g(t) = |MN|\)</span>，试求函数<spanclass="math inline">\(g(t)\)</span>的表达式；<br />（2）若对任意的正整数<span class="math inline">\(n\)</span>，在区间<spanclass="math inline">\([2, n+\dfrac{64}{n}]\)</span>内总存在<spanclass="math inline">\(m+1\)</span>个数<spanclass="math inline">\(a_1,a_2,\cdots,a_{m+1}\)</span>使得不等式<spanclass="math inline">\(g(a_1) + g(a_2) + \cdots + g(a_{m}) &lt;g(a_{m+1})\)</span>成立，求证<spanclass="math inline">\(m\)</span>的最大值。</p><p>$320. $ 设<span class="math inline">\(a_n =(\dfrac{1}{2})^n\)</span>，<span class="math inline">\(c_n =\dfrac{1}{1+a_n} + \dfrac{1}{1-a_{n+1}}\)</span>，<spanclass="math inline">\(P_n\)</span>是<spanclass="math inline">\(\{c_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和，求证<spanclass="math inline">\(P_n &gt; 2n - \frac{1}{2}\)</span>。</p><p>$321. $ 已知<span class="math inline">\(\displaystyle f(x) = 1 + x -\frac{x^2}{2} + \frac{x^3}{3} - \frac{x^4}{4} + \cdots +\frac{x^{2011}}{2011}\)</span>，则函数<spanclass="math inline">\(f(x)\)</span>在其定义域内有几个零点？</p><p>$322. $ 已知函数<span class="math inline">\(y = \dfrac{a^2+2a\sin\theta + 2}{a^2 + 2a\cos \theta + 2} (a,\theta \in \mathbb{R}, a \ne0)\)</span>，那么对于任意的<span class="math inline">\(a,\theta\)</span>，<spanclass="math inline">\(y\)</span>的最大值与最小值之和为？</p><p>$323. $ 已知<span class="math inline">\(f(x) = \ln x - \dfrac{1}{2}ax^2 - bx\)</span>，若该函数与<spanclass="math inline">\(x\)</span>轴交于两点<spanclass="math inline">\(A,B\)</span>，线段<spanclass="math inline">\(AB\)</span>的中点的横坐标为<spanclass="math inline">\(x_0\)</span>，证明<spanclass="math inline">\(f^\prime(x_0) &lt; 0\)</span>。</p><p>$324. $ 设等差数列的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，若<span class="math inline">\(S_{m}= \dfrac{m}{n}, S_n = \dfrac{n}{m} (m,n \in \mathbb{N^+}, m \nen)\)</span>，则<span class="math inline">\(S_{n+m}\)</span>与<spanclass="math inline">\(4\)</span>的大小关系为？</p><p><span class="math inline">\(325\)</span>. 设椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{4} + y^2 =1\)</span>，过右焦点<spanclass="math inline">\(F^\prime\)</span>的直线<spanclass="math inline">\(l\)</span>与椭圆交于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(N\)</span>为<spanclass="math inline">\(AB\)</span>的中点，连接<spanclass="math inline">\(ON\)</span>并延长交椭圆于点<spanclass="math inline">\(E\)</span>，<spanclass="math inline">\(O\)</span>为坐标原点，且<spanclass="math inline">\(\overrightarrow{OE} = 2\overrightarrow{ON}\)</span>，求<spanclass="math inline">\(|AB|\)</span>的值。</p><p>$326. $ 证明<span class="math inline">\(\displaystyle \ln (1 +\frac{1}{n}) &gt; \frac{1}{n^2} - \frac{1}{n^3} (n \in\mathbb{N^+})\)</span>。</p><p>$327. $ 一个竹竿长<spanclass="math inline">\(2\)</span>米，竖直放在广场的水平面上，在<spanclass="math inline">\(t_1\)</span>时刻测得它的影子长<spanclass="math inline">\(4\)</span>米，<spanclass="math inline">\(t_2\)</span>时刻影长为<spanclass="math inline">\(1\)</span>米，这个广场上有一个球体，它在地面上的影子为椭圆，问：在<spanclass="math inline">\(t_1,t_2\)</span>这两个时刻，该球体物体在地面上的两个椭圆影子的离心率之比为？</p><p>$328. $ 如图所示，设抛物线<span class="math inline">\(C_1: y^2 =4mx(m &gt; 0)\)</span>的准线与<spanclass="math inline">\(x\)</span>轴交于<spanclass="math inline">\(F_1\)</span>，焦点为<spanclass="math inline">\(F_2\)</span>，以<spanclass="math inline">\(F_1,F_2\)</span>为左右焦点，离心率为<spanclass="math inline">\(\dfrac{1}{2}\)</span>的椭圆<spanclass="math inline">\(C_2\)</span>与抛物线<spanclass="math inline">\(C_1\)</span>在<spanclass="math inline">\(x\)</span>轴上方的交点为<spanclass="math inline">\(P\)</span>，延长<spanclass="math inline">\(PF_2\)</span>交抛物线于点<spanclass="math inline">\(Q\)</span>，点<spanclass="math inline">\(M\)</span>是抛物线<spanclass="math inline">\(C_1\)</span>上的一动点，且<spanclass="math inline">\(M\)</span>在<spanclass="math inline">\(P,Q\)</span>之间，问当<spanclass="math inline">\(\trianglePF_1F_2\)</span>的边长恰好是三个连续自然数时，求<spanclass="math inline">\(\triangle MPQ\)</span>的面积最大值。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.23mckgntyqbk.webp" width="30%"></p><p>$329. $ 设<span class="math inline">\(m_n(x) = [x + \dfrac{1}{x}]^n -[x^n + \dfrac{1}{x^n}]\)</span>，其中<span class="math inline">\(n \ge2, n \in \mathbb{N^+}\)</span>；<br />（1）求函数<span class="math inline">\(y = m_n(x)\)</span>在区间<spanclass="math inline">\((0, +\infty)\)</span>上的最小值；<br />（2）求证对任意的正实数<span class="math inline">\(x\)</span>，都有<spanclass="math inline">\(\displaystyle \sum_{i=2}^n \dfrac{1}{m_i(x)} &lt;\dfrac{5}{6}\)</span>。</p><p>$330. $ 已知函数<span class="math inline">\(f(x) = |\lg(x - 1)| -(\dfrac{1}{3})^x\)</span>的两个零点为<spanclass="math inline">\(x_1,x_2\)</span>，则有<br />（1）<span class="math inline">\(x_1x_2 &lt; 1\)</span> （2）<spanclass="math inline">\(x_1x_2 &lt; x_1 + x_2\)</span> （3）<spanclass="math inline">\(x_1x_2 = x_1 + x_2\)</span> （4）<spanclass="math inline">\(x_1x_2 &gt; x_1 + x_2\)</span></p><p>$331. $ 已知点<span class="math inline">\(A,B\)</span>在椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{4} + \frac{y^2}{3} =1\)</span>，且<span class="math inline">\(P(1,\dfrac{3}{2})\)</span>，且<spanclass="math inline">\(\overrightarrow{PA} + \overrightarrow{PB} =m\overrightarrow{OP}\)</span>，当<span class="math inline">\(\trianglePAB\)</span>的面积取最大值时，原点<spanclass="math inline">\(O\)</span>是<span class="math inline">\(\trianglePAB\)</span>的什么心？</p><p>$332. $ 在数列<span class="math inline">\(\{a_n\}\)</span>中，<spanclass="math inline">\(a_1 = p &gt; 0\)</span>，且<spanclass="math inline">\(a_{n+1} \cdot a_n = n^2 + 3n + 2 (n \in\mathbb{N^+})\)</span>，求<spanclass="math inline">\(\{a_n\}\)</span>的通项公式。</p><p>$333. $ 设<span class="math inline">\(f(x) = mx - \dfrac{m}{x} - 2\ln x - \dfrac{2e}{x}\)</span>，当在<spanclass="math inline">\([1,e]\)</span>上至少存在一个<spanclass="math inline">\(x_0\)</span>，使得<spanclass="math inline">\(f(x)&gt;0\)</span>成立，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$334. $ 已知抛物线<span class="math inline">\(C: x^2 = 2my (m &gt;0)\)</span>与直线<span class="math inline">\(l: y = kx -m\)</span>没有公共点（其中<spanclass="math inline">\(k,m\)</span>为常数），动点<spanclass="math inline">\(P\)</span>是直线<spanclass="math inline">\(l\)</span>的任意点，过点<spanclass="math inline">\(P\)</span>引抛物线的两条切线，切点分别为<spanclass="math inline">\(M,N\)</span>，且两条直线<spanclass="math inline">\(M,N\)</span>恒过点<spanclass="math inline">\(Q(k,1)\)</span>；<br />（1）求<span class="math inline">\(m\)</span>的值；<br />（2）已知<span class="math inline">\(O\)</span>为坐标原点，连接<spanclass="math inline">\(P，Q\)</span>交抛物线<spanclass="math inline">\(C\)</span>于<spanclass="math inline">\(A,B\)</span>两点，证明<spanclass="math inline">\(S_{\triangle OAP} = S_{\triangleOBQ}\)</span>。</p><p>$335. $ 已知数列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>的通项公式分别为<span class="math inline">\(a_n = 6n +2, b_n = 2^{n+1}\)</span>，将集合<span class="math inline">\(\{x \big| x= a_n \} \bigcup \{x \big| x =b_n\}\)</span>中的元素从小到大的顺序依次排列得到数列<spanclass="math inline">\(\{c_n\}\)</span>（<span class="math inline">\(n\in \mathbb{N^+}\)</span>），<br />（1）证明在数列<span class="math inline">\(\{c_n\}\)</span>中但不在<spanclass="math inline">\(\{a_n\}\)</span>中的项恰好是<spanclass="math inline">\(\{b_n\}\)</span>中的奇数项；<br />（2）设数列<span class="math inline">\(\{a_n\}\)</span>和<spanclass="math inline">\(\{b_n\}\)</span>的公共项<spanclass="math inline">\(d_k (k \in \mathbb{N^+})\)</span>是数列<spanclass="math inline">\(\{c_n\}\)</span>的第<spanclass="math inline">\(m\)</span>项，求<spanclass="math inline">\(m\)</span>的值并求数列<spanclass="math inline">\(\{c_n\}\)</span>的前<spanclass="math inline">\(m\)</span>项和<spanclass="math inline">\(S_m\)</span>（<spanclass="math inline">\(S_m\)</span>和<spanclass="math inline">\(m\)</span>都用<spanclass="math inline">\(k\)</span>表示）。</p><p>$336. $ 已知点<span class="math inline">\(P(x,y)\)</span>是椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{16} + \frac{y^2}{8} =1\)</span>上的不在对称轴上的一动点，<spanclass="math inline">\(F_1,F_2\)</span>为椭圆左右焦点，若<spanclass="math inline">\(M\)</span>是<span class="math inline">\(\angleF_1PF_2\)</span>的角平分线上一点，若<spanclass="math inline">\(M,P\)</span>不重合，且<spanclass="math inline">\(\overrightarrow{F_1M} \cdot \overrightarrow{MP} =0\)</span>，<span class="math inline">\(O\)</span>为坐标原点，则<spanclass="math inline">\(|\overrightarrow{OM}|\)</span>的取值范围是？</p><p>$337. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>是以<spanclass="math inline">\(d(d \ne 0)\)</span>为公差的等差数列，数列<spanclass="math inline">\(\{b_n\}\)</span>是以<spanclass="math inline">\(q\)</span>为公比的等比数列，若<spanclass="math inline">\(b_1 = a_r, b_2 = a_s, b_3 =a_t\)</span>（其中<span class="math inline">\(t &gt; s &gt;r\)</span>且<span class="math inline">\(s - r\)</span>是<spanclass="math inline">\(tr\)</span>的约数），求证：数列<spanclass="math inline">\(\{b_n\}\)</span>中的每一项都是数列<spanclass="math inline">\(\{a_n\}\)</span>中的项。</p><p>$378. $ 已知数列<span class="math inline">\(\{a_n\},\{b_n\}\)</span>满足<span class="math inline">\(a_1 = 1, a_2 = 2, b_1 =2\)</span>且对任意的正整数<spanclass="math inline">\(i,j,k,l\)</span>都有<spanclass="math inline">\(a_i + a_j = a_k + a_l\)</span>，其中<spanclass="math inline">\(i + j = k + l\)</span>，求<spanclass="math inline">\(\{a_n + b_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和。</p><p>$379. $ 如果函数<span class="math inline">\(f(x) = |x| + \sqrt{a-x^2}- \sqrt{2} (a&gt;0)\)</span>无零点，则<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$380. $ 设<span class="math inline">\(a_n\)</span>是<spanclass="math inline">\((3 - \sqrt x)^n(n \in \mathbb{N^+},n&gt;1)\)</span>的二项式展开中<spanclass="math inline">\(x\)</span>的系数，则<spanclass="math inline">\(\displaystyle \frac{3^2}{a^2} + \frac{3^3}{a^3} +\cdots + \frac{3^{18}}{a^{18}}=\)</span>？</p><p>$381. $ 给定椭圆<span class="math inline">\(\displaystyle C:\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1 (a &gt; b &gt;0)\)</span>，称圆心在原点<spanclass="math inline">\(O\)</span>，半径为<spanclass="math inline">\(\sqrt{a^2 + b^2}\)</span>的圆是椭圆的准圆，若<spanclass="math inline">\(a = \sqrt{3}, b=1\)</span>，且<spanclass="math inline">\(P\)</span>是准圆上一点，过点<spanclass="math inline">\(P\)</span>作椭圆的切线，切点为<spanclass="math inline">\(A,B\)</span>，求证<spanclass="math inline">\(|AB|\)</span>为定值。</p><p>$382. $ 已知函数<span class="math inline">\(f(x) = 2 \ln x -x^2\)</span>，若<span class="math inline">\(a,b,c\)</span>分别为<spanclass="math inline">\(\triangle ABC\)</span>的的角<spanclass="math inline">\(A,B,C\)</span>所对的边，且<spanclass="math inline">\(3a^2 + 3b^2 - c^2 = 4ab\)</span>，则<spanclass="math inline">\(f(\sin A)\)</span>与<spanclass="math inline">\(f(\sin B)\)</span>的大小关系为？</p><p>$383. $ 点<span class="math inline">\(P\)</span>到圆<spanclass="math inline">\(C\)</span>上的每一个点的距离的最小值称为点<spanclass="math inline">\(P\)</span>到圆<spanclass="math inline">\(C\)</span>的距离，那平面内到圆<spanclass="math inline">\(C\)</span>的距离与到定点<spanclass="math inline">\(A\)</span>的距离相等的点的轨迹可能是？</p><p>$384. $ 已知抛物线<span class="math inline">\(C: y^2 = 2px(p&gt;0)\)</span>，过点<span class="math inline">\(A(p,0)\)</span>的直线与抛物线<span class="math inline">\(C\)</span>交于<spanclass="math inline">\(M,N\)</span>两点，且<spanclass="math inline">\(\overrightarrow{MA} =2\overrightarrow{AN}\)</span>，过点<spanclass="math inline">\(M,N\)</span>向直线<spanclass="math inline">\(x=-p\)</span>作垂线，垂足分别为<spanclass="math inline">\(P,Q\)</span>，<spanclass="math inline">\(\triangle MAP, \triangleNAQ\)</span>的面积分别记为<spanclass="math inline">\(S_1,S_2\)</span>，则<spanclass="math inline">\(S_1:S_2=\)</span>？</p><p>$385. $ 定义在<span class="math inline">\([1,+\infty)\)</span>上的函数<spanclass="math inline">\(f(x)\)</span>满足：（1）<spanclass="math inline">\(f(2x) = cf(x)\)</span>（<spanclass="math inline">\(c\)</span>为正数），（2）当<spanclass="math inline">\(2 \le x \le 4\)</span>时，<spanclass="math inline">\(f(x) = -|x-3|\)</span>，若函数的所有极大值均落在同一条直线上，则<spanclass="math inline">\(c=\)</span>？</p><p>$386. $ 已知数列<span class="math inline">\(A: a_1,a_2,\cdots,a_n (n\ge 2)\)</span>是公差不为<spanclass="math inline">\(0\)</span>的等差数列，令<spanclass="math inline">\(T_A = \{x \big| x = a_i + a_j; 1 \le i &lt; j \len \}\)</span>；则集合<spanclass="math inline">\(T_A\)</span>的元素个数为？</p><p>$387. $ 三角形中，若<span class="math inline">\(a^2 + c^2 =2b^2\)</span>；<br />（1）求<span class="math inline">\(B\)</span>的取值范围；<br />（2）若<span class="math inline">\(B = \dfrac{\pi}{4}\)</span>，求<spanclass="math inline">\(A\)</span>。</p><p>$388. $ 设函数<span class="math inline">\(f(x) =(1+x^2)(2-x)\)</span>，若<span class="math inline">\(a \ge 0, b \ge 0, c\ge 0\)</span>且<span class="math inline">\(a + b + c =1\)</span>，证明：<span class="math inline">\(\displaystyle \frac{a}{1 +a^2} + \frac{b}{1+b^2} + \frac{c}{1+c^2} \le \frac{9}{10}\)</span>。</p><p>$389. $ 数列<span class="math inline">\(b_n = \lnn\)</span>，是否存在<span class="math inline">\(k\)</span>（<spanclass="math inline">\(k \ge 2\)</span>且<span class="math inline">\(k\in \mathbb{N}\)</span>）使得<span class="math inline">\(b_k, b_{k+1},b_{k+2}\)</span>成等差数列？</p><p>$390. $ <span class="math inline">\(f(x) = \dfrac{3}{2}x^2 + x + a\ln x\)</span>，不等式<span class="math inline">\(f(2t-1) \ge 2f(t) -\dfrac{5}{2}\)</span>在<span class="math inline">\(t \ge1\)</span>恒成立，求<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$391. $ 椭圆<span class="math inline">\(x^2 + 2y^2 =8\)</span>，动点<span class="math inline">\(M\)</span>满足<spanclass="math inline">\(MA \perp AB\)</span>，连接<spanclass="math inline">\(AM\)</span>交椭圆于点<spanclass="math inline">\(P\)</span>，点<spanclass="math inline">\(N\)</span>是以<spanclass="math inline">\(OB\)</span>为直径的圆与<spanclass="math inline">\(PB\)</span>的交点，求证<spanclass="math inline">\(O,M,N\)</span>三点共线。</p><p>$392. $ 已知函数<span class="math inline">\(f(x) = ax^3 + bx^2 + cx +d (x \in \mathbb{N^+}, a \ne 0)\)</span>，<spanclass="math inline">\(-2\)</span>是<spanclass="math inline">\(f(x)\)</span>的一个零点，又<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x=0\)</span>处有极值，在区间<spanclass="math inline">\((-6,-4)\)</span>和<spanclass="math inline">\((-2,0)\)</span>上是单调的，且在这两个区间的单调性相反，则<spanclass="math inline">\(\dfrac{b}{a}\)</span>的取值范围是？</p><p>$393. $ 已知圆心角为<spanclass="math inline">\(120^\circ\)</span>的扇形<spanclass="math inline">\(AOB\)</span>，其半径为<spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(C\)</span>为<span class="math inline">\(\stackrel\frown{AB}\)</span>的中点，点<spanclass="math inline">\(D,E\)</span>分别在半径<spanclass="math inline">\(OA,OB\)</span>上，若<spanclass="math inline">\(CD^2 + CE^2 + DE^2 = 2\)</span>，则<spanclass="math inline">\(OD + OE\)</span>的最大值为？</p><p>$394. $ （1）已知函数<span class="math inline">\(f(x) = \ln(1+x) -\dfrac{ax}{a+x}\)</span>在<span class="math inline">\((0,+\infty)\)</span>上单调递增，求实数<spanclass="math inline">\(a\)</span>的取值范围？<br />（2）若关于<span class="math inline">\(x\)</span>的不等式<spanclass="math inline">\(\dfrac{x}{1+bx} + \frac{1}{e^x} \ge1\)</span>在<span class="math inline">\([0,+\infty)\)</span>上恒成立，求实数<spanclass="math inline">\(b\)</span>的最大值。</p><p>$395. $ 已知函数<span class="math inline">\(f(x) = x^2 + px +q\)</span>与函数<span class="math inline">\(y =f(f(f(x)))\)</span>有一个相同的零点，证明<spanclass="math inline">\(f(0)\)</span>与<spanclass="math inline">\(f(1)\)</span>至少有一个等于<spanclass="math inline">\(0\)</span>。</p><p>$396. $ 给定正整数<span class="math inline">\(k (1 \le k \le9)\)</span>，令<spanclass="math inline">\(\underbrace{\overline{kk\cdotsk}}_{n个}\)</span>表示各位数字均为<spanclass="math inline">\(k\)</span>的十进制<spanclass="math inline">\(n\)</span>为正整数，若对任意的正整数<spanclass="math inline">\(n\)</span>，二次函数<spanclass="math inline">\(f(x)\)</span>满足<spanclass="math inline">\(f(\underbrace{\overline{kk\cdots k}}_{n个}) =\underbrace{\overline{kk\cdots k}}_{2n个}\)</span>，则当<spanclass="math inline">\(k\)</span>变化时，函数<spanclass="math inline">\(f(x)\)</span>的最小值为？</p><p>$397. $ 在四棱锥<spanclass="math inline">\(V-ABCD\)</span>中，底面<spanclass="math inline">\(ABCD\)</span>是平行四边形，<spanclass="math inline">\(B_1,D_1\)</span>分别为棱锥<spanclass="math inline">\(VB,VD\)</span>的中点，则四面体<spanclass="math inline">\(AB_1CD_1\)</span>的体积与四棱锥<spanclass="math inline">\(V-ABCD\)</span>的体积之比为？</p><p>$398. $ 已知方程<span class="math inline">\(x^3 + ax^2 + bx + c =0\)</span>的三个实根可分别作为椭圆，双曲线，抛物线的离心率，则<spanclass="math inline">\(\dfrac{a-1}{b+1}\)</span>的取值范围是？</p><p>$399. $ 设函数<span class="math inline">\(f(x) = \left\{\begin{aligned} &amp; x - [x] &amp; x \ge 0 \\ &amp; f(x+1) &amp; x&lt;0\end{aligned}\right.\)</span>，若直线<span class="math inline">\(y = kx+ k (k&gt;0)\)</span>与函数<spanclass="math inline">\(f(x)\)</span>的图像恰有三个不同交点，则实数<spanclass="math inline">\(k\)</span>的取值范围是？</p><p>$400. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1 (a &gt; b&gt;0)\)</span>左右焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，右顶点为<spanclass="math inline">\(A\)</span>，上顶点为<spanclass="math inline">\(B\)</span>，<spanclass="math inline">\(P\)</span>为椭圆上在第一象限内一点；<br />（1）若<span class="math inline">\(S_{\triangle PF_1F_2} = S_{\trianglePAF_2} = S_{\triangle PBF_1}\)</span>，求直线<spanclass="math inline">\(PF_1\)</span>的斜率<spanclass="math inline">\(k\)</span>；<br />（2）若<span class="math inline">\(S_{\triangle PAF_2}, S_{\trianglePF_1F_2}, S_{\triangle PBF_1}\)</span>成等差数列，椭圆离心率<spanclass="math inline">\(e \in [\dfrac{1}{4}, 1)\)</span>，求直线<spanclass="math inline">\(PF_1\)</span>的斜率<spanclass="math inline">\(k\)</span>的取值范围。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解42：接雨水</title>
      <link href="/2022/05/21/leetcode%E9%A2%98%E8%A7%A342/"/>
      <url>/2022/05/21/leetcode%E9%A2%98%E8%A7%A342/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/trapping-rain-water/">力扣第42题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>最直接的想法就是求出哪两个柱子之间可以接雨水，然后算出每两个柱子之间能够接的雨水量；但是效率不高，仔细分析下计算过程，现假设编号<code>i</code>到<code>i+k-1</code>这<code>k</code>个柱子之间可以接雨水，那么有两个性质：<br />1.雨水的最大高度是两个边界柱子的最小高度，记<code>h=min(arr[i], arr[i+k-1])</code>，<code>h</code>也是每根柱子接雨水的高度<br />2.接的雨水的单位是<code>h*k - (arr[i] + arr[i+1] + arr[i+k-1])</code>，分解下得到<code>(h - arr[i]) + (h - arr[i+1]) + (h - arr[i+k-1])</code>，发现能接的雨水的总单位就是每跟柱子能接雨水的高度减去自身的高度，然后求和即可</p><p>性质2说明能接雨水总单位等于每跟柱子能接的雨水单位的总和，而性质1说明，每根柱子接雨水的高度就是，自身左边最大高度与自身右边最大高度的最小值。举个例子：</p><blockquote><p>1 0 <font color="blue">2</font> 1 <font color="red">0</font><font color="blue">1</font></p></blockquote><p>红色0左边的最大值为2，右边最大值为1，从而红色1接雨水的高度为1，而自身高度为<code>0</code>，所以该柱子能接雨水的单位是<code>1-0=1</code>；对于每个柱子接雨水的高度可以这样求解：先求出每个柱子的左边最大高度，再求出每个柱子的右边高度，然后求两个最小值即可。设编号为<code>i</code>的柱子左边最大高度为<code>f(i)</code>，显然有<code>f(i) = max(f(i-1), arr[i])</code>，所以在求解时可以使用动态规划。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left = [height[<span class="number">0</span>]]*<span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(height)):</span><br><span class="line">            left[i] = <span class="built_in">max</span>(left[i-<span class="number">1</span>], height[i])</span><br><span class="line"></span><br><span class="line">        right = [height[-<span class="number">1</span>]]*<span class="built_in">len</span>(height)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)-<span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            right[i] = <span class="built_in">max</span>(right[i+<span class="number">1</span>], height[i])</span><br><span class="line"></span><br><span class="line">        area = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(height)):</span><br><span class="line">            area += <span class="built_in">min</span>(left[i], right[i]) - height[i]</span><br><span class="line">        <span class="keyword">return</span> area</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解41：缺失的第一个正数</title>
      <link href="/2022/05/21/leetcode%E9%A2%98%E8%A7%A341/"/>
      <url>/2022/05/21/leetcode%E9%A2%98%E8%A7%A341/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/first-missing-positive/">力扣第41题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>没有出现的最小的正整数，按照暴力法就是先判断<code>1</code>有没有在，没有则返回<code>1</code>，有则继续判断<code>2</code>，依次下去；但是有更好的方法，假设没有出现的最小正整数为<code>n</code>，表示<code>1～n-1</code>都在数组中，那么如果将<code>k</code>放到数组的<code>k-1</code>位置上，即<code>arr[k-1]=k</code>，其中<code>arr</code>为数组，数组的前<code>n-1</code>个数就是<code>1,2,...,n-1</code>，由于<code>n</code>不在数组中，那么<code>arr[n-1]</code>必不等于<code>n</code>。那么求解过程应该是<br />1.遍历到<code>i</code>处，如果<code>1&lt;=arr[i]&lt;=len(arr)</code>，表示<code>arr[i]</code>应该放到<code>arr[i]-1</code>这个位置上，但是首先判断<code>arr[i]-1</code>是否已经是<code>arr[i]</code>，如果是的话不进行操作，继续遍历下一个；如果不是则交换<code>i</code>与<code>arr[i]-1</code>位置上的两个数，继续遍历下一个；<br />2.当遍历完整个数组后，第一个不满足<code>arr[k-1]==k</code>的<code>k</code>就是解了；如果都满足表示<code>1~len(arr)</code>都在数组中，那么解就是<code>len(arr)+1</code>。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        i = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nums[i] - <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[nums[i]-<span class="number">1</span>] != nums[i]:</span><br><span class="line">                j = nums[i] - <span class="number">1</span></span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != i + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums) + <span class="number">1</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解40：组合数II</title>
      <link href="/2022/05/21/leetcode%E9%A2%98%E8%A7%A340/"/>
      <url>/2022/05/21/leetcode%E9%A2%98%E8%A7%A340/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/combination-sum-ii/">力扣第40题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>相比于39题的改变为两点：<br />1.第7步中，由于现在数不可以重复取，则继续求解从<code>i+1</code>开始和为<code>target-candidates[i]</code>的路径<br />2.由于<code>candidates</code>存在重复的数，表示第6步中，遍历<code>i: [index, len(candidates)]</code>；执行的操作应该加一步去掉重复的，即如果以<code>candidates[i]</code>数开始的情况已经求解过一遍了，那么后面再遇到与<code>candidates[i]</code>相同的数就不需要继续考虑了。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">candidates, target, combinations, temp, index</span>):</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                combinations.append(temp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span> <span class="keyword">or</span> index &gt;= <span class="built_in">len</span>(candidates):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            i = index</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; index <span class="keyword">and</span> candidates[i] == candidates[i-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                temp.append(candidates[i])</span><br><span class="line">                dfs(candidates, target - candidates[i], combinations, temp, i+<span class="number">1</span>)</span><br><span class="line">                temp.pop()</span><br><span class="line"></span><br><span class="line">        combinations, temp = [], []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        dfs(candidates, target, combinations, temp, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解39：组合总数</title>
      <link href="/2022/05/21/leetcode%E9%A2%98%E8%A7%A339/"/>
      <url>/2022/05/21/leetcode%E9%A2%98%E8%A7%A339/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/combination-sum/">力扣第39题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>这题简单分析发现可以用递归解决，但是递归的写法怎么写比较难想，将整个过程推理下来，发现是个深度优先遍历问题，以<code>candidates = [2,3,6,7], target=7</code>为例，取第一个数<code>2</code>，然后求<code>[2,3,6,7]</code>中和为<code>7-2=5</code>的解，即转化为了一个更小的相同问题，具体构建过程为一棵树，记录树中满足条件的所有路径即可，具体做法：<br />1. <code>candidates</code>排序，使其递增；<br />2.所有解的数组为<code>res</code>，当前记录路径为<code>tmp</code>，剩下的和为<code>target</code>，当前遍历的数在<code>candidates</code>中的<code>index</code>；递归函数则为求解<code>candidates[index:]</code>中满足和为<code>target</code>的路径。<br />3. 进入递归函数主体，判断<br />4.如果剩余的和<code>target==0</code>，表示当前路径满足条件，将<code>tmp</code>加入到<code>res</code>中；<br />5.如果<code>target&lt;0</code>，表示当前路径已不满足，直接退出该函数，返回上一层<br />6.如果<code>target&gt;0</code>，则需要求解以<code>candidates[index:]</code>中每个元素为根的树的满足条件的路径，从而遍历<code>i: [index, len(candidates)]</code>；遍历时执行以下操作；<br />7.如果<code>target-candidates]i]&lt;0</code>，表示第一个数就已经超过了，由于数组是递增的，直接退出循环了，退出函数；否则将当前值<code>candidates[i]</code>加入到路径<code>tmp</code>中，由于数可以重复取，继续求解从<code>i</code>开始和为<code>target-candidates[i]</code>的路径，进入递归，当求解完毕后，在继续下次循环之前，需要回溯现场，将<code>candidates[i]</code>踢出<code>tmp</code><br />8. 当第3步的递归结束后，<code>res</code>就是所有解了</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">candidates, target, combinations, tmp, index</span>):</span><br><span class="line">            <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                combinations.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> target - candidates[i] &lt; <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                tmp.append(candidates[i])</span><br><span class="line">                dfs(candidates, target - candidates[i], combinations, tmp, i)</span><br><span class="line">                tmp.pop()</span><br><span class="line"></span><br><span class="line">        combinations = []</span><br><span class="line">        tmp = []</span><br><span class="line">        candidates = <span class="built_in">sorted</span>(candidates)</span><br><span class="line">        dfs(candidates, target, combinations, tmp, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> combinations</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解37：解数独</title>
      <link href="/2022/05/14/leetcode%E9%A2%98%E8%A7%A337/"/>
      <url>/2022/05/14/leetcode%E9%A2%98%E8%A7%A337/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/sudoku-solver/">力扣第37题</a><br /><span id="more"></span></p><h2 id="分析">分析</h2><p>典型的深度优先遍历，假设递归函数为<code>solve</code>，那么递归的方式为：<br />1. 进入递归<code>solve</code><br />2.遍历<code>board</code>，找到待补充的区域，记作<code>(i, j)</code>，<br />3.找到<code>(i,j)</code>的所有可选数字，记作<code>candidate_nums</code>，遍历所有<code>candidate_nums</code>，若对当前遍历的数字<code>n</code>，将<code>board[i][j]=n</code>，然后判断<code>solve</code>函数返回值，若为<code>True</code>，即表示成功解决数独，函数返回<code>True</code>；<br />4.若遍历完所有<code>candidate_nums</code>，结果还是没有返回<code>True</code>，则表示前面的数字有误，则回溯还原现场<code>board[i][j]="."</code>，并且函数返回<code>False</code>，这样会回到递归上一层<br />5.最终由于函数遍历完所有的待补充区域了，所以直接返回<code>True</code></p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_possible_number</span>(<span class="params">board, i, j</span>):</span><br><span class="line">            all_number = <span class="built_in">set</span>(<span class="built_in">map</span>(<span class="built_in">str</span>, <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>)))</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[index][j] != <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    all_number.discard(board[index][j])</span><br><span class="line">                <span class="keyword">if</span> board[i][index] != <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    all_number.discard(board[i][index])</span><br><span class="line">            row = i // <span class="number">3</span></span><br><span class="line">            col = j // <span class="number">3</span></span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(row*<span class="number">3</span>, (row+<span class="number">1</span>)*<span class="number">3</span>):</span><br><span class="line">                <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(col*<span class="number">3</span>, (col+<span class="number">1</span>)*<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[m][n] != <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                        all_number.discard(board[m][n])</span><br><span class="line">            <span class="keyword">return</span> all_number</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">solve</span>(<span class="params">board</span>):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                    <span class="keyword">if</span> board[i][j] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                        <span class="keyword">for</span> n <span class="keyword">in</span> find_possible_number(board, i, j):</span><br><span class="line">                            board[i][j] = n</span><br><span class="line">                            <span class="keyword">if</span> solve(board):</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">                        board[i][j] = <span class="string">&quot;.&quot;</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        solve = solve(board)</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解34：在排序数组中查找元素的第一个和最后一个位置</title>
      <link href="/2022/05/14/leetcode%E9%A2%98%E8%A7%A334/"/>
      <url>/2022/05/14/leetcode%E9%A2%98%E8%A7%A334/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">力扣第34题</a></p><span id="more"></span><h2 id="分析">分析</h2><p>典型的二分查找，要找第一个，那就当<code>nums[mid]&gt;=target</code>，选左边，否则选右边；要找最后一个，那就当<code>nums[mid] &lt;= target</code>时，选右边，否则选左边。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_first</span>(<span class="params">nums, target</span>):</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt;= target:</span><br><span class="line">                    right = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left] == target:</span><br><span class="line">                <span class="keyword">return</span> left</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_last</span>(<span class="params">nums, target</span>):</span><br><span class="line">            left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                    left = mid +<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= left - <span class="number">1</span> &lt; <span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[left-<span class="number">1</span>] == target:</span><br><span class="line">                <span class="keyword">return</span> left - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arr = [find_first(nums, target), find_last(nums, target)]</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解33：搜索旋转排序数组</title>
      <link href="/2022/05/14/leetcode%E9%A2%98%E8%A7%A333/"/>
      <url>/2022/05/14/leetcode%E9%A2%98%E8%A7%A333/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/search-in-rotated-sorted-array">力扣第33题</a></p><p>整数数组 nums 按升序排列，数组中的值互不相同 。<br /><span id="more"></span></p><p>在传递给函数之前，nums 在预先未知的某个下标<code>k(0 &lt;= k &lt; nums.length)</code>上进行了旋转，使数组变为<code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标从 0 开始 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 3处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你旋转后的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值target ，则返回它的下标，否则返回 -1 。</p><p> <br />示例 1：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 0<br />输出：4</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [4,5,6,7,0,1,2], target = 3<br />输出：-1</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1], target = 0<br />输出：-1</p></blockquote><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10^4 &lt;= nums[i] &lt;= 10^4</li><li>nums 中的每个值都 独一无二</li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10^4 &lt;= target &lt;= 10^4<br /> </li></ul><p>进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？</p><h2 id="分析">分析</h2><p>类似于排序数组，依然可以使用二分查找法，只不过考虑的情况更多而已，在一个旋转排序数组中，我们考虑<code>left, mid, right</code>，还是两种情况：<br />1. 如果<code>nums[mid] &gt; target</code>：<br />-如果<code>nums[left]&gt;nums[mid]</code>，表示旋转点必在<code>left</code>和<code>mid</code>之间，所以<code>mid</code>后的数是递增的，从而<code>target</code>必在<code>mid</code>左边<br />-如果<code>nums[left]&lt;nums[mid]</code>，表示<code>left</code>到<code>mid</code>是递增的，所以如果<code>nums[left] &lt;= target</code>，即<code>nums[left] &lt;= target &lt; nums[mid]</code>，表明<code>target</code>必在<code>mid</code>左边<br />-如果<code>nums[left]&lt;nums[mid]</code>且<code>nums[left] &gt; target</code>，则<code>target</code>必不可能在<code>mid</code>左边，只能出现在右边了<br />2.如果<code>nums[mid] &lt; target</code>，可以仿照<code>1</code>的分析，看什么条件下，一定是递增的，从而判断<code>target</code>在<code>mid</code>的左边还是右边</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">search</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> left &lt; right:</span><br><span class="line">            mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">                    <span class="keyword">if</span> nums[left] &lt;= target:</span><br><span class="line">                        right = mid</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        left = mid +<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    right = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[left]:</span><br><span class="line">                    left = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> nums[right-<span class="number">1</span>] &gt;= target:</span><br><span class="line">                        left = mid + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        right = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解32：最长有效括号</title>
      <link href="/2022/05/14/leetcode%E9%A2%98%E8%A7%A332/"/>
      <url>/2022/05/14/leetcode%E9%A2%98%E8%A7%A332/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode.cn/problems/longest-valid-parentheses/">力扣第32题</a><br />给你一个只包含 '(' 和')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入：s = "(()"<br />输出：2<br />解释：最长有效括号子串是 "()"</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = ")()())"<br />输出：4<br />解释：最长有效括号子串是 "()()"</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = ""<br />输出：0</p></blockquote><p>提示：</p><ul><li>0 &lt;= s.length &lt;= 3 * 104</li><li>s[i] 为 '(' 或 ')'</li></ul><h2 id="分析">分析</h2><p>注意嵌套括号也算，比如<code>())(())</code>的最长有效括号子串为<code>(())</code>。碰到括号匹配问题首先应该想到<strong>栈</strong>，由于存在嵌套，想要一次循环解决有点难，因为有些左括号必须到最后才知道是否有匹配的又括号，从而必须分两次解决，第一次循环通过压栈模拟获得每个匹配到的括号，如<code>())(()))()</code>，压栈过程（压栈记录索引，不需要记录元素）：<br /><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span>. 栈内（从而栈底到栈顶）：<span class="number">0</span>       出栈：null</span><br><span class="line"><span class="attribute">2</span>. 栈内（从而栈底到栈顶）：null    出栈：<span class="number">01</span></span><br><span class="line"><span class="attribute">3</span>. 栈内（从而栈底到栈顶）：<span class="number">2</span>       出栈：<span class="number">01</span></span><br><span class="line"><span class="attribute">4</span>. 栈内（从而栈底到栈顶）：<span class="number">23</span>      出栈：<span class="number">01</span></span><br><span class="line"><span class="attribute">5</span>. 栈内（从而栈底到栈顶）：<span class="number">234</span>     出栈：<span class="number">01</span></span><br><span class="line"><span class="attribute">6</span>. 栈内（从而栈底到栈顶）：<span class="number">23</span>      出栈：<span class="number">0145</span></span><br><span class="line"><span class="attribute">7</span>. 栈内（从而栈底到栈顶）：<span class="number">2</span>       出栈：<span class="number">014536</span></span><br><span class="line"><span class="attribute">8</span>. 栈内（从而栈底到栈顶）：<span class="number">27</span>      出栈：<span class="number">014536</span></span><br><span class="line"><span class="attribute">9</span>. 栈内（从而栈底到栈顶）：<span class="number">278</span>      出栈：<span class="number">014536</span></span><br><span class="line"><span class="attribute">10</span>. 栈内（从而栈底到栈顶）：<span class="number">27</span>      出栈：<span class="number">01453689</span></span><br></pre></td></tr></table></figure><br />最终发现栈内为是<code>27</code>，为了计算方便可以在最后得到的栈内首位插入-1，末尾插入<code>len(s)</code>，这时栈内为<code>-1 2 7 10</code>，表示<code>0-1</code>，<code>3-6</code>，<code>8-9</code>都是连续括号，这样再循环一次就可以求得最长的连续括号子串了</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestValidParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = [-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(stack) &gt; <span class="number">1</span> <span class="keyword">and</span> s[stack[-<span class="number">1</span>]] == <span class="string">&quot;(&quot;</span> <span class="keyword">and</span> s[i] == <span class="string">&quot;)&quot;</span>:</span><br><span class="line">                stack.pop()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stack.append(i)</span><br><span class="line">        stack.append(<span class="built_in">len</span>(s))</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(stack)):</span><br><span class="line">            curr_len = stack[i] - stack[i-<span class="number">1</span>] - <span class="number">1</span></span><br><span class="line">            max_len = <span class="built_in">max</span>(max_len, curr_len)</span><br><span class="line">        <span class="keyword">return</span> max_len</span><br><span class="line"></span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!v.<span class="built_in">empty</span>() &amp;&amp; (s[v[v.<span class="built_in">size</span>()<span class="number">-1</span>]] == <span class="string">&#x27;(&#x27;</span>) &amp;&amp; (s[i] == <span class="string">&#x27;)&#x27;</span>))</span><br><span class="line">                v.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        v.<span class="built_in">push_back</span>(s.<span class="built_in">size</span>());</span><br><span class="line">        v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxLen &lt; v[i + <span class="number">1</span>] - v[i] - <span class="number">1</span>)</span><br><span class="line">                maxLen = v[i + <span class="number">1</span>] - v[i] - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解31：下一个排列</title>
      <link href="/2022/05/08/leetcode%E9%A2%98%E8%A7%A331/"/>
      <url>/2022/05/08/leetcode%E9%A2%98%E8%A7%A331/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/next-permutation/">力扣第31题</a></p><p>整数数组的一个排列就是将其所有成员以序列或线性顺序排列。</p><span id="more"></span><p>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作 arr的排列：<code>[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1]</code> 。</p><p>整数数组的下一个排列是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的下一个排列就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><p>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。<br />类似地，<code>arr = [2,3,1]</code> 的下一个排列是 <code>[3,1,2]</code>。<br />而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code> ，因为<code>[3,2,1]</code> 不存在一个字典序更大的排列。<br />给你一个整数数组 <code>nums</code> ，找出 <code>nums</code>的下一个排列。</p><p>必须<strong>原地</strong>修改，只允许使用额外常数空间。</p><p> <br />示例 1：</p><blockquote><p>输入：nums = [1,2,3]<br />输出：[1,3,2]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = [3,2,1]<br />输出：[1,2,3]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [1,1,5]<br />输出：[1,5,1]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h2 id="分析">分析</h2><p>仔细分析不难发现，有两个事实：<br />1. 所有排列中，最小的排列是升序排列，最大的排序是降序排列<br />2.如果数组是降序排列，如<code>3 2 1</code>，则下一个更大的排列不存在，只能回到<code>1 2 3</code>。</p><p>从而若数组<code>a_1 a_2 ... a_&#123;k-1&#125; a_k .... a_n</code>中从<code>a_k</code>到<code>a_n</code>是降序，且<code>a_&#123;k-1&#125; &lt; a_k</code>，从而<code>a_k ... a_n</code>已经是最大的排列了，那么按照字典排序，那么下一个排列应该是将<code>k-1</code>位置上的数换成比<code>a_&#123;k-1&#125;</code>大的数字，并且应该是<code>a_k .. a_n</code>中大于<code>a_&#123;k-1&#125;</code>的所有数中的最小值，不妨设<code>a_j</code>是该值，那么交换后的排列为<code>a_1 a_2 ... a_j a_k ... a_&#123;k-1&#125; ... a_n</code>，这时比较两个排列</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">a_1</span> <span class="built_in">a_2</span> ... a_&#123;k-<span class="number">1</span>&#125; <span class="built_in">a_k</span> ... <span class="built_in">a_j</span>     ... <span class="built_in">a_n</span>   （<span class="number">1</span>）</span><br><span class="line"><span class="built_in">a_1</span> <span class="built_in">a_2</span> ... <span class="built_in">a_j</span>     <span class="built_in">a_k</span> ... a_&#123;k-<span class="number">1</span>&#125; ... <span class="built_in">a_n</span>   （<span class="number">2</span>）</span><br></pre></td></tr></table></figure><p>经过前面的分析知道排列<code>(1)</code>的下一个排列必然是以<code>a_1 a_2 ... a_j</code>开始的，且后面序列<code>a_k ... a_&#123;k-1&#125; ... a_n</code>为最小排列即升序排列。又由于<code>a_k ... a_&#123;k-1&#125; ... a_n</code>是降序，从而将该序列逆序即可得到升序排列了。</p><p>比如求<code>3 5 4 2</code>的下一个排列，这时<code>5 4 2</code>是降序，而且<code>3 &lt; 5</code>，由于<code>5 4 2</code>中比<code>3</code>大的数为<code>5 4</code>，其中最小值为<code>4</code>，所以<code>3</code>和<code>4</code>交换，排列变为<code>4 5 3 2</code>，再将<code>5 3 2</code>逆序，即得到下一个排列<code>4 2 3 5</code>。</p><p>所以算法主要分三步：<br />1.从后往前找，找到第一个<code>a_i &gt; a_&#123;i-1&#125;</code>，即第一个非降序的排列，记降序排列的起始位置为<code>desc_index</code><br />2.从后往前，找到在<code>desc_index</code>位置以后的数中第一个大于<code>desc_index-1</code>位置的数，并交换两个数<br />3. 逆序从<code>desc_index</code>开始的所有数</p><p>注意到第2步中，在降序排列中找数，可以使用二分查找，当然最简单的方法就是从后往遍历数组。</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 从后往前找到第一个非降序排列的index</span></span><br><span class="line">        desc_index = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i-<span class="number">1</span>]:</span><br><span class="line">                desc_index = i</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 使用二分查找，从后往前找到第一个比index位置大的数，并交换两个数</span></span><br><span class="line">        <span class="keyword">if</span> desc_index &gt; <span class="number">0</span>:</span><br><span class="line">            start = desc_index</span><br><span class="line">            end = <span class="built_in">len</span>(nums)</span><br><span class="line">            <span class="keyword">while</span> start &lt; end:</span><br><span class="line">                mid = (start + end) &gt;&gt; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; nums[desc_index-<span class="number">1</span>]:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[mid] &lt;= nums[desc_index-<span class="number">1</span>]:</span><br><span class="line">                    end = mid</span><br><span class="line"></span><br><span class="line">            find_index = start - <span class="number">1</span></span><br><span class="line">            nums[find_index], nums[desc_index-<span class="number">1</span>] = nums[desc_index-<span class="number">1</span>], nums[find_index]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逆序从index开始的数组</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, (<span class="built_in">len</span>(nums)-desc_index) // <span class="number">2</span>):</span><br><span class="line">            nums[desc_index+i], nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i] = nums[<span class="built_in">len</span>(nums)-<span class="number">1</span>-i], nums[desc_index+i]</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i+<span class="number">1</span>] &gt; nums[i])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = nums.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &gt; nums[i])</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> temp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = i + <span class="number">1</span>; x &lt; (nums.<span class="built_in">size</span>() + i + <span class="number">1</span>) / <span class="number">2</span>; x++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = nums[x];</span><br><span class="line">            nums[x] = nums[nums.<span class="built_in">size</span>() + i - x];</span><br><span class="line">            nums[nums.<span class="built_in">size</span>() + i - x] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题四：高中篇3</title>
      <link href="/2022/04/26/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%984/"/>
      <url>/2022/04/26/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<p>$201. $ 已知椭圆<span class="math inline">\(\displaystyle C:\frac{x^2}{4} + \frac{y^2}{3} = 1\)</span>，过点<spanclass="math inline">\(Q(4, 0)\)</span>且不与坐标轴垂直的直线<spanclass="math inline">\(l\)</span>交椭圆于<spanclass="math inline">\(A,B\)</span>两点，设点<spanclass="math inline">\(A\)</span>关于<spanclass="math inline">\(x\)</span>轴对称为点<spanclass="math inline">\(A^\prime\)</span>，则<br />（1）求证：直线<span class="math inline">\(A^\primeB\)</span>过一定点；<br />（2）求<span class="math inline">\(\triangle OA^\primeB\)</span>面积的取值范围。</p><span id="more"></span><p>$202. $ 过椭圆的左焦点<spanclass="math inline">\(F\)</span>，倾斜角为<spanclass="math inline">\(60^\circ\)</span>的直线交椭圆于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(A,F,B\)</span>从上到下排列，且<spanclass="math inline">\(|FA| = 2|FB|\)</span>，则该椭圆的离心率<spanclass="math inline">\(e=\)</span>？</p><p>$203. $ 已知直线<span class="math inline">\(3x \sin^2 \theta + y(1 +\cos 2\theta) = 12 (\theta \in\mathbb{R})\)</span>，则以原点为圆心且与该直线相切的圆的面积的最大值为？</p><p>$204. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>中，<spanclass="math inline">\(\displaystyle a_1 = 1, \frac{a_n}{n} -\frac{a_{n-1}}{n-1} = 2 * 3^{n-2} (n \ge 2)\)</span>；<br />（1）令<span class="math inline">\(\displaystyle b_n =\frac{3^{n-1}}{a_n}\)</span>，数列<spanclass="math inline">\(\{b_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和<spanclass="math inline">\(S_n\)</span>，比较<spanclass="math inline">\(S_{2^n}\)</span>与<spanclass="math inline">\(n\)</span>的大小；<br />（2）令<span class="math inline">\(\displaystyle c_n =\frac{a_{n+1}}{n+1}\)</span>，数列<spanclass="math inline">\(\displaystyle \{ \frac{2c_n}{(c_n-1)^2}\}\)</span>的前<span class="math inline">\(n\)</span>项和为<spanclass="math inline">\(T_n\)</span>，求证<span class="math inline">\(T_n&lt; 2\)</span>。</p><p>$205. $ 已知椭圆<span class="math inline">\(\displaystyle C:\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1 (a &gt; b &gt;0)\)</span>，直线<span class="math inline">\(l\)</span>为圆<spanclass="math inline">\(O: x^2 + y^2 =b^2\)</span>的一条切线且经过椭圆的右焦点，设椭圆<spanclass="math inline">\(C\)</span>的离心率为<spanclass="math inline">\(e\)</span>；<br />（1）若直线<span class="math inline">\(l\)</span>的倾斜角为<spanclass="math inline">\(30^\circ\)</span>，求<spanclass="math inline">\(e\)</span>的值；<br />（2）是否存在这样的<span class="math inline">\(e\)</span>，使得原点<spanclass="math inline">\(O\)</span>关于直线<spanclass="math inline">\(l\)</span>的对称点恰好在椭圆上？若存在，请求出<spanclass="math inline">\(e\)</span>的值；若不存在，请说明理由。</p><p>$206. $ 已知<span class="math inline">\(a_n =(4n-1)(4n+1)(4n+3)\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{1}{\sqrt {a_1}} +\frac{1}{\sqrt {a_2}} + \cdots + \frac{1}{\sqrt {a_n}} &lt; \frac{\sqrt3}{6}\)</span>。</p><p>$207. $ 已知椭圆<span class="math inline">\(\displaystyle C:\frac{x^2}{4} + \frac{y^2}{3} = 1\)</span>，<spanclass="math inline">\(A\)</span>为椭圆<spanclass="math inline">\(C\)</span>的左顶点，过<spanclass="math inline">\(F_2(1, 0)\)</span>的直线交椭圆于<spanclass="math inline">\(M,N\)</span>两点，且<spanclass="math inline">\(M,N\)</span>均不在<spanclass="math inline">\(x\)</span>轴上，设直线<spanclass="math inline">\(AM,AN\)</span>的斜率分别为<spanclass="math inline">\(k_1,k_2\)</span>，求<spanclass="math inline">\(k_1k_2\)</span>的值。</p><p>$208. $ 求证：<span class="math inline">\([(n+1)!]^2 &gt;(n+1)e^{n-2}, (n \in \mathbb{N^+})\)</span>。</p><p>$209. $ 已知函数<span class="math inline">\(f(x) = -a\cos2x - \sqrt3a \sin 2x + 2a + b\)</span>，其中<spanclass="math inline">\(\displaystyle a&gt;0, x \in [0, \frac{\pi}{2}], -5\le f(x) \le 1\)</span>，则当<span class="math inline">\(t \in [-1,0]\)</span>时，<span class="math inline">\(g(t) = at^2 + bt -3\)</span>的最小值是？</p><p>$210. $ 已知<span class="math inline">\(\alpha,\beta\)</span>是一个钝角三角形的两个锐角，求证：<br />（1）<span class="math inline">\(\tan \alpha + \tan \beta &lt;1\)</span>；<br />（2）<span class="math inline">\(\sin \alpha + \sin \beta &lt; \sqrt2\)</span>；<br />（3）<span class="math inline">\(\cos \alpha + \cos \beta &gt;1\)</span>；<br />（4）<span class="math inline">\(\displaystyle \frac{1}{2} \tan(\alpha +\beta) &gt; \tan \frac{\alpha + \beta}{2}\)</span>。</p><p>$211. $ 求<span class="math inline">\(\displaystyle \sin^2 \alphasin^2 \beta + \cos^2 \alpha \cos^2 \beta - \frac{1}{2} \cos 2\alpha \cos2\beta\)</span>的值。</p><p>$212. $ 证明：当<span class="math inline">\(a &gt;0\)</span>时，<span class="math inline">\(\displaystyle \sqrt {a^2 +\frac{1}{a^2}} \ge a + \frac{1}{a} - 2\)</span>。</p><p>$213. $ 若三角形<span class="math inline">\(\triangleABC\)</span>的三边长都是有理数，证明：对任意正整数<spanclass="math inline">\(n\)</span>，<span class="math inline">\(\cosnA\)</span>是有理数。</p><p>$214. $ 已知<span class="math inline">\(a,b,c \in\mathbb{R}\)</span>，<span class="math inline">\(a + b + c &gt; 0, ab +bc + ac &gt; 0, abc &gt; 0\)</span>，求证<span class="math inline">\(a&gt; 0,b &gt; 0, c &gt; 0\)</span>。</p><p>$215. $ 已知<span class="math inline">\(\displaystyle f(x) = x^3 -x^2 + \frac{x}{2} + \frac{1}{4}\)</span>，且存在<spanclass="math inline">\(\displaystyle x_0 \in \left(0, \frac{1}{2}\right)\)</span>，使得<span class="math inline">\(f(x_0) =x_0\)</span>，设<span class="math inline">\(x_1 = 0, x_{n+1} = f(x_n),y_1 = \frac{1}{2}, y_{n+1} = f(y_n)\)</span>，其中<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，证明<spanclass="math inline">\(x_n &lt; x_{n+1} &lt; x_0 &lt; y_{n+1} &lt;y_n\)</span>。</p><p>$216. $ 实数<span class="math inline">\(a,b,c\)</span>满足<spanclass="math inline">\(a + b+ c = 0, abc &gt; 0\)</span>，证明<spanclass="math inline">\(\displaystyle \frac{1}{a} + \frac{1}{b} +\frac{1}{c} &lt; 0\)</span>。</p><p>$217. $ 若<span class="math inline">\(a,b\)</span>均为不等于<spanclass="math inline">\(0\)</span>的实数，给出下列两个条件，甲：存在区间<spanclass="math inline">\([-1, 2]\)</span>的值<spanclass="math inline">\(x\)</span>，使得<span class="math inline">\(ax + b&gt; 0\)</span>成立；乙：<span class="math inline">\((b-a)b &lt;0\)</span>，则甲是乙的什么条件？（充分 必要 充要？）</p><p>$218. $ 设数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(\displaystyle a_1 = 2， a_{n+1} = a_n +\frac{1}{a_n} ( n = 1, 2, \cdots)\)</span>，<br />（1）求证：<span class="math inline">\(a_n &gt; \sqrt {2n +1}\)</span>对一切正整数<spanclass="math inline">\(n\)</span>成立；<br />（2）令<span class="math inline">\(\displaystyle b_n = \frac{a_n}{\sqrtn} (n = 1, 2, \cdots)\)</span>，试判断<spanclass="math inline">\(b_n\)</span>与<spanclass="math inline">\(b_{n+1}\)</span>的大小。</p><p>$219. $ 已知二次函数<span class="math inline">\(f(x) = ax^2 + bx + 1(a &gt; 0)\)</span>的最小值为<spanclass="math inline">\(-a\)</span>，且<span class="math inline">\(x_1,x_2\)</span>为<spanclass="math inline">\(f(x)\)</span>的两个零点；<br />（1）求<span class="math inline">\(|x_1 - x_2|\)</span>；<br />（2）<span class="math inline">\(f(x) &lt; 0\)</span>的解集为<spanclass="math inline">\(A\)</span>，若<span class="math inline">\(f(x) +2x\)</span>在<spanclass="math inline">\(A\)</span>上不存在最小值，求<spanclass="math inline">\(a\)</span>的取值范围；<br />（3）若<span class="math inline">\(-2 &lt; x_1 &lt; 0\)</span>，求<spanclass="math inline">\(b\)</span>的取值范围。</p><p>$220. $ 已知函数<span class="math inline">\(\displaystyle f(x) =\frac{a^x}{1 + a^x} (a&gt;0,a \ne 1)\)</span>，<spanclass="math inline">\([m]\)</span>表示不超过实数<spanclass="math inline">\(m\)</span>的最大值整数，则函数<spanclass="math inline">\(\displaystyle \left[ f(x) - \frac{1}{2} \right] +\left[ f(-x) - \frac{1}{2}\right]\)</span>的值域是？</p><p>$221. $ 已知函数<span class="math inline">\(f(x) = 2mx^2 - 2(4 - m)x+ 1, g(x) = mx\)</span>，若对任意实数<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(f(x)\)</span>与<spanclass="math inline">\(g(x)\)</span>的值至少有一个正数，则<spanclass="math inline">\(m\)</span>的取值范围是？</p><p>$222. $ 已知<span class="math inline">\(F_1,F_2\)</span>是椭圆的两个焦点，满足<spanclass="math inline">\(\overrightarrow {MF_1} \cdot \overrightarrow{MF_2}= 0\)</span>的点<spanclass="math inline">\(M\)</span>总在椭圆内部，则椭圆的离心率的取值范围是?</p><p>$223. $ 若<span class="math inline">\(0 &lt; a_1 &lt; a_2, 0 &lt; b_1&lt; b_2\)</span>，且<span class="math inline">\(a_1 + b_2 = a_2 + b_1 =1\)</span>，则下列各代数式中最大的是？<br />（1）<span class="math inline">\(a_1b_1 + a_2b_2\)</span> （2）<spanclass="math inline">\(a_1a_2 + b_1b_2\)</span> （3）<spanclass="math inline">\(a_1b_2 + a_2b_1\)</span> （4）<spanclass="math inline">\(\displaystyle \frac{1}{2}\)</span></p><p>$224. $ 已知抛物线<span class="math inline">\(C: y =x^2\)</span>和三个点<span class="math inline">\(M(x_0, y_0), P(0, y_0),N(-x_0, y_0) (y_0 \ne x_0^2, y_0 &gt; 0)\)</span>，过点<spanclass="math inline">\(M\)</span>作一条直线交抛物线于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(AP,BP\)</span>的延长线交曲线<spanclass="math inline">\(C\)</span>于<spanclass="math inline">\(E,F\)</span>；<br />（1）证明：<span class="math inline">\(E, F, N\)</span>三点共线；<br />（2）如果<spanclass="math inline">\(A,B,M,N\)</span>四点共线，问是否存在<spanclass="math inline">\(y_0\)</span>使以线段<spanclass="math inline">\(AB\)</span>为直径的圆与抛物线有异于<spanclass="math inline">\(A,B\)</span>的交点？如果存在，求出<spanclass="math inline">\(y_0\)</span>的取值范围，并求出该交点到直线<spanclass="math inline">\(AB\)</span>的距离；若不存在，请说明理由。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.2yt4ttg4dku8.webp" width="25%"></p><p>$225. $ 设点<span class="math inline">\(P(x_0,y_0)\)</span>在直线<span class="math inline">\(x=m(y \ne \pm m, 0 &lt; m&lt; 1)\)</span>上过点<spanclass="math inline">\(P\)</span>作双曲线<span class="math inline">\(x^2- y^2 = 1\)</span>的两条切线<spanclass="math inline">\(PA,PB\)</span>，切点为<spanclass="math inline">\(A,B\)</span>，定点<spanclass="math inline">\(\displaystyle M(\frac{1}{m}, 0)\)</span>；<br />（1）过点<span class="math inline">\(A\)</span>作直线<spanclass="math inline">\(x=y\)</span>的垂线，垂足为<spanclass="math inline">\(N\)</span>，试求<spanclass="math inline">\(\triangle AMN\)</span>的重心<spanclass="math inline">\(G\)</span>所在的曲线方程；<br />（2）证明<span class="math inline">\(A, M, B\)</span>共线。</p><p>$226. $ 已知<spanclass="math inline">\(A,B,C\)</span>三点共圆，设圆心为<spanclass="math inline">\(O\)</span>，<spanclass="math inline">\(OA,OB\)</span>之间的夹角为<spanclass="math inline">\(\theta\)</span>，且<spanclass="math inline">\(\overrightarrow{OC} = \lambda \overrightarrow{OA}+ \mu \overrightarrow{OB} (\lambda \mu &gt; 0)\)</span>；<br />（1）若<span class="math inline">\(\theta = 60^\circ\)</span>，求<spanclass="math inline">\(\lambda \mu\)</span>的最大值；<br />（2）在<span class="math inline">\(\triangle OAB\)</span>中，<spanclass="math inline">\(a,b\)</span>分别为<spanclass="math inline">\(OA,OB\)</span>边的长，且<spanclass="math inline">\(S_{\triangle OAB} = \sqrt 2\)</span>，求<spanclass="math inline">\(\displaystyle ab \sqrt {\frac{1 - \cos\theta}{\lambda \mu}}\)</span>。</p><p>$227. $ 已知各项为正数的数列<spanclass="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1 = 3\)</span>且<spanclass="math inline">\(\displaystyle \frac{2a_{n+1} - a_n}{2a_n -a_{n+1}} = a_n a_{n+1} (n \in \mathbb{N}^+)\)</span>；<br />（1）求数列<spanclass="math inline">\(\{a_n\}\)</span>的通项公式；<br />（2）设<span class="math inline">\(\displaystyle S_n = a_1^2 + a_2^2 +\cdots + a_n^2, T_n = \frac{1}{a_1^2} + \frac{1}{a_2^2} + \cdots +\frac{1}{a_n^2}\)</span>，求<span class="math inline">\(S_n +T_n\)</span>，并确定最小正整数<spanclass="math inline">\(n\)</span>，使得<span class="math inline">\(S_n +T_n\)</span>为整数。</p><p>$228. $ 在三角形<span class="math inline">\(ABC\)</span>中，求<spanclass="math inline">\(\displaystyle \frac{aA + bB + cC}{a + b +c}\)</span>的取值范围。</p><p>$229. $ 在三角形<span class="math inline">\(ABC\)</span>中，若<spanclass="math inline">\(c^n = a^n + b^n\)</span>；若<spanclass="math inline">\(n&gt;2\)</span>且为整数，则三角形为什么三角形？（锐角，直角，钝角）；若<spanclass="math inline">\(1 &lt; n &lt;2\)</span>，则三角又是什么三角形？</p><p>$230. $ 在三角形<span class="math inline">\(ABC\)</span>中，若<spanclass="math inline">\(\displaystyle \cos A + \cos B + \cos C =\frac{3}{2}\)</span>，则三角形为什么三角形？（锐角，直角，钝角）</p><p>$231. $ 已知函数<span class="math inline">\(\displaystyle y =\frac{1}{3}x^3 + x^2 - 8x\)</span>的图像上<spanclass="math inline">\(C\)</span>存在一点<spanclass="math inline">\(P\)</span>满足过该点的直线<spanclass="math inline">\(l\)</span>与曲线<spanclass="math inline">\(C\)</span>交于不同于<spanclass="math inline">\(P\)</span>的两点<span class="math inline">\(M(x_1,y_1), N(x_2, y_2)\)</span>，则恒有<span class="math inline">\(y_1 +y_2\)</span>为定值<span class="math inline">\(y_0\)</span>，则<spanclass="math inline">\(y_0\)</span>的值为？</p><p>$232. $ 已知函数<span class="math inline">\(\displaystyle f(x) = x -\frac{1}{2} x^2\)</span>，若常数<spanclass="math inline">\(\displaystyle k \ge\frac{2}{3}\)</span>，存在区间<span class="math inline">\([m, n] (m &lt;n)\)</span>使得<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([m, n]\)</span>上的值域为<spanclass="math inline">\([km, kn]\)</span>，求出区间<spanclass="math inline">\([m,n]\)</span>。</p><p>$233. $ 若<span class="math inline">\((x + \sqrt {x^2 + 1}) (y +\sqrt {y^2 + 1})=1\)</span>，求<spanclass="math inline">\(x+y\)</span>的值。</p><p>$234. $ 函数<span class="math inline">\(\displaystyle f(x) =\frac{\sin x - 1}{\sqrt (3 - 2 \cos x - 2 \sin x)} (0 \le x &lt;2\pi)\)</span>的值域是？</p><p>$235. $ 若<span class="math inline">\(\alpha,\beta\)</span>是两锐角，且<span class="math inline">\(\sin(\alpha +\beta) = 2 \sin \alpha\)</span>，则<span class="math inline">\(\alpha,\beta\)</span>的大小关系是？</p><p>$236. $ 已知<span class="math inline">\(\displaystyle \alpha + \beta= \frac{3}{4}\pi\)</span>，求证<span class="math inline">\(\displaystyle\cos^2 \alpha + \cos^2 \beta + \sqrt 2 \cos \alpha \cos \beta =\frac{1}{2}\)</span>。</p><p>$237. $ 定义在<span class="math inline">\((-1,1)\)</span>上的函数<spanclass="math inline">\(f(x)\)</span>，对任意<spanclass="math inline">\(x,y \in (-1, 1)\)</span>都有<spanclass="math inline">\(\displaystyle f(x) + f(y) =f\left(\frac{x+y}{1+xy} \right)\)</span>，当<spanclass="math inline">\(x \in (-1, 0)\)</span>时<spanclass="math inline">\(f(x)&gt;0\)</span>，证明：<br /><span class="math display">\[    f\left(\frac{1}{5}\right) + f\left(\frac{1}{11}\right) + \cdots +f\left(\frac{1}{n^2 + 3n + 1} \right) &gt; f\left(\frac{1}{2}\right)\]</span></p><p>$238. $ 已知<span class="math inline">\(3 \sin^2 \alpha + 2 \sin^2\beta = 2 \sin \alpha\)</span>，则<span class="math inline">\(\sin^2\alpha + \sin^2 \beta\)</span>的取值范围是？</p><p>$239. $ 已知函数<span class="math inline">\(f(x) = x^2 + bx + c(b, c\in \mathbb{R})\)</span>，对任意<span class="math inline">\(x \in\mathbb{R}\)</span>，恒有<span class="math inline">\(f^\prime(x) \lef(x)\)</span>；<br />（1）证明：当<span class="math inline">\(x \ge 0\)</span>时，<spanclass="math inline">\(f(x) \le (x + c)^2\)</span>；<br />（2）若对满足题设条件的任意<spanclass="math inline">\(b,c\)</span>，不等式<spanclass="math inline">\(f(c) - f(b) \le M (c^2 -b^2)\)</span>恒成立，求<spanclass="math inline">\(M\)</span>的最小值。</p><p>$240. $ 已知<span class="math inline">\(f(x) = -x^2 + 8x, g(x) = 6\ln x + m\)</span>，已知<spanclass="math inline">\(f(x)-g(x)=0\)</span>有且仅有两个不同的解，求<spanclass="math inline">\(m\)</span>的值。</p><p>$241. $ 若<span class="math inline">\(a \ne 0, \sin x + \sin y = a,\cos x + \cos y = a\)</span>，则$x + x = $？</p><p>$242. $ 已知直线<span class="math inline">\(\displaystyle x =\frac{\pi}{6}\)</span>是函数<span class="math inline">\(y = a \sin x - b\cos x\)</span>图像的一条对称轴，则函数<span class="math inline">\(y = b\sin x - a \cos x\)</span>图像的一条对称轴方程为？</p><p>$243. $ 在三角形<span class="math inline">\(ABC\)</span>中，<spanclass="math inline">\(\cos 2B &gt; \cos 2A\)</span>是<spanclass="math inline">\(A &gt;B\)</span>的什么条件？（充分，必要，充要）</p><p>$244. $ 在<span class="math inline">\(\triangleABC\)</span>中，若<span class="math inline">\(\displaystyle C =\frac{\pi}{3}, a &gt; 1, b - c = \frac{1}{2}\)</span>，求<spanclass="math inline">\(b\)</span>的最小值。</p><p>$245. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(\displaystyle \overrightarrow{OC} = \frac{1}{4}\overrightarrow{OA}, \overrightarrow{OD} = \frac{1}{2}\overrightarrow{OB}\)</span>，<spanclass="math inline">\(AD\)</span>与<spanclass="math inline">\(BC\)</span>交于<spanclass="math inline">\(M\)</span>点，过<spanclass="math inline">\(M\)</span>作直线分别交<spanclass="math inline">\(OB,OA\)</span>于<spanclass="math inline">\(F,E\)</span>两点，若<spanclass="math inline">\(\overrightarrow {OE} = p \overrightarrow{OA},\overrightarrow{OF} = q \overrightarrow{OB}\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{1}{p} +\frac{3}{q}\)</span>为定值。</p><p>$246. $ 已知<span class="math inline">\(M\)</span>是以点<spanclass="math inline">\(C\)</span>为圆心的圆<spanclass="math inline">\((x+1)^2 + y^2 = 8\)</span>上的动点，定点<spanclass="math inline">\(D(1,0)\)</span>，点<spanclass="math inline">\(P\)</span>在<spanclass="math inline">\(DM\)</span>上，点<spanclass="math inline">\(N\)</span>在<spanclass="math inline">\(CM\)</span>上，且满足<spanclass="math inline">\(\overrightarrow{DM} = 2 \overrightarrow{DP},\overrightarrow{NP} \cdot \overrightarrow{DM} = 0\)</span>，设动点<spanclass="math inline">\(N\)</span>的轨迹曲线为曲线<spanclass="math inline">\(E\)</span>；<br />（1）求曲线<span class="math inline">\(E\)</span>的方程；<br />（2）线段<span class="math inline">\(AB\)</span>是曲线<spanclass="math inline">\(E\)</span>的长为<spanclass="math inline">\(2\)</span>的动弦，<spanclass="math inline">\(O\)</span>为坐标原点，求<spanclass="math inline">\(\triangle AOB\)</span>面积<spanclass="math inline">\(S\)</span>的取值范围。</p><p>$247. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(\displaystyle a_1 = 1, a_2 =\frac{1}{2}\)</span>，且<span class="math inline">\(\displaystylea_{n+2} = \frac{a_{n+1}^2}{a_n + a_{n+1}} (n \in\mathbb{N}^+)\)</span>；<br />（1）求数列<spanclass="math inline">\(\{a_n\}\)</span>的通项公式；<br />（2）求下表中前<span class="math inline">\(n\)</span>行的所有数的和<spanclass="math inline">\(S_n\)</span>。</p><p><span class="math display">\[\begin{matrix}\frac{a_1a_1}{a_2}\\\frac{a_1a_2}{a_3} &amp; \frac{a_2a_1}{a_3} \\\frac{a_1a_3}{a_4} &amp; \frac{a_2a_2}{a_4} &amp; \frac{a_3a_1}{a_4} \\\cdots \\\frac{a_1a_n}{a_{n+1}} &amp; \frac{a_2a_{n-1}}{a_{n+1}} &amp; \cdots&amp; \frac{a_na_1}{a_{n+1}}\end{matrix}\]</span></p><p>$248. $ 设<span class="math inline">\(x, y\)</span>均为正数且<spanclass="math inline">\(4x + y = xy\)</span>，则<spanclass="math inline">\(x+y\)</span>的最小值为？</p><p>$249. $ 若直线<spanclass="math inline">\(m\)</span>被两条平行直线<spanclass="math inline">\(l_1: x - y + 1 = 0\)</span>与<spanclass="math inline">\(x - y + 3 = 0\)</span>所得的线段长为<spanclass="math inline">\(2\sqrt 2\)</span>，则<spanclass="math inline">\(m\)</span>的倾斜角为？</p><p>$250. $ 已知<span class="math inline">\(M(-3, 0), N(3, 0), B(1,0)\)</span>，动圆<span class="math inline">\(C\)</span>与直线<spanclass="math inline">\(MN\)</span>切于点<spanclass="math inline">\(B\)</span>，过<spanclass="math inline">\(M,N\)</span>与圆<spanclass="math inline">\(C相切的两直线相交于\)</span>P<spanclass="math inline">\(点，则点\)</span>P$的轨迹方程是？</p><p>$251. $ 已知圆<span class="math inline">\(C_1: (x+3)^2 + (y-1)^2 =4\)</span>和圆<span class="math inline">\(C_2: (x-4)^2 + (y - 5)^2 =4\)</span>，存在过点<spanclass="math inline">\(P\)</span>的无穷多对互相垂直的直线<spanclass="math inline">\(l_1,l_2\)</span>，它们分别于圆<spanclass="math inline">\(C_1\)</span>和圆<spanclass="math inline">\(C_2\)</span>相交，且直线<spanclass="math inline">\(l_1\)</span>被圆<spanclass="math inline">\(C_1\)</span>截得的线段长于直线<spanclass="math inline">\(l_2\)</span>截得的线段相等，试求所有<spanclass="math inline">\(P\)</span>点的坐标。</p><p>$252. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{4} + y^2 = 1\)</span>，设直线<spanclass="math inline">\(l\)</span>与椭圆相交于不同的两点<spanclass="math inline">\(A,B\)</span>，已知点<spanclass="math inline">\(A\)</span>的坐标为<span class="math inline">\((-a,0)\)</span>，点<span class="math inline">\(Q(0, y_0)\)</span>在线段<spanclass="math inline">\(AB\)</span>的垂直平分线上且<spanclass="math inline">\(\overrightarrow{QA} \cdot \overrightarrow{QB} =4\)</span>，求<span class="math inline">\(y_0\)</span>的值。</p><p>$253. $ 已知抛物线<span class="math inline">\(C: y^2 =4x\)</span>的焦点为<span class="math inline">\(F\)</span>，过点<spanclass="math inline">\(K(-1, 0)\)</span>的直线<spanclass="math inline">\(l\)</span>与<spanclass="math inline">\(C\)</span>相交于<spanclass="math inline">\(A,B\)</span>两点，点<spanclass="math inline">\(A\)</span>关于<spanclass="math inline">\(x\)</span>轴的对称点为<spanclass="math inline">\(D\)</span>；<br />（1）证明：点<span class="math inline">\(F\)</span>在直线<spanclass="math inline">\(BD\)</span>上；<br />（2）设<span class="math inline">\(\displaystyle \overrightarrow{FA}\cdot \overrightarrow{FB} = \frac{8}{9}\)</span>，求<spanclass="math inline">\(\triangle BDK\)</span>的内切圆<spanclass="math inline">\(M\)</span>的方程。</p><p>$254. $ 设<span class="math inline">\(O\)</span>为坐标原点，<spanclass="math inline">\(F_1,F_2\)</span>是双曲线<spanclass="math inline">\(\displaystyle \frac{x^2}{a^2} - \frac{y^2}{b^2} =1 (a&gt;0, b&gt;0)\)</span>的焦点，若在双曲线上存在点<spanclass="math inline">\(P\)</span>，满足<span class="math inline">\(\angleF_1PF_2 = 60^\circ, |OP|=\sqrt{7}a\)</span>，则该双曲线的渐进线方程为？</p><p>$256. $ 设<span class="math inline">\(P\)</span>是双曲线<spanclass="math inline">\(\displaystyle x^2 -\frac{y^3}{3}=1\)</span>的右支上的动点，<spanclass="math inline">\(F\)</span>为双曲线的右焦点，已知<spanclass="math inline">\(A(3, 1)\)</span>，则<spanclass="math inline">\(|PA| + |PF|\)</span>的最小值为？</p><p>$257. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{2} + y^2 = 1\)</span>，点<span class="math inline">\(P(x_0,2-x_0) (x_0 \ne 2)\)</span>，点<spanclass="math inline">\(F_1,F_2\)</span>分别是椭圆的左右焦点，若<spanclass="math inline">\(PF_1,PF_2\)</span>与椭圆交于<spanclass="math inline">\(C,D\)</span>和<spanclass="math inline">\(A,B\)</span>两点，直线<spanclass="math inline">\(OA,OB,OC,OD\)</span>的斜率分别记为<spanclass="math inline">\(k_{OA},k_{OB},k_{OC},k_{OD}\)</span>，且满足<spanclass="math inline">\(k_{OA} + k_{OB} + k_{OC} + k_{OD} =0\)</span>，求<span class="math inline">\(x_0\)</span>的值。</p><p>$258. $ 若椭圆<span class="math inline">\(\displaystyle \frac{x^2}{2}+ \frac{y^2}{3} = 1\)</span>上存在两点<spanclass="math inline">\(A,B\)</span>关于直线<span class="math inline">\(l:y = 4x + m\)</span>对称，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$259. $到两条相互垂直的异面直线的距离相等的点在过其中一条直线且平行于另一条直线的平面内的轨迹是？</p><p>$260. $ 已知<span class="math inline">\(\displaystyle \vec a =\left(\cos \frac{\pi}{4}x, 1\right), \vec b = \left(-2 \sin\frac{\pi}{4}x, f(x)\right), \vec a \perp \vec b\)</span>，数列<spanclass="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(\displaystyle a_1 = \frac{1}{2}, a_{n+1} = f(a_n),n \in \mathbb{N}^*\)</span>；<br />证明：（1）<span class="math inline">\(0 &lt; a_n &lt; a_{n+1} &lt;1\)</span>；<br />（2）<span class="math inline">\(\displaystyle a_{n+1} -\frac{\pi}{4}a_n &gt; \frac{4-\pi}{4}\)</span>。</p><p>$261. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>中，<spanclass="math inline">\(\displaystyle a_1 = 1, a_{n+1} = c -\frac{1}{a_n}\)</span>；<br />（1）设<span class="math inline">\(\displaystyle c = \frac{5}{2}, b_n =\frac{1}{a_n - 2}\)</span>，求<spanclass="math inline">\(\{b_n\}\)</span>的通项公式；<br />（2）求使不等式<span class="math inline">\(a_n &lt; a_{n+1} &lt;3\)</span>成立的<span class="math inline">\(c\)</span>的取值范围。</p><p>$262. $ 设函数的定义域为<spanclass="math inline">\(\mathbb{R}\)</span>，对于任意的实数<spanclass="math inline">\(m,n\)</span>，恒有<span class="math inline">\(f(m+ n) = f(m)f(n)\)</span>且当<span class="math inline">\(x &gt;0\)</span>时，<span class="math inline">\(0 &lt; f(x) &lt;1\)</span>，设<span class="math inline">\(A = \{(x, y) \mid f(x^2)f(y^2)&gt; f(1)\}, B = \{(x, y) \mid f(ax - y + 2) = 1, a \in\mathbb{R}\}\)</span>，若<span class="math inline">\(A \cap B =\varnothing\)</span>，求<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$263. $ 圆<span class="math inline">\(C\)</span>的方程<spanclass="math inline">\((x-2)^2 + y^2 = 4\)</span>，圆<spanclass="math inline">\(M\)</span>的方程<spanclass="math inline">\((x-2-5\cos \theta)^2 + (y - 5\sin\theta)^2 = 1(\theta \in \mathbb{R})\)</span>，过圆<spanclass="math inline">\(M\)</span>上任意一点<spanclass="math inline">\(P\)</span>作圆<spanclass="math inline">\(C\)</span>的两条切线<spanclass="math inline">\(PE,PF\)</span>，切点分别为<spanclass="math inline">\(E,F\)</span>，则<spanclass="math inline">\(\overrightarrow{PE} \cdot\overrightarrow{PF}\)</span>的最小值为？</p><p>$264. $ 过抛物线<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>的焦点<span class="math inline">\(F\)</span>作直线<spanclass="math inline">\(l\)</span>交抛物线于<spanclass="math inline">\(A,B\)</span>两点，且满足<spanclass="math inline">\(\overrightarrow{AF} = 2\overrightarrow{FB}\)</span>，若<span class="math inline">\(S_{\triangleOAB} = \sqrt 3 |\overrightarrow{AB}|\)</span>（<spanclass="math inline">\(O\)</span>为坐标原点），则<spanclass="math inline">\(p\)</span>的值为？</p><p>$265. $ 等比数列<spanclass="math inline">\(\{a_n\}\)</span>的首项<spanclass="math inline">\(\displaystyle a_1 = -\frac{1}{2}\)</span>，前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，且<spanclass="math inline">\(S_1,S_2,S_3\)</span>成等差数列，记<spanclass="math inline">\(\displaystyle b_n = \frac{2 +a_n}{1-a_n}\)</span>；<br />（1）记<span class="math inline">\(c_n = b_n -b_{2n-1}\)</span>，证明<span class="math inline">\(\displaystyle c_1 +c_2 + \cdots + c_n &lt; \frac{11}{4}\)</span>；<br />（2）设<span class="math inline">\(b_n\)</span>的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(R_n\)</span>，是否存在正整数<spanclass="math inline">\(k\)</span>使得<span class="math inline">\(R_k \ge2k\)</span>成立；若存在，求出<spanclass="math inline">\(k\)</span>的值，若不存在，请说明理由。</p><p>$265. $ 已知椭圆<span class="math inline">\(\displaystyle x^2 +\frac{y^2}{2} = 1\)</span>，点<span class="math inline">\(\displaystyleS(-\frac{1}{3}, 0)\)</span>，过点<spanclass="math inline">\(S\)</span>的直线<spanclass="math inline">\(l\)</span>交椭圆于<spanclass="math inline">\(A,B\)</span>两点，则以<spanclass="math inline">\(AB\)</span>为直径的圆是否恒过一定点<spanclass="math inline">\(T\)</span>？</p><p>$267. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，<span class="math inline">\(a_1 = 1,S_{n+1} = 2S_n + 3n + 1 (n \in \mathbb{N^+})\)</span>；<br />（1）求<span class="math inline">\(a_n\)</span>；<br />（2）对<span class="math inline">\(k \in \mathbb{N^+}\)</span>，设<spanclass="math inline">\(\displaystyle f(n) = \left\{\begin{aligned}&amp;S_n - a_n + 3n &amp; (n = 2k - 1)\\ &amp;\log_2(a_n + 3) &amp; (n =2k)\end{aligned} \right.\)</span>，求使不等式<spanclass="math inline">\(f(m) &gt; f(2m^2)\)</span>恒成立的自然数<spanclass="math inline">\(m\)</span>的最小值。</p><p>$268. $ 已知函数<span class="math inline">\(f(x) = a x^2 +ax\)</span>和<span class="math inline">\(g(x) = x -a\)</span>，其中<spanclass="math inline">\(a \in \mathbb{R}\)</span>且<spanclass="math inline">\(a \ne 0\)</span>，若<spanclass="math inline">\(p,q\)</span>是方程<spanclass="math inline">\(f(x)=g(x)\)</span>的两根且满足<spanclass="math inline">\(\displaystyle 0 &lt; p &lt; q &lt;\frac{1}{a}\)</span>，证明：当<span class="math inline">\(x \in (0,p)\)</span>时，<span class="math inline">\(g(x) &lt; f(x) &lt; p -a\)</span>。</p><p>$269. $ 设<span class="math inline">\(\triangleABC\)</span>的内角<spanclass="math inline">\(A,B,C\)</span>所对边分别为<spanclass="math inline">\(a,b,c\)</span>是<spanclass="math inline">\(\displaystyle a \cos c + \frac{1}{2}c =b\)</span>，若<span class="math inline">\(a = 1\)</span>，则<spanclass="math inline">\(\triangle ABC\)</span>的周长的取值范围是？</p><p>$270. $ 在<span class="math inline">\(\triangleABC\)</span>中，求证<span class="math inline">\(\cos 2A + \cos 2B + \cos2C = -1 - 4 \cos A \cos B \cos C\)</span>。</p><p>$271. $ 已知<span class="math inline">\(f(x) = ax^2 + bx + c(a \ne0)\)</span>，任给两个实数<spanclass="math inline">\(x_1,x_2\)</span>有方程<spanclass="math inline">\(\displaystyle f(x) = \frac{1}{2}(f(x_1) +f(x_2))\)</span>；<br />（1）求证：方程<span class="math inline">\(\displaystyle f(x) =\frac{1}{2}(f(x_1) +f(x_2))\)</span>有两个不相等的实根且有一个实根属于<spanclass="math inline">\((x_1,x_2)\)</span>；<br />（2）若上述方程的一个根为<span class="math inline">\(m\)</span>且<spanclass="math inline">\(x_1 &lt; m &lt; x_2\)</span>，且<spanclass="math inline">\(\displaystyle x_1, m - \frac{1}{2},x_2\)</span>成等差数列，求证<span class="math inline">\(x_0 &lt;m^2\)</span>，<span class="math inline">\(x_0\)</span>满足<spanclass="math inline">\(x=x_0\)</span>是<spanclass="math inline">\(f(x)\)</span>的对称轴。</p><p>$272. $ 已知<span class="math inline">\(\displaystyle f(x) = \left| x- \frac{1}{x}\right|\)</span>，若<span class="math inline">\(f^2(x) +bf(x) + c = 0\)</span>的方程有五个不同的实数解，则<spanclass="math inline">\(b, c\)</span>的取值范围分别是？</p><p>$273. $ 已知<span class="math inline">\(\displaystyle a_1 =\frac{3}{2}, a_{n+1} = a_n^2 - a_n + 1 (n \in\mathbb{N^+})\)</span>，则<span class="math inline">\(\displaystyle\frac{1}{a_1} + \frac{1}{a_2} + \cdots +\frac{1}{a_{2011}}\)</span>的整数部分是？</p><p>$274. $ 设数列<spanclass="math inline">\(\{a_n\}\)</span>是首项为<spanclass="math inline">\(0\)</span>的递增数列，<spanclass="math inline">\(\displaystyle f_n(x) = \left| \sin\left(\frac{1}{n} (x - a_n)\right)\right|, (x \in [a_n,a_{n+1}])\)</span>满足对任意的<span class="math inline">\(b \in [0, 1),f_n(x) = b\)</span>总有两个不同的根，求<span class="math inline">\(S_n =a_1 - a_2 + a_3 - a_4 + \cdots + (-1)^{n-1}a_n\)</span>。</p><p>$275. $ 设变量<span class="math inline">\(x,y\)</span>满足<spanclass="math inline">\(|x-2|+|y-2| \le 1\)</span>，则<spanclass="math inline">\(\displaystyle\frac{y-x}{x+1}\)</span>的最大值为？</p><p>$276. $ 已知<span class="math inline">\(f(x)\)</span>是定义在<spanclass="math inline">\((0, +\infty)\)</span>上的单调函数，且对任意的<spanclass="math inline">\(x \in (0, +\infty)\)</span>都有<spanclass="math inline">\(f(f(x) - \log_2^x) = 3\)</span>，则方程<spanclass="math inline">\(f(x) - f^\prime(x) =2\)</span>的解所在区间是？</p><p>$277. $ 已知点<span class="math inline">\(G\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>的外心，<spanclass="math inline">\(\overrightarrow{GA}, \overrightarrow{GB},\overrightarrow{GC}\)</span>是三个单位向量，且满足<spanclass="math inline">\(2\overrightarrow{GA} + \overrightarrow{AB} +\overrightarrow{AC} = 0, |\overrightarrow{GA}| =|\overrightarrow{AB}|\)</span>，如图所示<spanclass="math inline">\(\triangle ABC\)</span>的顶点<spanclass="math inline">\(B,C\)</span>分别在<spanclass="math inline">\(x\)</span>轴和<spanclass="math inline">\(y\)</span>轴的非负半轴上移动，<spanclass="math inline">\(O\)</span>是坐标原点，则<spanclass="math inline">\(|\overrightarrow{OA}|\)</span>的最大值为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.3cys7t6pkfk0.webp" width="25%"></p><p>$278. $ 设<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>是正整数<spanclass="math inline">\(1,2,3,\cdots,n\)</span>的一个排列，令<spanclass="math inline">\(b_j\)</span>表示排列在<spanclass="math inline">\(j\)</span>的左边且比<spanclass="math inline">\(j\)</span>大的数的个数，<spanclass="math inline">\(b_j\)</span>称为<spanclass="math inline">\(j\)</span>的逆序数，如在排列<spanclass="math inline">\(3,5,1,4,2,6\)</span>中，<spanclass="math inline">\(5\)</span>的逆序数是<spanclass="math inline">\(0\)</span>，<spanclass="math inline">\(2\)</span>的逆序数是<spanclass="math inline">\(3\)</span>，则由<spanclass="math inline">\(1\)</span>至<spanclass="math inline">\(9\)</span>这<spanclass="math inline">\(9\)</span>个数字构成的所有排列中满足<spanclass="math inline">\(1\)</span>的逆序数是<spanclass="math inline">\(2\)</span>，<spanclass="math inline">\(2\)</span>的逆序数是<spanclass="math inline">\(3\)</span>，<spanclass="math inline">\(5\)</span>的逆序数是<spanclass="math inline">\(3\)</span>的所有不同排列的种数是？</p><p>$279. $ 若点<spanclass="math inline">\(P(m+1,n+1)\)</span>在不等式<spanclass="math inline">\(\left\{ \begin{aligned} &amp; x+ y \ge 3 \\ &amp;x - y \ge 1 \\ &amp; 2x - y \le6\end{aligned}\right.\)</span>表示的可行域内，则<spanclass="math inline">\(\displaystyle\frac{2m+n+1}{m+2n+2}\)</span>的取值范围是？</p><p>$280. $ 若<span class="math inline">\(g(x) = \lambda x + \sinx\)</span>是区间<spanclass="math inline">\([-1,1]\)</span>上的减函数，且<spanclass="math inline">\(g(x) &lt; t^2 + \lambda t + 1\)</span>在<spanclass="math inline">\(x \in [-1, 1]\)</span>恒成立，则<spanclass="math inline">\(t\)</span>的取值范围是？</p><p>$281. $ 已知椭圆<span class="math inline">\(x^2 + 4y^2 =8\)</span>上一点<span class="math inline">\(M(2,1)\)</span>平行于<spanclass="math inline">\(OM\)</span>的直线<spanclass="math inline">\(l\)</span>在<spanclass="math inline">\(y\)</span>轴上的截距为<spanclass="math inline">\(m (m&lt;0)\)</span>，设直线<spanclass="math inline">\(l\)</span>交椭圆于两个不同点<spanclass="math inline">\(A,B\)</span>，证明<spanclass="math inline">\(\triangle ABM\)</span>的内心一定在直线<spanclass="math inline">\(l\)</span>上。</p><p>$282. $ 已知<span class="math inline">\(a_{x+y} = a_xa_y\)</span>且<span class="math inline">\(a_1 \ne 0, x,y \in \mathbb{R},S_n = \sum \limits_{i=1}^n a_i\)</span>，且<spanclass="math inline">\(\displaystyle b_n =\frac{2S_n}{a_n}+1\)</span>为等比数列，设<spanclass="math inline">\(\displaystyle c_n =\frac{1}{1+2a_n}\)</span>，证明：<br />（1）对任意<span class="math inline">\(x&gt;0\)</span>，<spanclass="math inline">\(\displaystyle c_n \ge \frac{1}{1+x} -\frac{1}{1+x^2}(2a_n - x) (n \in \mathbb{N^+})\)</span>；<br />（2）<span class="math inline">\(\displaystyle c_1 + c_2 + \cdots + c_n&gt; \frac{n^2}{n+1} (n \in \mathbb{N}^+)\)</span>。</p><p>$283. $ 圆心<spanclass="math inline">\(P(x_0,y_0)\)</span>在椭圆<spanclass="math inline">\(\displaystyle \frac{x^2}{25} + \frac{y^2}{16} =1\)</span>上，半径<span class="math inline">\(\displaystyle r =\frac{3}{5}x_0 + 3\)</span>的所有圆覆盖的图形面积为？</p><p>$284. $ 证明：<span class="math inline">\(\displaystyle 1 +\frac{1}{2 \cdot 2} + \frac{1}{3 \cdot 2^2} + \cdots + \frac{1}{n \cdot2^{n-1}} &lt; \frac{2}{3}\)</span>。</p><p>$285. $ 已知点<span class="math inline">\(A,B\)</span>分别在<spanclass="math inline">\(x,y\)</span>轴上运动，且<spanclass="math inline">\(|AB| = 8\)</span>，动点<spanclass="math inline">\(P\)</span>满足<spanclass="math inline">\(\displaystyle \overrightarrow{AP} =\frac{3}{5}\overrightarrow{PB}\)</span>，设点<spanclass="math inline">\(P\)</span>的轨迹为曲线<spanclass="math inline">\(C\)</span>，定点<spanclass="math inline">\(M(4,0)\)</span>，直线<spanclass="math inline">\(PM\)</span>交曲线<spanclass="math inline">\(C\)</span>与点<spanclass="math inline">\(Q\)</span>（非<spanclass="math inline">\(P\)</span>点）;<br />（1）求曲线<span class="math inline">\(C\)</span>的方程；<br />（2）求<span class="math inline">\(\triangleOPQ\)</span>面积最大值并求此时直线<spanclass="math inline">\(PM\)</span>的方程。</p><p>$286. $ 设<span class="math inline">\(D\)</span>是边长为<spanclass="math inline">\(3\)</span>的正<spanclass="math inline">\(\triangleP_1P_2P_3\)</span>及其内部的点构成的集合；点<spanclass="math inline">\(P_0\)</span>是<spanclass="math inline">\(\triangle P_1P_2P_3\)</span>的中心，则集合<spanclass="math inline">\(S = \{ P \mid P \in D, |PP_0| \le |PP_i|, i=1,2,3\}\)</span>所表示的平面区域的面积是？</p><p>$287. $ <span class="math inline">\(y = \lnx\)</span>上是否存在不同的两点<spanclass="math inline">\(A,B\)</span>，线段<spanclass="math inline">\(AB\)</span>的中点的横坐标为<spanclass="math inline">\(x_0\)</span>，使得函数<spanclass="math inline">\(y = \ln x\)</span>在<spanclass="math inline">\(M(x_0, \ln x_0)\)</span>处的切线<spanclass="math inline">\(l \parallel AB\)</span>？若存在，求切线<spanclass="math inline">\(l\)</span>的方程，若不存在，请说明理由。</p>$288. $ 设实数<span class="math inline">\(x, y\)</span>满足$ {<span class="math display">\[\begin{aligned}|x| \le 1 \\ |y| \le1\end{aligned}\]</span><p>. <span class="math inline">\(，则\)</span>z = $的取值范围是？</p><p>$289. $ 已知<span class="math inline">\(A,B,P\)</span>是双曲线<spanclass="math inline">\(\displaystyle \frac{x^2}{a^2} - \frac{y^2}{b^2} =1 (a &gt; b &gt; 0)\)</span>上不同的三点，且<spanclass="math inline">\(AB\)</span>连线过坐标原点<spanclass="math inline">\(O\)</span>，若直线<spanclass="math inline">\(PA,PB\)</span>的斜率之积<spanclass="math inline">\(\displaystyle k_{PA} \cdot k_{PB} =\frac{2}{3}\)</span>，则双曲线的离心率为？</p><p>$290. $将一个三位数的三个数字顺序颠倒，将所得的数与原数相加，若和的所有位数中没有一个偶数，则称这个数为“奇和数”，那么所有3位数中“奇和数”的个数为？</p><p>$291. $ 定义在<span class="math inline">\([1,+\infty)\)</span>上的函数<span class="math inline">\(\displaystyle f(x)= \left\{ \begin{aligned} &amp; 4 - 8 |x - \frac{3}{2}| &amp; (1 \le x\le 2) \\ &amp; \frac{1}{2}f(\frac{x}{2}) &amp; (x&gt; 2)\end{aligned}\right.\)</span>，则以下成立的有：<br />（1）函数<span class="math inline">\(f(x)\)</span>的值域为<spanclass="math inline">\([0, 4]\)</span>；<br />（2）关于<span class="math inline">\(x\)</span>的方程<spanclass="math inline">\(\displaystyle f(x) = (\frac{1}{2})^n (n \in\mathbb{N^+})\)</span>有<spanclass="math inline">\(2n+4\)</span>个不相等的实根；<br />（3）当<span class="math inline">\(x \in [2^{n-1}, 2^n] (n \in\mathbb{N^+})\)</span>时，函数<spanclass="math inline">\(f(x)\)</span>的图像与<spanclass="math inline">\(x\)</span>轴围成的图形面积<spanclass="math inline">\(S = 2\)</span>；<br />（4）存在<span class="math inline">\(x_0 \in [1,8]\)</span>，使得不等式<span class="math inline">\(x_0 f(x_0) &gt;6\)</span>成立。</p><p>$292. $ <span class="math inline">\(\displaystyle f(x) =\frac{1}{2}x, g(x) = e \ln x\)</span>，是否存在直线<spanclass="math inline">\(y = kx + m\)</span>使得<spanclass="math inline">\(f(x) \ge kx + m\)</span>和<spanclass="math inline">\(g(x) \le kx + m\)</span>都成立？</p><p>$293. $ 如图，<span class="math inline">\(A,B,C\)</span>是圆<spanclass="math inline">\(O\)</span>上三点，射线<spanclass="math inline">\(CO\)</span>与线段<spanclass="math inline">\(AB\)</span>的延长线交于点<spanclass="math inline">\(D\)</span>，若<spanclass="math inline">\(\overrightarrow{OC} = \alpha \overrightarrow{OA} +\beta \overrightarrow{OB}\)</span>，则<span class="math inline">\(\alpha+ \beta\)</span>的取值范围是？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.16gkknp6tf7k.webp" width="25%"></p><p>$294. $ 等差数列<span class="math inline">\(a_n\)</span>的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，若<spanclass="math inline">\(\displaystyle \left\{ \frac{S_n}{a_n}\right\}\)</span>是公差为<spanclass="math inline">\(d\)</span>的等差数列，则<spanclass="math inline">\(d=\)</span>？</p><p>$295. $ <spanclass="math inline">\(a,b,c\)</span>分别是直角三角形<spanclass="math inline">\(ABC\)</span>的三边，其中<spanclass="math inline">\(c\)</span>为斜边，若不等式<spanclass="math inline">\(a^2(b+c) + b^2(a+c) + c^2(a+b) \gekabc\)</span>对任意的<spanclass="math inline">\(a,b,c\)</span>都成立，求<spanclass="math inline">\(k\)</span>的取值范围。</p><p>$296. $ 已知<span class="math inline">\(a_{n+1} = a_n^2 - 2n a_n + 1(n \in \mathbb{N^+})\)</span>；<br />（1）证明：<span class="math inline">\(a_n \ge 2n + 2, n \in\mathbb{N^+}\)</span>；<br />（2）求证<span class="math inline">\(\displaystyle \frac{1}{1+a_1} +\frac{1}{1+a_2} + \cdots + \frac{1}{1+a_n} &lt;\frac{2}{5}\)</span>。</p><p>$297. $ 如图，设<span class="math inline">\(P\)</span>为直线<spanclass="math inline">\(y = x - 2\)</span>上的动点，过点<spanclass="math inline">\(P\)</span>作抛物线<spanclass="math inline">\(\displaystyle y =\frac{1}{2}x^2\)</span>的两条切线，切点分别为<spanclass="math inline">\(A,B\)</span>；<br />（1）求证直线<span class="math inline">\(AB\)</span>过定点；<br />（2）求<span class="math inline">\(\triangle PAB\)</span>的面积<spanclass="math inline">\(S\)</span>的最小值。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.1gjet3zwahls.webp" width="25%"></p><p>$298. $ 若偶函数<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([-1,0]\)</span>上是增函数，<spanclass="math inline">\(\alpha,\beta\)</span>是锐角三角形的两个内角，则下面成立的有：<br />（1）<span class="math inline">\(f(\cos \alpha) &gt; f(\cos\beta)\)</span>；<br />（2）<span class="math inline">\(f(\sin \alpha) &gt; f(\cos\beta)\)</span>；<br />（3）<span class="math inline">\(f(\sin \alpha) &gt; f(\sin\beta)\)</span>；<br />（4）<span class="math inline">\(f(\cos \alpha) &gt; f(\sin\beta)\)</span>。</p><p>$299. $ 设集合<span class="math inline">\(A = [0, \frac{1}{2}], B =[\frac{1}{2}, 1]\)</span>，函数<span class="math inline">\(f(x) =\left\{ \begin{aligned} &amp; x+ \frac{1}{2} &amp; x \in A \\ &amp;2(1-x) &amp; x \in B\end{aligned} \right.\)</span>，若<spanclass="math inline">\(x_0 \in [0, 1]\)</span>且<spanclass="math inline">\(f(x_0) \in A\)</span>，则<spanclass="math inline">\(x_0\)</span>的取值范围是？</p><p>$300. $ 已知两点<span class="math inline">\(A(-1,-2), B(1,-1)\)</span>，给出下列曲线方程：（1）<span class="math inline">\(4x + 2y- 1 = 0\)</span>；（2）<span class="math inline">\(x^2 + y^2 =4\)</span>；（3）<span class="math inline">\(\displaystyle x^2 +\frac{y^2}{2} = 1\)</span>；（4）<spanclass="math inline">\(\displaystyle x^2 - \frac{y^2}{2} =1\)</span>，则在曲线上存在点<spanclass="math inline">\(P\)</span>满足<spanclass="math inline">\(\overrightarrow{AP} \cdot \overrightarrow{AB} =0\)</span>的所有曲线方程为？</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题三：高中篇2</title>
      <link href="/2022/03/04/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%983/"/>
      <url>/2022/03/04/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<p>$101. $ 已知<span class="math inline">\(g(x)\)</span>的图像是<spanclass="math inline">\(f(x)\)</span>的图像关于原点对称，且<spanclass="math inline">\(f(x) = x^2 + 2x\)</span>；<br />（1）解不等式<span class="math inline">\(g(x) \ge f(x) - |x -1|\)</span>；<br />（2）若<span class="math inline">\(h(x) = g(x) - \lambda f(x) +1\)</span>在<spanclass="math inline">\([-1,1]\)</span>上是增函数，求实数<spanclass="math inline">\(\lambda\)</span>的取值范围。</p><span id="more"></span><p>$102. $ 已知<span class="math inline">\(\displaystyle \vec a =(\sqrt2 \sin wx, \cos wx + \sin wx), \vec b = (\cos wx, \frac{\sqrt6}{2} \cos wx - \frac{\sqrt 6}{2} \sin wx)\)</span>，其中<spanclass="math inline">\(0 &lt; w &lt; 2\)</span>，函数<spanclass="math inline">\(f(x) = \vec a \cdot \vec b\)</span>，且<spanclass="math inline">\(f(x)\)</span>的图像关于直线<spanclass="math inline">\(\displaystyle x =\frac{\pi}{12}\)</span>对称，且在<spanclass="math inline">\(\displaystyle x =\frac{\pi}{12}\)</span>处取最大值，若<spanclass="math inline">\(\displaystyle x \in [\frac{5\pi}{24}, \frac{7\pi}{12}]\)</span>时，<span class="math inline">\(|f(x) - m| \le3\)</span>恒成立，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$103. $ 如图，<span class="math inline">\(Rt \triangleABC\)</span>中，<span class="math inline">\(S,r\)</span>分别是<spanclass="math inline">\(\triangle ABC\)</span>的面积和内切圆半径，<spanclass="math inline">\(l\)</span>是三角形周长，令<spanclass="math inline">\(\displaystyle t = \frac{lr}{S}\)</span>；<br />（1）<span class="math inline">\(t\)</span>表示为<spanclass="math inline">\(\angle A\)</span>的函数<spanclass="math inline">\(t = f(A)\)</span>；<br />（2）<span class="math inline">\(t = f(A)\)</span>的取值范围。</p><p>$104. $ 在<span class="math inline">\(\triangleABC\)</span>中，若<span class="math inline">\(\displaystyle\frac{\overrightarrow {AB} \cdot \overrightarrow {BC}}{3} =\frac{\overrightarrow {BC} \cdot \overrightarrow {CA}}{2} =\overrightarrow {CA} \cdot \overrightarrow{AB}\)</span>，则<spanclass="math inline">\(\tan A=\)</span>?</p><p>$105. $ 已知<span class="math inline">\(\displaystyle \vec a = (\sqrt3, -1), \vec b = (\frac{1}{2}, \frac{\sqrt 3}{2}), \vec c = \vec a +(\cos \pi x - \sin pi x) \vec b, \vec d = (y - 1) \vec a + (\sin \pi x)\vec b\)</span>，其中<span class="math inline">\(\displaystyle x,y \in\mathbb{R}, x \in (-\frac{1}{2}, \frac{1}{2}), \vec c \perp \vecd\)</span>，<br />（1）求函数<spanclass="math inline">\(y=f(x)\)</span>的解析式与最大值；<br />（2）若函数<span class="math inline">\(f(x)\)</span>是区间<spanclass="math inline">\(\displaystyle [1 - \frac{p}{2},\frac{p}{16}]\)</span>上的减函数，求<spanclass="math inline">\(p\)</span>的取值范围。</p><p>$106. $ <spanclass="math inline">\(l_1,l_2,l_3\)</span>是三条平行的直线，<spanclass="math inline">\(l_1,l_2\)</span>的距离为<spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(l_2,l_3\)</span>的距离为<spanclass="math inline">\(2\)</span>，正三角形<spanclass="math inline">\(ABC\)</span>的三个顶点分别在<spanclass="math inline">\(l_1,l_2,l_3\)</span>上，则<spanclass="math inline">\(\triangle ABC\)</span>的边长是？</p><p>$107. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{9} + \frac{y^2}{5} = 1\)</span>的左右顶点为<spanclass="math inline">\(A,B\)</span>，右焦点为<spanclass="math inline">\(F\)</span>，设过点<spanclass="math inline">\(T(9,m)\)</span>的直线<spanclass="math inline">\(TA,TB\)</span>与椭圆分别交于<spanclass="math inline">\(M(x_1,y_2), N(x_2,y_2)\)</span>，其中<spanclass="math inline">\(m&gt;0, y_1&gt;0, y_2&lt;0\)</span>，求证<spanclass="math inline">\(MN\)</span>必过一定点。</p><p>$108. $ 已知关于<span class="math inline">\(x\)</span>的不等式组<spanclass="math inline">\(1 \le kx^2 + 2x + k \le2\)</span>有唯一的实数解，则实数<spanclass="math inline">\(k\)</span>的取值范围是？</p><p>$109. $ 当<span class="math inline">\(\displaystyle 0 &lt; x &lt;\frac{\pi}{2}\)</span>时，函数<span class="math inline">\(\displaystylef(x) = \frac{1 + \cos 2x + 8 \sin^2 x}{\sin 2x}\)</span>的最小值是？</p><p>$110. $ 已知<span class="math inline">\(a \ge 0, b \ge 0, a + b =1\)</span>，则<span class="math inline">\(\displaystyle \sqrt {a +\frac{1}{2}} + \sqrt {b + \frac{1}{2}}\)</span>的取值范围是？</p><p>$111. $ 在平行四边形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AB=AC=1\)</span>，<spanclass="math inline">\(\angle ACD =90^\circ\)</span>，将它们沿对角线<spanclass="math inline">\(AC\)</span>折起，使<spanclass="math inline">\(AB\)</span>与<spanclass="math inline">\(CD\)</span>成<spanclass="math inline">\(60^\circ\)</span>角，求<spanclass="math inline">\(BD\)</span>的长度。</p><p>$112. $ 过抛物线<span class="math inline">\(C: y =x^2\)</span>上两点<span class="math inline">\(M,N\)</span>的直线<spanclass="math inline">\(l\)</span>交<spanclass="math inline">\(y\)</span>轴于点<span class="math inline">\(D(0,b)\)</span>；<br />（1）若<span class="math inline">\(\angle MDN\)</span>为钝角（<spanclass="math inline">\(O\)</span>为坐标原点），求<spanclass="math inline">\(b\)</span>的取值范围；<br />（2）若<span class="math inline">\(b = 2\)</span>，曲线<spanclass="math inline">\(C\)</span>在<spanclass="math inline">\(M,N\)</span>处的切线的交点为<spanclass="math inline">\(Q\)</span>，求证点<spanclass="math inline">\(Q\)</span>必在一条定直线上运动。</p><p>$113. $ 设<span class="math inline">\(G,M\)</span>分别为不等边<spanclass="math inline">\(\triangle ABC\)</span>的垂心与外心，<spanclass="math inline">\(A(-1, 0), B(1, 0)\)</span>，且<spanclass="math inline">\(GM \parallel AB\)</span>，求点<spanclass="math inline">\(C\)</span>的轨迹方程。</p><p>$114. $ 在平面直角坐标系中，过顶点<spanclass="math inline">\(C(0,p)\)</span>作直线与抛物线<spanclass="math inline">\(x^2 = 2py (p&gt;0)\)</span>相交于<spanclass="math inline">\(A,B\)</span>两点，若点<spanclass="math inline">\(N\)</span>是点<spanclass="math inline">\(C\)</span>关于原点<spanclass="math inline">\(O\)</span>的对称点，<br />（1）求<span class="math inline">\(\triangleANB\)</span>面积的最小值；<br />（2）是否存在垂直于<span class="math inline">\(y\)</span>轴的直线<spanclass="math inline">\(l\)</span>，使得<spanclass="math inline">\(l\)</span>被以<spanclass="math inline">\(AC\)</span>为直径的圆截得的弦长恒为定值。</p><p>$115. $ 已知双曲线<span class="math inline">\(\displaystyle\frac{x^2}{m^2} - \frac{y^2}{n^2} = 1 (m &gt;0,n&gt;0)\)</span>的顶点<spanclass="math inline">\(A_1,A_2\)</span>，与<spanclass="math inline">\(y\)</span>轴平线的直线<spanclass="math inline">\(l\)</span>交双曲线于点<spanclass="math inline">\(P,Q\)</span>，求直线<spanclass="math inline">\(A_1P\)</span>与<spanclass="math inline">\(A_2Q\)</span>交点<spanclass="math inline">\(M\)</span>的轨迹方程。</p><p>$116. $ 已知<span class="math inline">\(f(f(x) - x^2 + x) = f(x) -x^2 + x\)</span>，设有且仅有一个实数<spanclass="math inline">\(x_0\)</span>使得<span class="math inline">\(f(x_0)= x_0\)</span>，求函数<spanclass="math inline">\(f(x)\)</span>的解析式。</p><p>$117. $ 设<span class="math inline">\(x \ge 0, y \ge0\)</span>，且<span class="math inline">\(\displaystyle 2x + y =\frac{1}{2}\)</span>，那么函数<span class="math inline">\(\displaystyley = \log_{\frac{1}{5}} (4x^2 + 8xy + 1)\)</span>的最大值为？</p><p>$118. $ 将半径为<spanclass="math inline">\(1\)</span>的四个钢球完全装入正四面体的容器里，则这个四面体的高的最小值为？</p><p>$119. $ 过点<span class="math inline">\(A(11, 2)\)</span>作圆<spanclass="math inline">\(x^2 + y^2 + 2x - 4y - 164 =0\)</span>的弦，其中弦为整数的共有多少条？</p><p>$120. $ 若圆<span class="math inline">\(O_1: x^2 + y^2 =5\)</span>与圆<span class="math inline">\(O_2: (x-m)^2 + y^2 = 20 (m \in\mathbb{R})\)</span>相交于<spanclass="math inline">\(A,B\)</span>两点，且两圆在点<spanclass="math inline">\(A\)</span>处的切线相互垂直，则线段<spanclass="math inline">\(AB\)</span>的长度是？</p><p>$121. $ 若圆<span class="math inline">\(x^2 + y^2 =4\)</span>与圆<span class="math inline">\(x^2 + y^2 + 2ay - 6 = 0 (a&gt; 0)\)</span>的公共弦长为<span class="math inline">\(2\sqrt3\)</span>，则<span class="math inline">\(a=\)</span>?</p><p>$122. $ 已知圆<span class="math inline">\(x^2 + y^2 =1\)</span>，过点<span class="math inline">\(A(1,0)\)</span>作直线交圆于<spanclass="math inline">\(Q\)</span>，在直线上取一点<spanclass="math inline">\(P\)</span>，作<spanclass="math inline">\(P\)</span>到<spanclass="math inline">\(x=-1\)</span>的距离等于<spanclass="math inline">\(|PQ|\)</span>，求点<spanclass="math inline">\(P\)</span>的运动轨迹。</p><p>$123. $ 已知<span class="math inline">\(x_1 + \lg x_1 = 3, x_2 +10^{x_2} = 3\)</span>，求<span class="math inline">\(x_1 +x_2\)</span>。</p><p>$124. $ 过圆<span class="math inline">\(x^2 + y^2 =5\)</span>内一点<span class="math inline">\(\displaystyle P(\frac{\sqrt5}{2}, \frac{\sqrt 3}{2})\)</span>有<spanclass="math inline">\(n\)</span>条弦，这<spanclass="math inline">\(n\)</span>条弦长成等差数列<spanclass="math inline">\(\{a_n\}\)</span>，如果过点<spanclass="math inline">\(P\)</span>的最短弦长为<spanclass="math inline">\(a_1\)</span>，最长弦长为<spanclass="math inline">\(a_n\)</span>，且公差<spanclass="math inline">\(\displaystyle d \in (\frac{1}{6},\frac{1}{3})\)</span>，那么<spanclass="math inline">\(n\)</span>的取值集合为?</p><p>$125. $ 已知<span class="math inline">\(a &gt; b&gt;0\)</span>，则<span class="math inline">\(\displaystyle a^2 +\frac{25}{b(a-b)}\)</span>的最小值为？</p><p>$126. $ 已知<span class="math inline">\(a, b, c \in (0,1)\)</span>，求证<span class="math inline">\((1-a)b, (1-b)c,(1-c)a\)</span>不能同时大于<spanclass="math inline">\(\frac{1}{4}\)</span>。</p><p>$127. $ 设<span class="math inline">\(f(x) = |\lg x|\)</span>，<spanclass="math inline">\(a,b\)</span>满足<spanclass="math inline">\(\displaystyle f(a) = f(b) =2f(\frac{a+b}{2})\)</span>，其中<span class="math inline">\(0 &lt; a&lt; b\)</span>；<br />（1）求证：<span class="math inline">\(a &lt; 1 &lt; b\)</span>；<br />（2）求证：<span class="math inline">\(2 &lt; 4b - b^2 &lt;3\)</span>。</p><p>$128. $ 已知<span class="math inline">\(\displaystyle f(x) = 4 \sin^2(\frac{\pi}{4} + x) - 2 \sqrt 3 \cos 2x - 1\)</span>，且给定条件<spanclass="math inline">\(\displaystyle p: \frac{\pi}{4} \le x \le\frac{\pi}{2}\)</span>，条件<span class="math inline">\(q: |f(x) - m|&lt; 2\)</span>，且<span class="math inline">\(p\)</span>是<spanclass="math inline">\(q\)</span>的充分条件，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$129. $ 在棱长为<span class="math inline">\(a\)</span>的正方体<spanclass="math inline">\(ABCD-A_1B_1C_1D_1\)</span>中，<spanclass="math inline">\(\displaystyle \overrightarrow{AE} = \frac{1}{2}\overrightarrow{AB_1}\)</span>，在平面<spanclass="math inline">\(ABCD\)</span>中取一点<spanclass="math inline">\(F\)</span>，使<spanclass="math inline">\(\overrightarrow{EF} +\overrightarrow{FG}\)</span>最小，则最小值为？</p><p>$130. $ 设<span class="math inline">\(f(x) = ax^2 - (a^2 - b^2) x -4c^2\)</span>，且<span class="math inline">\(f(2) = 0\)</span>，在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(a,b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，求角<spanclass="math inline">\(C\)</span>的取值范围。</p><p>$131. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(A\)</span>最大，<spanclass="math inline">\(C\)</span>最小，且<span class="math inline">\(A =2C\)</span>，<span class="math inline">\(a + c =2b\)</span>，求此三边之比。</p><p>$132. $ 已知<span class="math inline">\(\triangleABC\)</span>满足<span class="math inline">\(a^2 - a - 2b - 2c = 0, a +2b - 2c + 3 = 0\)</span>，判断哪一个角最大，并求出最大角。</p><p>$133. $ <spanclass="math inline">\(B_1,B_2,\cdots,B_n\)</span>依次为曲线<spanclass="math inline">\(\displaystyle y = \frac{1}{x} (x &gt;0)\)</span>上的点，<span class="math inline">\(A_1,A_2,\cdots,A_n\)</span>依次为<spanclass="math inline">\(x\)</span>轴上的点，且<spanclass="math inline">\(\triangle OB_1A_1, \triangle A_1B_2A_2, \cdots,\triangle A_{n-1}B_nA_n\)</span>均为等腰直角三角形（其中<spanclass="math inline">\(B_1,B_2,\cdots,B_n\)</span>为直角顶点），设<spanclass="math inline">\(A_n\)</span>的坐标为<spanclass="math inline">\((x_n, 0)\)</span>；<br />（1）求数列<spanclass="math inline">\(\{x_n\}\)</span>的通项公式；<br />（2）设<span class="math inline">\(S_n\)</span>为数列<spanclass="math inline">\(\displaystyle \{ \frac{1}{x_n}\}\)</span>的前<span class="math inline">\(n\)</span>项和，试比较<spanclass="math inline">\(\log_a (S_n + 1)\)</span>与<spanclass="math inline">\(\displaystyle \frac{1}{2} \log_a(n+1)\)</span>的大小，其中<span class="math inline">\(a &gt; 0, a \ne1\)</span>。</p><p>$134. $ 已知等比数列<spanclass="math inline">\(\{a_n\}\)</span>的公比<spanclass="math inline">\(q &gt;1\)</span>，第17项的平方等于第24项，求使<spanclass="math inline">\(\displaystyle a_1 + a_2 + \cdots + a_n &gt;\frac{1}{a_1} + \frac{1}{a_2} + \cdots +\frac{1}{a_n}\)</span>成立的<spanclass="math inline">\(n\)</span>的取值范围。</p><p>$135. $ 已知数列<span class="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和<spanclass="math inline">\(S_n\)</span>满足<spanclass="math inline">\(\displaystyle S_n - S_{n-2} = 3(-\frac{1}{2})^{n-1} (n \ge 3)\)</span>且<spanclass="math inline">\(\displaystyle S_1 = 1, S_2 =-\frac{3}{2}\)</span>，求数列<spanclass="math inline">\(\{a_n\}\)</span>的通项公式。</p><p>$136. $ 函数<span class="math inline">\(f(x) = ax^2 + bx + c (a &gt;0)\)</span>，方程<span class="math inline">\(f(x) =x\)</span>有两个实根<span class="math inline">\(x_1,x_2\)</span>，满足<span class="math inline">\(\displaystyle 0 &lt; x_1&lt; x_2 &lt; \frac{1}{a}\)</span>，当<span class="math inline">\(x \in(0, x_1)\)</span>时，证明<span class="math inline">\(x &lt; f(x) &lt;x_1\)</span>。</p><p>$137. $ 已知函数<span class="math inline">\(f(x) = ax^2 + bx + c (a,b\in \mathbb{R}, a &gt; 0)\)</span>，设方程<spanclass="math inline">\(f(x) = x\)</span>的两个实根<spanclass="math inline">\(x_1, x_2\)</span>；<br />（1）如果<span class="math inline">\(x_1 &lt; 2 &lt; x_2 &lt;4\)</span>，设<span class="math inline">\(f(x)\)</span>的对称轴为<spanclass="math inline">\(x = x_0\)</span>，求证<spanclass="math inline">\(x_0 &gt; -1\)</span>；<br />（2）如果<span class="math inline">\(|x_1| &lt; 2, |x_2 - x_1| =2\)</span>，求<span class="math inline">\(b\)</span>的取值范围。</p><p>$138. $ 设<spanclass="math inline">\(\{a_n\}\)</span>是由正数组成的等比数列，<spanclass="math inline">\(S_n\)</span>是其<spanclass="math inline">\(n\)</span>项和；<br />（1）证明：<span class="math inline">\(\displaystyle \frac{1}{2} (\lgs_n + \lg S_{n+2}) &lt; \lg S_{n+1}\)</span>；<br />（2）是否存在常数<span class="math inline">\(C&gt;0\)</span>，使得<spanclass="math inline">\(\displaystyle \frac{1}{2}[\lg (S_n - C) + \lg(S_{n+2} - C)] = \lg (S_{n+1} - C)\)</span>成立，并证明你的结论。</p><p>$139. $ 已知圆<span class="math inline">\((x - 3)^2 + y^2 =4\)</span>和过原点的直线<span class="math inline">\(y =kx\)</span>的交点为<span class="math inline">\(P,Q\)</span>，则<spanclass="math inline">\(|OP|\cdot |OQ|=\)</span>？</p><p>$140. $ 如图，在四面体<spanclass="math inline">\(ABCD\)</span>中，截面<spanclass="math inline">\(AEF\)</span>经过四面体的内切球的球心<spanclass="math inline">\(O\)</span>，且与<spanclass="math inline">\(BC,DC\)</span>分别交于<spanclass="math inline">\(E,F\)</span>，如该截面将四面体分成体积相等的两部分，设<spanclass="math inline">\(A-BEFD\)</span>与三棱锥<spanclass="math inline">\(A-EFC\)</span>的表面积分别为<spanclass="math inline">\(S_1,S_2\)</span>，则<spanclass="math inline">\(S_1\)</span>与<spanclass="math inline">\(S_2\)</span>的大小关系为？</p><p>$141. $ 证明：过椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2}=1 (a&gt;b&gt;0)\)</span>外一点<spanclass="math inline">\(P\)</span>作其两条切线<spanclass="math inline">\(PA,PB\)</span>，其中<spanclass="math inline">\(A,B\)</span>为切点，点<spanclass="math inline">\(F\)</span>为椭圆的一个焦点，则<spanclass="math inline">\(\angle PFA = \angle PFB\)</span>。</p><p>$142. $ 证明：过抛物线<span class="math inline">\(x^2 = 2py(p&gt;0)\)</span>外一点<spanclass="math inline">\(P\)</span>作其两条切线<spanclass="math inline">\(PA,PB\)</span>，若<spanclass="math inline">\(F\)</span>为抛物线的焦点，则<spanclass="math inline">\(\angle PFA = \angle PFB\)</span>。</p><p>$143. $ 过双曲线<span class="math inline">\(\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1 (a&gt;0,b&gt;0)\)</span>外（两支之间）一点<spanclass="math inline">\(P\)</span>（<spanclass="math inline">\(P\)</span>不在渐近线上）作双曲线的两条切线<spanclass="math inline">\(A,B\)</span>，若<spanclass="math inline">\(F\)</span>为双曲线的一个焦点，证明：<br />（1）若<span class="math inline">\(A,B\)</span>在同一支，则<spanclass="math inline">\(\angle PFA = \angle PFB\)</span>；<br />（2）若<span class="math inline">\(A,B\)</span>不在同一支，则<spanclass="math inline">\(PF\)</span>平分<span class="math inline">\(\angleAFB\)</span>的邻补角。</p><p>$144. $ 在四面体<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AB,AC,AD\)</span>两两垂直，<spanclass="math inline">\(AO \perp\)</span>平面<spanclass="math inline">\(BCD\)</span>，垂足为<spanclass="math inline">\(O\)</span>，则有<spanclass="math inline">\(\displaystyle \frac{1}{AO^2} = \frac{1}{AB^2} +\frac{1}{AC^2} + \frac{1}{AD^2}\)</span>。</p><p>$145. $ 在四面体<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AD \perp\)</span>平面<spanclass="math inline">\(ABC\)</span>，<span class="math inline">\(AO\perp\)</span>平面<span class="math inline">\(BCD\)</span>，垂足为<spanclass="math inline">\(O\)</span>，则有<spanclass="math inline">\(S^2_{\triangle ABC} = S_{\triangle BOC}S_{\triangle BCD}\)</span>。</p><p>$146. $ 点<span class="math inline">\(O\)</span>在<spanclass="math inline">\(\triangle ABC\)</span>内，证明<spanclass="math inline">\(S_{\triangle OBC \cdot \overrightarrow{OA}} +S_{\triangle OAC} \cdot \overrightarrow{OB} + S_{\triangle OAB}\cdot\overrightarrow{OC} = \vec 0\)</span>。</p><p>$147. $ 点<span class="math inline">\(O\)</span>在四面体内，证明<spanclass="math inline">\(V_{O-BCD} \cdot \overrightarrow {OA} + V_{O-ACD}\cdot \overrightarrow{OB} + V_{O-ABD} \cdot \overrightarrow{OC} +V_{O-ABC} \cdot \overrightarrow{OD} = \vec 0\)</span>。</p><p>$148. $ 若<span class="math inline">\(n\)</span>个实数<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>满足<spanclass="math inline">\(a^2_1 + a^2_2 + \cdots + a^2_n =1\)</span>，证明<span class="math inline">\(a_1 + a_2 + \cdots + a_n&lt; \sqrt n\)</span>。</p><p>$149. $ 锐角<span class="math inline">\(\alpha,\beta\)</span>满足<span class="math inline">\(\displaystyle \sin^2\alpha + \sin^2 \beta + \frac{1}{4} = \sin \alpha \sin \beta +\frac{1}{2}(\sin \alpha + \sin \beta)\)</span>，证明<spanclass="math inline">\(\alpha = \beta = 30^\circ\)</span>。</p><p>$150. $ 已知<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(\sin A \sin B \cos C = \sinB \sin C \cos A + \sin A \sin C \cos B\)</span>，令<spanclass="math inline">\(R\)</span>为外切圆半径，<spanclass="math inline">\(S\)</span>为其面积，则<spanclass="math inline">\(\displaystyle y =\frac{RS}{c^3}\)</span>的取值范围是?</p><p>$151. $ 已知函数<span class="math inline">\(\displaystyle f(x) = \lnx - \frac{x}{4} + \frac{3}{4x} - 1, g(x) = x^2 - 2bx +4\)</span>，若对任意<span class="math inline">\(x_1 \in (0,2)\)</span>存在<span class="math inline">\(x_2 \in [1,2]\)</span>使得<span class="math inline">\(f(x_1) \geg(x_2)\)</span>，求实数<spanclass="math inline">\(b\)</span>的取值范围。</p><p>$152. $ 已知函数<span class="math inline">\(\displaystyle f(x) = \lnx - \frac{a}{x}\)</span>，若<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\([1,e]\)</span>上的最小值为<spanclass="math inline">\(\displaystyle \frac{3}{2}\)</span>，求<spanclass="math inline">\(a\)</span>的值。</p><p>$153. $ 已知曲线<span class="math inline">\(C_1: y =x^2\)</span>与曲线<span class="math inline">\(C_2: y = x^2 + 2ax(a&gt;1)\)</span>交于<spanclass="math inline">\(O,A\)</span>两点，直线<spanclass="math inline">\(x = t(0 \le t \le 1)\)</span>与曲线<spanclass="math inline">\(C_1,C_2\)</span>分别交于<spanclass="math inline">\(D, B\)</span>，设<spanclass="math inline">\(S\)</span>为梯形<spanclass="math inline">\(ABOD\)</span>的面积，求<spanclass="math inline">\(S\)</span>的最大值。</p><p>$154. $ 已知<span class="math inline">\(A,B\)</span>分别是直线<spanclass="math inline">\(\displaystyle y = \frac{\sqrt3}{3}x\)</span>与<span class="math inline">\(\displaystyle y =-\frac{\sqrt 3}{3}x\)</span>上两动点，线段<spanclass="math inline">\(AB\)</span>的长为<spanclass="math inline">\(2\sqrt 3\)</span>，<spanclass="math inline">\(P\)</span>是<spanclass="math inline">\(AB\)</span>的中点，设动点<spanclass="math inline">\(P\)</span>的轨迹为<spanclass="math inline">\(C\)</span>，过点<span class="math inline">\(Q(1,0)\)</span>作直线<span class="math inline">\(l\)</span>（与<spanclass="math inline">\(x\)</span>轴不垂直）与轨迹<spanclass="math inline">\(C\)</span>交于<spanclass="math inline">\(M,N\)</span>两点，与<spanclass="math inline">\(y\)</span>轴交于<spanclass="math inline">\(R\)</span>，若<spanclass="math inline">\(\overrightarrow{RM} = \lambda \overrightarrow{MQ},\overrightarrow{RN} = \mu \overrightarrow{NQ}\)</span>，求证<spanclass="math inline">\(\lambda + \mu\)</span>为定值。</p><p>$155. $ 已知<span class="math inline">\(f(x) = x^3 -3x^2\)</span>，设<spanclass="math inline">\(m&gt;1\)</span>，若过点<spanclass="math inline">\((m,n)\)</span>可作函数的三条切线，求证<spanclass="math inline">\(1 - 3m &lt; n &lt; f(m)\)</span>。</p><p>$156. $ 设<span class="math inline">\(f(x) = x(x+1)(x+2)\cdots(x+n)\)</span>，求<spanclass="math inline">\(f^\prime(0)\)</span>的值。</p><p>$157. $ 已知函数在定义域<spanclass="math inline">\(R\)</span>上可导，设点<spanclass="math inline">\(P\)</span>是函数<spanclass="math inline">\(y=f(x)\)</span>的图像上距离原点<spanclass="math inline">\(O\)</span>最近的点；<br />（1）设点<span class="math inline">\(P\)</span>的坐标<spanclass="math inline">\((a,f(a))\)</span>，求证<spanclass="math inline">\(a + f(a)f^\prime(a) = 0\)</span>；<br />（2）若函数<span class="math inline">\(y =f(x)\)</span>的图像不通过坐标原点<spanclass="math inline">\(O\)</span>，证明：直线<spanclass="math inline">\(OP\)</span>与函数<spanclass="math inline">\(y=f(x)\)</span>的图像上过<spanclass="math inline">\(P\)</span>点切线互相垂直。</p><p>$158. $ 设直线<span class="math inline">\(l_1\)</span>与曲线<spanclass="math inline">\(y=\sqrt x\)</span>相切于点<spanclass="math inline">\(P\)</span>，直线<spanclass="math inline">\(l_2\)</span>过点<spanclass="math inline">\(P\)</span>且垂直<spanclass="math inline">\(l_1\)</span>，若<spanclass="math inline">\(l_2\)</span>交<spanclass="math inline">\(x\)</span>轴于点<spanclass="math inline">\(Q\)</span>，又作<span class="math inline">\(PK\perp x\)</span>轴于点<span class="math inline">\(K\)</span>，求证<spanclass="math inline">\(KQ\)</span>的长度为定值。</p><p>$159. $ 设<span class="math inline">\(f(x) = x^2 + bx + c，x \in [-1,1]\)</span>，试证明：当<span class="math inline">\(b &lt;-2\)</span>时，在<spanclass="math inline">\([-1,1]\)</span>上总存在一个<spanclass="math inline">\(x\)</span>使得<span class="math inline">\(|f(x)|\ge |b|\)</span>。</p><p>$160. $ 已知<span class="math inline">\(f(x) =x(x-1)(x-a)，(a&gt;1)\)</span>的两个极值点<spanclass="math inline">\(x_1,x_2\)</span>，如果<spanclass="math inline">\(f(x_1) + f(x_2) \le 0\)</span>恒成立，求<spanclass="math inline">\(a\)</span>的最小值。</p><p>$161. $ 已知<span class="math inline">\(a&gt;0\)</span>且<spanclass="math inline">\(a \ne 1\)</span>，<spanclass="math inline">\(f(x)\)</span>是奇函数，<spanclass="math inline">\(\displaystyle \varphi(x) = (a-1)f(x)\left(\frac{1}{a^x-1} + \frac{1}{2} \right)\)</span>；<br />（1）判断<span class="math inline">\(\varphi(x)\)</span>的奇偶性；<br />（2）证明：若<span class="math inline">\(xf(x)&gt;0\)</span>，则<spanclass="math inline">\(\varphi(x) &gt; 0\)</span>。</p><p>$162. $ 设<span class="math inline">\(x_1,x_2\)</span>是函数<spanclass="math inline">\(f(x) = e^x\)</span>定义域内的两个变量且<spanclass="math inline">\(x_1 &lt; x_2\)</span>，若<spanclass="math inline">\(\displaystyle x_0 = \frac{1}{2}(x_1 +x_2)\)</span>，那么<span class="math inline">\(|f(x_0) -f(x_1)|\)</span>与<span class="math inline">\(|f(x_2) -f(x_0)|\)</span>的大小关系为？</p><p>$163. $ 已知函数<span class="math inline">\(f(x) = \lg (a^x -kb^x)\)</span>的定义域是<span class="math inline">\((0, +\infty), (k \in\mathbb{N^+}, 0&lt;b&lt;1&lt;a)\)</span>，是否存在这样的<spanclass="math inline">\(a\)</span>与<spanclass="math inline">\(b\)</span>使<spanclass="math inline">\(f(x)\)</span>在<span class="math inline">\((1,+\infty)\)</span>上的值域为<span class="math inline">\((0,+\infty)\)</span>且<span class="math inline">\(f(3) = \lg4\)</span>？若存在求出<span class="math inline">\(a\)</span>与<spanclass="math inline">\(b\)</span>的值，若不存在，请说明理由。</p><p>$164. $ 证明：两个既约分数的和与积不能同时为整数。</p><p>$165. $ 证明：<span class="math inline">\(\displaystyle \frac{1}{2}\times \frac{3}{4} \times \frac{5}{6} \times \cdots \frac{2n-1}{2n} &lt;\frac{\sqrt{2n+1}}{2n+1} (n \in \mathbb{N^+})\)</span>。</p><p>$166. $ 已知<span class="math inline">\(a, b \in\mathbb{R}^*\)</span>，集合<span class="math inline">\(A = \{x \mid|x+1| &lt; a, x \in \mathbb{R}\}，B = \{ x \mid |x-2| &gt; b, x \in\mathbb{R}\}\)</span>，且<span class="math inline">\(A \subseteqB\)</span>，则<span class="math inline">\(a+b\)</span>的最大值为？</p><p>$167. $ 椭圆<span class="math inline">\(\displaystyle \frac{x^2}{9} +\frac{y^2}{4} = 1\)</span>上到直线<span class="math inline">\(2x + 3y +1 = 0\)</span>的距离等于<span class="math inline">\(\displaystyle\frac{\sqrt 3 + 1}{2}\)</span>的点的个数为？</p><p>$168. $ 直线<span class="math inline">\(MN\)</span>过<spanclass="math inline">\(\triangle ABC\)</span>的重心<spanclass="math inline">\(G\)</span>，且<spanclass="math inline">\(\overrightarrow AM = m \overrightarrow AB,\overrightarrow AN = n \overrightarrow AC\)</span>（其中<spanclass="math inline">\(m&gt;0,n&gt;0\)</span>），则<spanclass="math inline">\(mn\)</span>的最小值为？</p><p>$169. $ 已知四面体<span class="math inline">\(ABCD\)</span>，<spanclass="math inline">\(AB=AC=AD=BC=1, CD = \sqrt2\)</span>，则该四面体的内切球半径为？</p><p>$170. $ 从直线<span class="math inline">\(\displaystyle l:\frac{x}{8} + \frac{y}{4} = 1\)</span>上的任意一点<spanclass="math inline">\(P\)</span>作圆<span class="math inline">\(O: x^2 +y^2 = 8\)</span>的两条切线，切点为<spanclass="math inline">\(A,B\)</span>，则弦<spanclass="math inline">\(AB\)</span>的最小值为？</p><p>$171. $ 在半径为<spanclass="math inline">\(1\)</span>的大球内放入<spanclass="math inline">\(6\)</span>个半径相同的小球，当小球的体积最大时，小球的半径为？此时在6个小球之间的空隙里还可以放入一个小球，该小球的最大半径为？</p><p>$172. $ 关于<span class="math inline">\(x\)</span>的不等式<spanclass="math inline">\(\displaystyle \frac{mx+1}{2x^2+ax-1} \gen\)</span>（<spanclass="math inline">\(m,a,n\)</span>是实数）的解集为<spanclass="math inline">\(\displaystyle [-2, -1) \cup (\frac{1}{2},1]\)</span>，则<span class="math inline">\(a=?,m=?\)</span></p><p>$173. $ 若不等式<span class="math inline">\(\displaystyle (-1)^n a&lt; 2 + \frac{(-1)^{n+1}}{n}\)</span>对任意正整数<spanclass="math inline">\(n\)</span>恒成立，则实数<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$174. $ <spanclass="math inline">\(a,b,c\)</span>为互不相等的正数且<spanclass="math inline">\(abc=1\)</span>，求证：<spanclass="math inline">\(\displaystyle \frac{1}{a} + \frac{1}{b} +\frac{1}{c} &gt; \sqrt a + \sqrt b + \sqrt c\)</span>。</p><p>$175. $ 在<span class="math inline">\(\triangleABC\)</span>中，求证：<span class="math inline">\(\displaystyle \sin^2A+ \sin^2B + \sin^2C \le \frac{4}{9}\)</span>。</p><p>$176. $ 已知函数<span class="math inline">\(f(x) = x^3 - x +c\)</span>定义在区间<span class="math inline">\([0, 1]\)</span>上，<spanclass="math inline">\(x_1,x_2 \in [0, 1]\)</span>且<spanclass="math inline">\(x_1 \ne x_2\)</span>，求证：<br />（1）<span class="math inline">\(|f(x_2) - f(x_1)| &lt; 2|x_1 -x_2|\)</span>；<br />（2）<span class="math inline">\(|f(x_2) - f(x_1)| &lt; 1\)</span>。</p><p>$177. $ 已知<span class="math inline">\(a,b,c \in\mathbb{R}\)</span>，且<span class="math inline">\(ab + bc + ac =1\)</span>，求证：<br />（1）<span class="math inline">\(a + b + c \ge \sqrt 3\)</span>；<br />（2）<span class="math inline">\(\displaystyle \sqrt {\frac{a}{bc}} +\sqrt {\frac{b}{ac}} + \sqrt {\frac{c}{ab}} \ge \sqrt 3 (\sqrt a + \sqrtb + \sqrt c)\)</span>。</p><p>$178. $ 已知<spanclass="math inline">\(a&gt;b&gt;0\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{(a-b)^2}{8a} &lt;\frac{a+b}{2} - \sqrt {ab} &lt; \frac{(a-b)^2}{8b}\)</span>。</p><p>$179. $ 在<span class="math inline">\(\triangleABC\)</span>中，若<span class="math inline">\(\angle A: \angle B: \angleC = 4:2:1\)</span>，<spanclass="math inline">\(a,b,c\)</span>分别为<spanclass="math inline">\(\angle A, \angle B, \angleC\)</span>的对边，求证：<span class="math inline">\(\displaystyle\frac{1}{a} + \frac{1}{b} = \frac{1}{c}\)</span>。</p><p>$180. $ 设<span class="math inline">\(a,b,c\)</span>均为大于<spanclass="math inline">\(1\)</span>的正数，且<span class="math inline">\(ab= 10\)</span>，求证<span class="math inline">\(\log_a c + \log_b c \ge 4\lg c\)</span>。</p><p>$181. $ 已知函数<span class="math inline">\(f(x) = - x^3 + ax^2 +b(a, b \in \mathbb{R})\)</span>，记在<spanclass="math inline">\(f(x)\)</span>图像上任意一点处的切线斜率为<spanclass="math inline">\(k\)</span>，当<span class="math inline">\(x \in[0, 1]\)</span>,有<span class="math inline">\(|k| \le1\)</span>，求<span class="math inline">\(a\)</span>的取值范围。</p><p>$182. $ 已知<span class="math inline">\(f(x) = \ln (1 + x) - x, g(x)= x \ln x\)</span>。设<span class="math inline">\(0 &lt; a &lt;b\)</span>，证明：<span class="math inline">\(\displaystyle 0 &lt; g(a)+ g(b) - 2g\left( \frac{a+b}{2} \right) &lt; (b - a) \ln2\)</span>。</p><p>$183. $ 设<span class="math inline">\(z\)</span>为虚数，<spanclass="math inline">\(\displaystyle w = z +\frac{1}{z}\)</span>是实数且<span class="math inline">\(-1 &lt; w &lt;2\)</span>，<span class="math inline">\(\displaystyle u =\frac{1-z}{1+z}\)</span>，求<span class="math inline">\(w -u^2\)</span>的最小值。</p><p>$184. $ 证明：首项系数为<spanclass="math inline">\(1\)</span>的整系数多项式的有理根必是整数。</p><p>$185. $ 设在<span class="math inline">\(\triangleABC\)</span>中有<span class="math inline">\(\cos^2 A + \cos^2 B + \cos^2C &lt; 1\)</span>，证明<span class="math inline">\(\triangleABC\)</span>是锐角三角形。</p><p>$186. $ <span class="math inline">\(\displaystyle f(x) = x +\frac{x}{x-1}\)</span>，证明：曲线<spanclass="math inline">\(y=f(x)\)</span>上任一点的切线与直线<spanclass="math inline">\(x=1\)</span>和直线<spanclass="math inline">\(y=x\)</span>所围成的三角形的面积为定值。</p><p>$187. $ 已知<span class="math inline">\(A,B,C\)</span>是直线<spanclass="math inline">\(l\)</span>上的点，向量<spanclass="math inline">\(\overrightarrow{OA}, \overrightarrow{OB},\overrightarrow{OC}\)</span>及函数<spanclass="math inline">\(f(x)\)</span>满足：<spanclass="math inline">\(\displaystyle \overrightarrow{OA} - \left[ f(x) -f^\prime(\frac{1}{2})\right]\overrightarrow{OB} + x^2\overrightarrow{OC} = \vec 0\)</span>。<br />（1）求函数<span class="math inline">\(f(x)\)</span>的表达式；<br />（2）设<span class="math inline">\(a&gt;0, g(x) = ax + 5 -2a\)</span>，若对任意<span class="math inline">\(x_0 \in[0,1]\)</span>，总存在<span class="math inline">\(x_1 \in [0,1]\)</span>使<span class="math inline">\(f(x_0) =g(x_1)\)</span>成立，求实数<spanclass="math inline">\(a\)</span>的取值范围。</p><p>$188. $ 已知<span class="math inline">\(f(x) = (x^2 + bx +c)e^x\)</span>，其中<span class="math inline">\(b,c \in\mathbb{R}\)</span>为常数；<br />（1）若<span class="math inline">\(b^2 &gt;4(c-1)\)</span>，讨论函数<spanclass="math inline">\(f(x)\)</span>的单调性；<br />（2）若<span class="math inline">\(b^2 \le 4(c-1)\)</span>，且<spanclass="math inline">\(\displaystyle \lim \limits_{x\to 0} \frac{f(x) -c}{x} = 4\)</span>，求<spanclass="math inline">\(b\)</span>的取值范围。</p><p>$189. $ 已知<span class="math inline">\(f(x) = \lnx\)</span>，当<span class="math inline">\(0 &lt; a &lt;b\)</span>时，求证<span class="math inline">\(\displaystyle f(b) - f(a)&gt; \frac{2a (b-a)}{a^2 + b^2}\)</span>。</p><p>$190. $ 已知<spanclass="math inline">\(i,m,n\)</span>是正整数，且<spanclass="math inline">\(1 &lt; i \le m \le n\)</span>，证明<spanclass="math inline">\(n^i A_m^i &lt; m^i A_n^i\)</span>。</p><p>$191. $ 设关于<span class="math inline">\(x\)</span>的方程<spanclass="math inline">\(2x^2 - ax - 2 = 0\)</span>的两根为<spanclass="math inline">\(\alpha, \beta (\alpha &lt;\beta)\)</span>，函数<span class="math inline">\(\displaystyle f(x) =\frac{4x - n}{x^2 + 1}\)</span>；<br />（1）证明：<span class="math inline">\(f(x)\)</span>是<spanclass="math inline">\([\alpha, \beta]\)</span>上的增函数；<br />（2）当<span class="math inline">\(a\)</span>为何值时，<spanclass="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\([\alpha,\beta]\)</span>上的最大值与最小值之差最小？</p><p>$192. $ 已知关于<span class="math inline">\(x\)</span>的方程<spanclass="math inline">\(x^2 - (6 + i)x + 9 + ai = 0 (a \in\mathbb{R})\)</span>有实根<span class="math inline">\(b\)</span>；<br />（1）求<span class="math inline">\(a,b\)</span>的值；<br />（2）若复数<span class="math inline">\(z\)</span>满足<spanclass="math inline">\(|\bar z - a - bi| - 2|z| = 0\)</span>，求<spanclass="math inline">\(z\)</span>为何值时，<spanclass="math inline">\(|z|\)</span>有最小值，并求出<spanclass="math inline">\(|z|\)</span>的值。</p><p>$193. $ 对于<spanclass="math inline">\(\mathbb{R}\)</span>上可导的任意函数<spanclass="math inline">\(f(x)\)</span>，若满足<spanclass="math inline">\((x-1)f^\prime(x) \ge 0\)</span>，则<spanclass="math inline">\(f(0) + f(2)\)</span>与<spanclass="math inline">\(2f(1)\)</span>的大小关系是？</p><p>$194. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{9} + \frac{y^2}{4} = 1\)</span>，<spanclass="math inline">\(AA^\prime\)</span>是椭圆的长轴，<spanclass="math inline">\(P(x_1,y_1)\)</span>是椭圆上异于<spanclass="math inline">\(A,A^\prime\)</span>的任意一点，过点<spanclass="math inline">\(P\)</span>斜率为<spanclass="math inline">\(\displaystyle -\frac{4x_1}{9y_1}\)</span>的直线<spanclass="math inline">\(l\)</span>，若直线<spanclass="math inline">\(l\)</span>上的两点<spanclass="math inline">\(M,M^\prime\)</span>在<spanclass="math inline">\(x\)</span>轴上的射影分别为<spanclass="math inline">\(A,A^\prime\)</span>，证明：<br />（1）<span class="math inline">\(|AM| \cdot |A^\primeM^\prime|\)</span>为定值；<br />（2）求由<span class="math inline">\(A,A^\prime, M^\prime,M\)</span>四点构成的四边形的面积的最小值。</p><p>$195. $ 过双曲线<span class="math inline">\(\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1(a&gt;b&gt;0)\)</span>的右焦点<spanclass="math inline">\(F(c,0)\)</span>的直线交双曲线于<spanclass="math inline">\(M,N\)</span>两点，交<spanclass="math inline">\(y\)</span>轴于点<spanclass="math inline">\(P\)</span>，点<spanclass="math inline">\(M,N\)</span>分<spanclass="math inline">\(\overrightarrow{PF}\)</span>所成的比例分别为<spanclass="math inline">\(\lambda_1, \lambda_2\)</span>，求证<spanclass="math inline">\(\lambda_1 + \lambda_2\)</span>为定值。</p><p>$196. $ 求证<span class="math inline">\(a^2 + b^2 + 3 \ge ab + \sqrt3 (a+b)\)</span>。</p><p>$197. $ 若<span class="math inline">\(\displaystyle |x - a| +\frac{1}{x} \ge \frac{1}{2}\)</span>对任意<spanclass="math inline">\(x&gt;0\)</span>恒成立，则<spanclass="math inline">\(a\)</span>的取值范围是？</p><p>$198. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB = 4, AC = 3\)</span>，<spanclass="math inline">\(G\)</span>为外心，则<spanclass="math inline">\(\overrightarrow{AG} \cdot\overrightarrow{BC}=\)</span>？</p><p>$199. $ 已知<span class="math inline">\(\displaystyle (2x + 1)^10 =a_0 + a_1(x+1) + \frac{a_2}{2}(x+1)^2 + \cdots +\frac{a_10}{10}(x+1)^10\)</span>，则<span class="math inline">\(a_1 +a_2 + \cdots + a_10=\)</span>?</p><p>$200. $ 已知<span class="math inline">\(\displaystyle f(x) =\frac{(x+1)[1 + \ln (x+1)]}{x}\)</span>，<spanclass="math inline">\(g(x) = x^2 f^\prime(x) (x &gt; 0)\)</span>；<br />（1）若存在唯一的实数<span class="math inline">\(a \in (m,m+1)\)</span>，使得<span class="math inline">\(g(a) =0\)</span>成立，求正整数<spanclass="math inline">\(m\)</span>的值；<br />（2）若<span class="math inline">\(x &gt; 0\)</span>时，<spanclass="math inline">\(f(x) &gt; n\)</span>恒成立，求正整数<spanclass="math inline">\(n\)</span>的最大值。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题：自创篇</title>
      <link href="/2022/02/22/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%98/"/>
      <url>/2022/02/22/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>$1. $ 递增等比数列<spanclass="math inline">\(\{a_n\}\)</span>，有<spanclass="math inline">\(a_1^2+a_2^2+a_3^2 = 8, a_1 + a_2 + a_3 =4\)</span>，则该数列的公比为？</p><p>$2. $ 已知<span class="math inline">\(\displaystyle -\frac{\pi}{2}\le \beta &lt; \alpha &lt; \gamma \le \frac{\pi}{2}\)</span>，且<spanclass="math inline">\(\displaystyle \tan (\alpha + \beta) = \frac{\sin2\alpha - 1}{\cos 2\alpha}, \tan(\alpha + \gamma) = \frac{\sin2\alpha}{\cos 2\alpha + 1}\)</span>，则<span class="math inline">\(\tan(\beta + \gamma)=\)</span>？</p><p>$3. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB = 3, AC = 4\)</span>，<spanclass="math inline">\(O\)</span>外心，<spanclass="math inline">\(G\)</span>为重心，则<spanclass="math inline">\(|\overrightarrow{GC}|^2 + \overrightarrow{OG}\cdot \overrightarrow{BC} - |\overrightarrow{GB}|^2=\)</span>？</p><span id="more"></span><p>$4. $ <span class="math inline">\(a,b,c\)</span>为三角形<spanclass="math inline">\(ABC\)</span>的三边长，满足<spanclass="math inline">\(a \le b \le c\)</span>，令<spanclass="math inline">\(R,r\)</span>分别是该三角形的外切圆半径和内切圆半径，则“三角形<spanclass="math inline">\(ABC\)</span>是直角三角形“是“<spanclass="math inline">\(a, R+r,b\)</span>按顺序成等差数列”的什么条件？</p><p>$5. $ 如图所示，<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(D,E\)</span>分别在边<spanclass="math inline">\(AB,AC\)</span>上，且<spanclass="math inline">\(\displaystyle \frac{AD}{DB} = k_1, \displaystyle\frac{AE}{EC}=k_2\)</span>，线段<spanclass="math inline">\(CD\)</span>与<spanclass="math inline">\(BE\)</span>交于点<spanclass="math inline">\(O\)</span>，作<spanclass="math inline">\(AO\)</span>的延长线交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(F\)</span>，则<spanclass="math inline">\(\displaystyle \frac{BF}{CF}=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.406uas3gfp40.webp" width="25%"></p><p>$6. $ 如图所示，在<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(AD\)</span>为<spanclass="math inline">\(\angle BAC\)</span>的角平分线且交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，<br />（1）当<span class="math inline">\(\angle A =90^\circ\)</span>时，记该三角形面积，内切圆面积，外切圆面积分别为<spanclass="math inline">\(S, S_{内}, S_{外}\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{S_{内} + S_{外}}{3} &gt;S\)</span>；<br />（2）求证：<span class="math inline">\(AD^2 = AB \cdot AC - BD \cdotDC\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.1b45nqzze7y8.webp" width="30%"></p><p>$7. $ 已知在<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(a,b,c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，<spanclass="math inline">\(h\)</span>为最长边<spanclass="math inline">\(c\)</span>上的高，且<spanclass="math inline">\(\displaystyle \frac{1}{h}, \frac{1}{a},\frac{1}{b}\)</span>成等差数列，记<span class="math inline">\(\lambda =9 \cos B \sin 2B\)</span>；<br />（1）求<span class="math inline">\(2\sin B - \sin A\)</span>的值；<br />（2）是否存在正整数对<span class="math inline">\(p,q\)</span>，使得<spanclass="math inline">\(p &lt; \lambda &lt;q\)</span>恒成立？若存在，求出<span class="math inline">\(q -p\)</span>的最小值；反之，请说明理由。</p><p>$8. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(a, b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，且<spanclass="math inline">\((a+b)\cos \alpha = c\)</span>，其中<spanclass="math inline">\(\alpha\)</span>为实数；<br />（1）若<span class="math inline">\(\angle C = 90^\circ\)</span>，求<spanclass="math inline">\(\alpha\)</span>的取值范围；<br />（2）若<span class="math inline">\(\sin C \cos \alpha = \sinB\)</span>，求证<span class="math inline">\(2a &lt; 3c &lt;6b\)</span>。</p><p>$9. $ 在平面直角坐标系<spanclass="math inline">\(xOy\)</span>中，有两点<spanclass="math inline">\(A,B\)</span>，已知点<spanclass="math inline">\(P\)</span>到点<spanclass="math inline">\(A,B\)</span>之间的距离之比<spanclass="math inline">\(\displaystyle \lambda =\frac{|PA|}{|PB|}\)</span>，<spanclass="math inline">\(\lambda\)</span>为定值，且<spanclass="math inline">\(\lambda &gt; 1\)</span>；<br />（1）证明点<span class="math inline">\(P\)</span>的轨迹形状为圆；<br />（2）记（1）中的圆的圆心为<spanclass="math inline">\(C\)</span>，且<span class="math inline">\(|CP| \ge|AB|\)</span>对任意点<spanclass="math inline">\(P\)</span>恒成立，求<spanclass="math inline">\(\lambda\)</span>的取值范围。</p><p>$10. $ 已知函数<span class="math inline">\(\displaystyle f(x) = x -\frac{1}{2^x + 1}\)</span>；<br />（1）证明函数<spanclass="math inline">\(f(x)\)</span>的零点唯一，且零点<spanclass="math inline">\(x_0 \in (-1, 1)\)</span>；<br />（2）令<span class="math inline">\(x_1 = -1, x_2 =1\)</span>，记函数<span class="math inline">\(f(x)\)</span>与<spanclass="math inline">\(x\)</span>轴，<span class="math inline">\(x=x_1,x=x_2\)</span>构成的面积分别为<span class="math inline">\(S_1,S_2\)</span>，问<span class="math inline">\(S_1\)</span>和<spanclass="math inline">\(S_2\)</span>的大小关系，相差多少，试证之。</p><p>$11. $ 数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(a_1=2\)</span>，且<spanclass="math inline">\(\displaystyle \frac{a_{n+1}}{n} = \frac{2a_n}{n+1}\)</span>；<br />（1）求<span class="math inline">\(\{a_n\}\)</span>的通项公式；<br />（2）记数列<span class="math inline">\(\{a_n\}\)</span>的前<spanclass="math inline">\(n\)</span>项和为<spanclass="math inline">\(S_n\)</span>，<spanclass="math inline">\(\displaystyle \{ \frac{2^n}{n^2}\}\)</span>的前<span class="math inline">\(n\)</span>项和为<spanclass="math inline">\(T_n\)</span>，求证<spanclass="math inline">\(\displaystyle a_n \le 2 + \frac{S_n -T_n}{2}\)</span>。</p><p>$12. $ 如图所示，已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2} = 1(a&gt;b&gt;0)\)</span>上存在过其左焦点的一条直线<spanclass="math inline">\(l\)</span>与椭圆交于<spanclass="math inline">\(A,B\)</span>两点，坐标原点<spanclass="math inline">\(O\)</span>关于直线<spanclass="math inline">\(l\)</span>的对称点为<spanclass="math inline">\(D\)</span>，使得<spanclass="math inline">\(O,A,B,D\)</span>四点共圆，求椭圆的离心率<spanclass="math inline">\(e\)</span>的取值范围。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.3tpkw8c6er60.webp" width="35%"></p><p>$13. $证明过抛物线准线上的任意一点作抛物线的两条切线，则两个切点和抛物线的焦点共线。类似的，探讨椭圆和双曲线是否具有相似的性质？</p><p>$14. $ 如图所示，已知椭圆<span class="math inline">\(\displaystyle G:\frac{x^2}{a^2} + \frac{y^2}{b^2}=1 (a&gt;b&gt;0)\)</span>，抛物线<spanclass="math inline">\(C: y = x^2 - b^2\)</span>，若椭圆<spanclass="math inline">\(G\)</span>与抛物线<spanclass="math inline">\(C\)</span>的其中一个交点<spanclass="math inline">\((x_0,y_0)\)</span>到点<spanclass="math inline">\(\displaystyle (0, \frac{1}{4} -b^2)\)</span>的距离为<span class="math inline">\(\displaystyle\frac{23}{12}\)</span>，且椭圆<spanclass="math inline">\(G\)</span>的离心率为<spanclass="math inline">\(\displaystyle \frac{\sqrt 6}{3}\)</span>；<br />（1）求<span class="math inline">\(y_0\)</span>的值；<br />（2）若直线<span class="math inline">\(\displaystyle l: y = \frac{\sqrt3}{3}x + m\)</span>与可行域<span class="math inline">\(\left \{\begin{aligned} &amp;y \le x^2 - b^2 \\&amp; \frac{x^2}{a^2} +\frac{y^2}{b^2} &lt;= 1\end{aligned}\right.\)</span>的边界交于不同的四点，从左到右依次记为<spanclass="math inline">\(A,B,C,D\)</span>，问是否存在这样的直线<spanclass="math inline">\(l\)</span>使得<span class="math inline">\(|AB|,|BC|, |CD|\)</span>成等差数列？并说明理由。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.44jznavny4q0.webp" width="35%"></p><p>$15. $ 已知在<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(a,b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，数列<spanclass="math inline">\(A: \{a^2,b^2,c^2\}\)</span>，数列<spanclass="math inline">\(B: \{ \cot A, \cot B, \cot C \}\)</span>；<br />（1）若数列<span class="math inline">\(A\)</span>的项和与数列<spanclass="math inline">\(B\)</span>的项和相等，求三角形<spanclass="math inline">\(ABC\)</span>的面积；<br />（2）证明数列<spanclass="math inline">\(A\)</span>成等差数列的充要条件是数列<spanclass="math inline">\(B\)</span>成等差数列。</p><p>$16. $ 数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(\displaystyle a_{n+1} = \frac{1}{a - a_n}(n,a \in\mathbb{N^+}, a \ge 2)\)</span>，<spanclass="math inline">\(a_1=0\)</span>；<br />（1）若<span class="math inline">\(a=2\)</span>；<br />（i）求<span class="math inline">\(\lim \limits_{n \to + \infty}a_n\)</span>；<br />（ii）令<span class="math inline">\(\displaystyle b_n = a_n +\frac{1}{a_n} (n \ge 2)\)</span>，求<span class="math inline">\(b_2 +b_3 + \cdots + b_n\)</span>的值。<br />（2）求证对任意的<span class="math inline">\(n \ge 2\)</span>，都有<spanclass="math inline">\(0 \le a_n &lt; a_{n+1} &lt;\frac{1}{a-1}\)</span>；<br />（3）令<span class="math inline">\(S_n = \dfrac{1}{n-1}\sum\limits_{k=1}^n a_n (n \ge 2)\)</span>，求证：<spanclass="math inline">\(\displaystyle S_n \ge (a_n^2 - aa_n +1)^{\frac{1}{2(n-1)}} (n \ge 2)\)</span>。</p><p>$17. $ 在椭圆上有一点<span class="math inline">\(M\)</span>，记<spanclass="math inline">\(M\)</span>在椭圆上的切线为<spanclass="math inline">\(l_1\)</span>，过原点<spanclass="math inline">\(O\)</span>做一直线<spanclass="math inline">\(l_2\)</span>使得<span class="math inline">\(l_1\perp l_2\)</span>，记<spanclass="math inline">\(OM\)</span>所在直线为<spanclass="math inline">\(l_3\)</span>，求<spanclass="math inline">\(l_2\)</span>与<spanclass="math inline">\(l_3\)</span>的夹角<spanclass="math inline">\(\alpha\)</span>的取值范围。</p><p>$18. $ 已知在<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(a,b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，<spanclass="math inline">\(b \sin A + a \sin B = 3, \angle C =60^\circ\)</span>，求边长<spanclass="math inline">\(c\)</span>的取值范围。</p><p>$19. $ 已知在<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(a,b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，且<spanclass="math inline">\(\displaystyle \cos A =\frac{a}{b}\)</span>；<br />（1）若<span class="math inline">\(\displaystyle \frac{c}{a} = 1, b =2\)</span>，求三角形的面积；<br />（2）若<span class="math inline">\(\triangleABC\)</span>为锐角三角形，求<span class="math inline">\(\displaystyle\frac{c}{a}\)</span>的取值范围。</p><p>$20. $ 设三角形的周长为<spanclass="math inline">\(l\)</span>，外切圆和内切圆的半径分别为<spanclass="math inline">\(R,r\)</span>，求<spanclass="math inline">\(\displaystyle\frac{Rr}{l^2}\)</span>的最大值。</p><p>$21. $ 如图所示，已知抛物线<span class="math inline">\(C: y^2 = 2px(p&gt;0)\)</span>的焦点为<spanclass="math inline">\(F\)</span>，准线与<spanclass="math inline">\(x\)</span>轴的交点为<spanclass="math inline">\(K\)</span>，过点<spanclass="math inline">\(F\)</span>作一动直线<spanclass="math inline">\(l\)</span>与抛物线交于<spanclass="math inline">\(A,B\)</span>两点，当直线<spanclass="math inline">\(l\)</span>的倾斜角为<spanclass="math inline">\(30^\circ\)</span>时，<spanclass="math inline">\(\triangle ABK\)</span>的面积为<spanclass="math inline">\(8\)</span>；<br />（1）求抛物线<span class="math inline">\(C\)</span>的方程；<br />（2）记<span class="math inline">\(\triangleABK\)</span>的内切圆半径为<spanclass="math inline">\(r\)</span>，求<spanclass="math inline">\(r\)</span>的取值范围。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.4q8wp1w8a9a0.webp" width="30%"></p><p>$22. $ （1）已知<span class="math inline">\(-c \le x, y \lec\)</span>（<span class="math inline">\(c\)</span>为正常实数）,求证<spanclass="math inline">\(\displaystyle x + y \le c +\frac{xy}{c^2}\)</span>；<br />（2）已知<span class="math inline">\(-1 \le m, n \le 1\)</span>，求<spanclass="math inline">\(\displaystyle (1+m)(1+n)(1 - \frac{m + n}{1 +mn})\)</span>的取值范围。<br />（3）<spanclass="math inline">\(a,b,c\)</span>是一个三角形的三边长，求<spanclass="math inline">\(\displaystyle(\frac{a+b}{c}-1)(\frac{a+c}{b}-1)(\frac{b+c}{a}-1)\)</span>的取值范围。</p><p>$23. $ 如图所示，抛物线<span class="math inline">\(y^2 = 4(x+1) (x\le 0)\)</span>的一部分与其关于<spanclass="math inline">\(y\)</span>轴对称的曲线合成的曲线称为“类椭圆”，设<spanclass="math inline">\(F_1(0, \sqrt 3), F_2(0, -\sqrt 3)\)</span>；<br />（1）若<spanclass="math inline">\(P\)</span>为该“类椭圆”上一点，试证明<spanclass="math inline">\(|PF_1| + |PF_2| \le 4\)</span>；<br />（2）过点<span class="math inline">\(D(2,0)\)</span>的直线与“类椭圆”交于<spanclass="math inline">\(A,B\)</span>两点，若<spanclass="math inline">\(\overrightarrow {DB} = \lambda \overrightarrow{DA}\)</span>，求<spanclass="math inline">\(\lambda\)</span>的取值范围；<br />（3）过“类椭圆”内任意一点作相互垂直的两条直线<spanclass="math inline">\(l_1, l_2\)</span>分别交“类椭圆”于<spanclass="math inline">\(M,N\)</span>和<spanclass="math inline">\(S,T\)</span>四点，求四边形<spanclass="math inline">\(MSNT\)</span>的最大值。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题自创/xxx.6nl2ho4vikw0.webp" width="35%"></p><p>$24. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(a, b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，<spanclass="math inline">\(h\)</span>为边<spanclass="math inline">\(c\)</span>上的高，<spanclass="math inline">\(p\)</span>为<span class="math inline">\(\triangleABC\)</span>的半周长，已知<span class="math inline">\(a &lt; b &lt;c\)</span>，且<span class="math inline">\(\displaystyle \frac{1}{a},\frac {1}{b}, \frac{1}{h},\frac{1}{p}\)</span>按某种次序成等差数列，并记该数列为<spanclass="math inline">\(K_4\)</span>；<br />（1）试写出所有可能排列的<spanclass="math inline">\(K_4\)</span>，并说明理由；<br />（2）求<span class="math inline">\(a:b:c\)</span>。</p><p>$25. $ 记平面内三角形全体构成的集合为<spanclass="math inline">\(\Delta\)</span>，任取三角形<spanclass="math inline">\(\delta\)</span>，记<spanclass="math inline">\(R_\delta,r_\delta\)</span>分别为该三角形的外切圆和内切圆半径，<spanclass="math inline">\(\displaystyle t_\delta =\frac{r_\delta}{R_\delta}\)</span>；<br />（1）求<span class="math inline">\(S = \{t_\delta | \delta \in\Delta\}\)</span>；<br />（2）求<span class="math inline">\(T = \{t \big| \exists A_t, \forall\delta \in A_t, t_\delta = t\)</span>,其中<spanclass="math inline">\(A_t\)</span>为无穷多个互不相似的三角形构成的集合<spanclass="math inline">\(\}\)</span>。</p><p>$26. <span class="math inline">\(（1）在三角形\)</span>ABC<spanclass="math inline">\(的边\)</span>BC<spanclass="math inline">\(上任取一个不与\)</span>B,C<spanclass="math inline">\(重合的点\)</span>D<spanclass="math inline">\(，记\)</span>ABC, ABD, ADC<spanclass="math inline">\(的内切圆半径分别为\)</span>r,r_1,r_2<spanclass="math inline">\(，\)</span>ABC, ABD, ADC<spanclass="math inline">\(的外切圆半径分别为\)</span>R,R_1,R_2<spanclass="math inline">\(，求\)</span><spanclass="math inline">\(以及\)</span><spanclass="math inline">\(的取值范围。 （2）在三角形\)</span>AD_0D<spanclass="math inline">\(的边\)</span>D_0D<spanclass="math inline">\(上任取\)</span>n<spanclass="math inline">\(个点\)</span>D_1,D_2,,D_n<spanclass="math inline">\(，这时不妨记\)</span>D<spanclass="math inline">\(为\)</span>D_{n+1}<spanclass="math inline">\(，并满足\)</span>D_0D_{i+1} &gt; D_0D_i (i=0, 1, ,n)<span class="math inline">\(，记\)</span>AD_iD_{i+1}<spanclass="math inline">\(的内切圆半径与外切圆半径分别为\)</span>r_i,R_i<span class="math inline">\(，并记\)</span>AD_0D_{n+1}<spanclass="math inline">\(的内切圆半径与外切圆半径分别为\)</span>r,R<spanclass="math inline">\(，求\)</span><spanclass="math inline">\(与\)</span><spanclass="math inline">\(的取值范围，其中\)</span>i=0,1,,n$。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解30：串联所有单词的子串</title>
      <link href="/2022/01/25/leetcode%E9%A2%98%E8%A7%A330/"/>
      <url>/2022/01/25/leetcode%E9%A2%98%E8%A7%A330/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words">力扣第30题</a></p><p>给定一个字符串<code>s</code>和一些长度相同的单词<code>words</code>。找出<code>s</code>中恰好可以由<code>words</code>中所有单词串联形成的子串的起始位置。</p><p>注意子串要与<code>words</code>中的单词完全匹配，中间不能有其他字符，但不需要考虑<code>words</code>中单词串联的顺序。</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入：s = "barfoothefoobarman", words = ["foo","bar"]<br />输出：[0,9]<br />解释：<br />从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。<br />输出的顺序不重要, [9,0] 也是有效答案。</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = "wordgoodgoodgoodbestword", words =["word","good","best","word"]<br />输出：[]</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = "barfoofoobarthefoobarman", words =["bar","foo","the"]<br />输出：[6,9,12]</p></blockquote><p>提示：<br />* 1 &lt;= s.length &lt;= 104<br />* s 由小写英文字母组成<br />* 1 &lt;= words.length &lt;= 5000<br />* 1 &lt;= words[i].length &lt;= 30<br />* words[i]由小写英文字母组成</p><h2 id="分析">分析</h2><p>需要知道words的一个组合是否是s的一个子串，由于words中的元素组合成的字符串是固定长度的，所以只需要考虑s中固定长度的子串，以实例2为例，words中每个词的长度为4，而words中元素个数也是4，所以组合成的字符串总长度为<code>4*4 = 16</code>，所以遍历s的长度为16的子串，看看该子串里的元素是否和words一样。具体过程为：<br /><font color='red'>wordgoodgoodgood</font>bestword -&gt;w<font color='red'>ordgoodgoodgoodb</font>estword -&gt;wo<font color='red'>rdgoodgoodgoodbe</font>stword -&gt; ...</p><p>上述方法每次移动一个字符串，无法利用之前窗口的信息，显然不合理，由于每个元素长度为4，可以每次移动4个字符，即<br />*以<code>w</code>开始，长度为16的窗口，以4为步长移动：<font color='red'>wordgoodgoodgood</font>bestword-&gt; word<font color='red'>goodgoodgoodbest</font>word -&gt;wordgood<font color='red'>goodgoodbestword</font> -&gt; ...<br />*以<code>o</code>开始，长度为16的窗口，以4为步长移动：w<font color='red'>ordgoodgoodgoodb</font>estword-&gt; wordg<font color='red'>oodgoodgoodbestw</font>ord<br />* 以<code>r</code>开始以及以<code>d</code>开始相应的窗口移动</p><p>优化后的方法同样可以遍历完所有子串，而且由于每次移出一个单词，移入一个单词，从而可以很好的维护窗口中的元素。</p><p>在模拟窗口移动时发现可以继续优化，比如即将移入的元素不存在于words中，表明直到将该元素移出为止，不可能存在满足条件的子串。另外一种可以优化的情况，如果即将移入的元素在words中，但是元素个数超过了words中的该元素个数呢？显然这时候需要移出该元素前面的所有元素（包含自身），这样才能让该元素的个数少一个。</p><p>考虑了上面的两种情况就可以保证子串里的元素都在words中，且每个元素的个数不超过words中的元素，所以该窗口必为words中的某个组合，因为如果某个元素的个数小与words中的该元素个数，那么窗口的长度必然小于16。</p><h2 id="代码">代码</h2><details open><summary>python</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, words: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        word_len = <span class="built_in">len</span>(words[<span class="number">0</span>])</span><br><span class="line">        num_words = <span class="built_in">len</span>(words)</span><br><span class="line">        total_len = num_words * word_len</span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        all_indices = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s_len &lt; total_len:</span><br><span class="line">            <span class="keyword">return</span> all_indices</span><br><span class="line"></span><br><span class="line">        word_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            word_map[word] = word_map.get(word, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> wi <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">min</span>(word_len, s_len - total_len+<span class="number">1</span>)):</span><br><span class="line">            start = curr = <span class="number">0</span></span><br><span class="line">            window_map = &#123;&#125;</span><br><span class="line">            <span class="keyword">while</span> wi + curr * word_len &lt;= (s_len - word_len):</span><br><span class="line">                curr_word = s[wi+curr*word_len:wi+curr*word_len+word_len]</span><br><span class="line">                <span class="keyword">if</span> curr_word <span class="keyword">not</span> <span class="keyword">in</span> word_map:</span><br><span class="line">                    window_map = &#123;&#125;</span><br><span class="line">                    start = curr + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    window_map[curr_word] = [</span><br><span class="line">                        window_map.get(curr_word, [<span class="number">0</span>, []])[<span class="number">0</span>] + <span class="number">1</span>,</span><br><span class="line">                        window_map.get(curr_word, [<span class="number">0</span>, []])[<span class="number">1</span>] + [curr]</span><br><span class="line">                    ]</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> window_map[curr_word][<span class="number">0</span>] &gt; word_map[curr_word]:</span><br><span class="line">                        new_start = window_map[curr_word][<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">                        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, window_map[curr_word][<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>):</span><br><span class="line">                            window_map[s[wi+i*word_len:wi+i*word_len+word_len]][<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                            window_map[s[wi+i*word_len:wi+i*word_len+word_len]][<span class="number">1</span>].pop(<span class="number">0</span>)</span><br><span class="line">                        start = new_start</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> curr - start + <span class="number">1</span> == num_words:</span><br><span class="line">                        <span class="keyword">if</span> window_map[curr_word][<span class="number">0</span>] == word_map[curr_word]:</span><br><span class="line">                            all_indices.append(wi+start*word_len)</span><br><span class="line">                        window_map[s[wi+start*word_len:wi+start*word_len+word_len]][<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">                curr += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> all_indices</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解29：两数相除</title>
      <link href="/2022/01/06/leetcode%E9%A2%98%E8%A7%A329/"/>
      <url>/2022/01/06/leetcode%E9%A2%98%E8%A7%A329/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/divide-two-integers/">力扣第29题</a></p><p>给定两个整数，被除数<code>dividend</code>和除数<code>divisor</code>。将两数相除，要求不使用乘法、除法和<code>mod</code>运算符。</p><p>返回被除数<code>dividend</code>除以除数<code>divisor</code>得到的商。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) =8 以及 truncate(-2.7335) = -2</p><span id="more"></span><p>示例1:</p><blockquote><p>输入: dividend = 10, divisor = 3<br />输出: 3<br />解释: 10/3 = truncate(3.33333..) = truncate(3) = 3<br />示例2:</p></blockquote><blockquote><p>输入: dividend = 7, divisor = -3<br />输出: -2<br />解释: 7/-3 = truncate(-2.33333..) = -2</p></blockquote><p>提示：</p><ul><li>被除数和除数均为<code>32</code>位有符号整数。</li><li>除数不为<code>0</code>。</li><li>假设我们的环境只能存储<code>32</code>位有符号整数，其数值范围是<code>[−2^31, 2^31 − 1]</code>。本题中，如果除法结果溢出，则返回<code>2^31 − 1</code>。</li></ul><h2 id="分析">分析</h2><p>不能使用乘除计算两个数的除法，只能用加减了，考虑到正负只对最后结果的正负号有影响，所以可以先讨论被除数和除数都为正数的情况；而最简单的思路就是用除数循环加自身直到最后的值大于被除数，然后计算循环的次数就是商了。伪代码如下：<br /><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sum</span> = divisor</span><br><span class="line">result = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">sum</span> &lt; dividend:</span><br><span class="line">    <span class="built_in">sum</span> += divisor</span><br><span class="line">    result++;</span><br></pre></td></tr></table></figure></p><p>上面思路显然效率太低了，问题在于每次只加上<code>divisor</code>，如果每次加上<code>sum</code>自身，然后<code>result</code>也加上自身，这样就使得<code>sum = pow(2, result) * divisor</code>，这样<code>sum</code>会是指数级增加，比之前的线性增加快了太多；</p><p>但是问题来了，按照上面的算法，最终商会定位到<code>pow(2, n-1)</code>和<code>pow(2, n)</code>，<code>n</code>是满足<code>pow(2, n-1) * divisor &lt; dividend &lt; pow(2, n) * divisor</code>正整数，接下来如何定位到确定的商的，注意到最终的商必然是<code>pow(2, n-1) + k</code>，即<code>pow(2, n-1) + k = dividend / divisor</code>,从而得到<code>k = (dividend - pow(2, n-1) * divisor) / divisor</code>，就是说<code>k</code>也是两个数的商，那么可以继续使用上面的思路，只不过这时候被除数变为了<code>dividend - pow(2, n-1) * divisor = dividend - sum</code>。伪代码也很简单：<br /><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="keyword">div</span>(dividend, divisor):</span><br><span class="line">    <span class="keyword">if</span> (dividend &lt; divisor):</span><br><span class="line">        <span class="literal">return</span> <span class="number">0</span></span><br><span class="line">    <span class="built_in">sum</span> = divisor</span><br><span class="line">    <span class="built_in">result</span> = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">sum</span> + <span class="built_in">sum</span>) &lt; dividend:</span><br><span class="line">        <span class="built_in">sum</span> += <span class="built_in">sum</span></span><br><span class="line">        reuslt += <span class="built_in">result</span></span><br><span class="line">    <span class="literal">return</span> <span class="built_in">result</span> + <span class="keyword">div</span>(dividend - <span class="built_in">sum</span>, divisor)</span><br></pre></td></tr></table></figure><br />由于<code>sum+sum</code>可能会溢出，所以改为<code>sum &lt; dividend - sum</code>就好。</p><p>最后无非是考虑边界了，由于int32的数值范围是<code>[-2^31, 2^31-1]</code>，所以如果把值转为正数，那么范围会变成<code>[0, 2^31]</code>，这时候<code>2^31</code>就会溢出，怎么办呢？其实这里有个小技巧，不都转为正数，而是都转为负数，因为转为负数后的范围是<code>[-2^31, 0]</code>，这样就不会溢出了。当然被除数与除数全部转为负数后，要注意代码中的大小关系与全转为正数时的不同。</p><p>当然如果全部使用<code>long long</code>长整型，就没有那么多边界的问题需要考虑了。但是题目应该是倾向于只使用<code>int</code>整型。</p><h2 id="代码">代码</h2><details open><summary>c++</summary><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当dividend和divisor为INT_MIN时，不能使用绝对值，因为会溢出</span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend == INT_MIN)&#123;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">-1</span>) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor == INT_MIN) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dividend == INT_MIN) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> isPositive = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dividend = -dividend;</span><br><span class="line">            isPositive = !isPositive;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            divisor = -divisor;</span><br><span class="line">            isPositive = !isPositive;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> result = <span class="built_in">div</span>(dividend, divisor);</span><br><span class="line">        <span class="keyword">return</span> isPositive ? result : -result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; divisor) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = divisor;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 注意： 不能使用sum - dividend，可能会先计算-dividend，从而导致溢出</span></span><br><span class="line">        <span class="keyword">while</span> ((dividend - sum) &lt;= sum)&#123;</span><br><span class="line">            sum += sum;</span><br><span class="line">            result += result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result + <span class="built_in">div</span>(dividend - sum, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗篇：情有感</title>
      <link href="/2021/12/17/%E8%AF%97%E7%AF%87%EF%BC%9A%E6%83%85%E6%9C%89%E6%84%9F/"/>
      <url>/2021/12/17/%E8%AF%97%E7%AF%87%EF%BC%9A%E6%83%85%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <h3 id="情有感">情有感</h3><p>半影哀鸿寄妾伤，孤衣破镜弄眉妆；<br />陈姻落尽双娥泪，忆最倾心爱未央。</p>            <i class="fa fa-quote-right"></i>          </blockquote>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题二：高中篇1</title>
      <link href="/2021/12/17/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%982/"/>
      <url>/2021/12/17/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<p>$1. $ <span class="math inline">\(f(x)=3ax^2 + 2bx +c\)</span>，若<span class="math inline">\(a+b+c=0,f(0)f(1)&gt;0\)</span>，求证：<br />（1）方程<span class="math inline">\(f(x)=0\)</span>有实根；<br />（2）<span class="math inline">\(\displaystyle -2 &lt; \frac{b}{a} &lt;-1\)</span>；<br />（3）设<span class="math inline">\(x_1,x_2\)</span>是方程<spanclass="math inline">\(f(x)=0\)</span>的两个实根，则<spanclass="math inline">\(\displaystyle \frac{\sqrt 3}{3} &lt; |x_1 - x_2|&lt; \frac{2}{3}\)</span>。</p><span id="more"></span><p>$2. $ 已知<span class="math inline">\(f(x)\)</span>是定义在<spanclass="math inline">\([-1,1]\)</span>的奇函数，且<spanclass="math inline">\(f(1)=1\)</span>，若<span class="math inline">\(a,b \in [-1, 1], a+b \ne 0\)</span>，有<spanclass="math inline">\(\displaystyle \frac{f(a)+f(b)}{a+b} &gt;0\)</span>恒成立，<br />（1）判断<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\([-1,1]\)</span>的单调性。<br />（2）若<span class="math inline">\(f(x) \lem^2-2am+1\)</span>，对所有<span class="math inline">\(x \in [-1, 1], a\in [-1, 1]\)</span>恒成立，求<spanclass="math inline">\(m\)</span>的取值范围。</p><p>$3. $ 设实数<span class="math inline">\(a,b,c\)</span>满足<br /><span class="math display">\[    \left\{  \begin{aligned}        &amp; a^2 - bc -8a + 7 = 0 \\        &amp; b^2 + c^2 + bc - 6a + 6 = 0    \end{aligned}    \right.\]</span><br />求<span class="math inline">\(a\)</span>的取值范围。</p><p>$4. $ 已知<span class="math inline">\(a,b,c\)</span>都不是小于<spanclass="math inline">\(1\)</span>的实数，满足<spanclass="math inline">\(a \cdot b \cdot c = 10\)</span>，并且<spanclass="math inline">\(a^{\lg a} \cdot b^{\lg b} \cdot c^{\lg c} \ge10\)</span>，求<span class="math inline">\(a+b+c\)</span>的值。</p><p>$5. $ 函数<span class="math inline">\(f(x)\)</span>的定义域为<spanclass="math inline">\([0, +\infty)\)</span>，且满足<br />（1）<span class="math inline">\(f(x)\)</span>在<spanclass="math inline">\((0, +\infty)\)</span>上递增；<br />（2）对<span class="math inline">\(x&gt;0\)</span>，均有<spanclass="math inline">\(\displaystylef(f(x)+\frac{1}{x})=1\)</span>；<br />求<span class="math inline">\(f(1)\)</span>。</p><p>$6. $ <span class="math inline">\(f(x+3)f(1-x)=0\)</span>有<spanclass="math inline">\(5\)</span>个实数根，则这<spanclass="math inline">\(5\)</span>个根之和为？</p><p>$7. $ <span class="math inline">\(\triangle ABC\)</span>中，点<spanclass="math inline">\(G\)</span>为中线<spanclass="math inline">\(AM\)</span>的中点，过点<spanclass="math inline">\(G\)</span>作<spanclass="math inline">\(PQ\)</span>分别交<spanclass="math inline">\(AB,AC\)</span>于点<spanclass="math inline">\(P,Q\)</span>，若<spanclass="math inline">\(AP=hAB, AQ=kAC\)</span>，<spanclass="math inline">\(\triangle APQ\)</span>的面积为<spanclass="math inline">\(S\)</span>，<span class="math inline">\(\triangleABC\)</span>的面积为<span class="math inline">\(T\)</span>，求<br />（1）<span class="math inline">\(\displaystyle \frac{1}{h} +\frac{1}{k}\)</span>的值；<br />（2）<span class="math inline">\(\displaystyle\frac{S}{T}\)</span>的最小值。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5irsesusr580.webp" width="30%"></p><p>$8. $ <span class="math inline">\(a,b,c\)</span>为非负数，求<spanclass="math inline">\(\displaystylef(a,b,c)=\frac{c}{a}+\frac{a}{b+c}+\frac{b}{c}\)</span>的最小值？</p><p>$9. $ 求<span class="math inline">\(\displaystyle\sqrt{\frac{4x+3}{x+1}} +\sqrt{\frac{5x+6}{x+1}}\)</span>的定义域和值域。</p><p>$10. $ 不等式<span class="math inline">\(\displaystyle \sqrt{x} \geax + \frac{3}{2}\)</span>的解集为<spanclass="math inline">\((4,b)\)</span>，则实数<spanclass="math inline">\(a,b\)</span>为？</p><p>$11. $ 正方体<spanclass="math inline">\(ABCD-A_1B_1C_1D_1\)</span>的棱长为1，对角线<spanclass="math inline">\(BD_1\)</span>的截面面积记为<spanclass="math inline">\(S\)</span>，则<spanclass="math inline">\(S\)</span>的取值范围是？</p><p>$12. $ 已知<span class="math inline">\(\sin \alpha + \sin \beta =\sqrt 2, \cos \alpha + \cos \beta = \frac{2\sqrt 3}{3}\)</span>，求<spanclass="math inline">\(\tan \alpha \tan \beta\)</span>的值。</p><p>$13. $ <span class="math inline">\(\triangleABC\)</span>中，内角<span class="math inline">\(A,B,C\)</span>满足<spanclass="math inline">\(2 \sin B = \sin A + \sin C\)</span>，求<spanclass="math inline">\(5 \cos A - 4 \cos A \cos C + 5 \cosC\)</span>的值。</p><p>$14. $ 已知<span class="math inline">\(\displaystyle \frac{\sin^2\gamma}{\sin^2 \alpha} = 1 - \frac{\tan (\alpha - \beta)}{\tan\alpha}\)</span>，求证<span class="math inline">\(\tan^2 \gamma = \tan\alpha \tan \beta\)</span>。</p><p>$15. $ 已知正方形<spanclass="math inline">\(ABCD\)</span>的边长为<spanclass="math inline">\(1\)</span>，<spanclass="math inline">\(P,Q\)</span>分别是<spanclass="math inline">\(AD,AB\)</span>上的点，<spanclass="math inline">\(\triangle APQ\)</span>的周长为<spanclass="math inline">\(2\)</span>，求<span class="math inline">\(\anglePCQ\)</span>。</p><p>$16. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB=AC\)</span>，点<spanclass="math inline">\(D\)</span>是<spanclass="math inline">\(BC\)</span>的中点，点<spanclass="math inline">\(E\)</span>是从点<spanclass="math inline">\(D\)</span>作<spanclass="math inline">\(AC\)</span>的垂线的垂足，点<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(DE\)</span>的中点，证明<spanclass="math inline">\(AF \perp BE\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6ykaxfxmny80.webp" width="25%"></p><p>$17. $ 已知点<span class="math inline">\(P\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>内一点，且<spanclass="math inline">\(\displaystyle \overrightarrow{AP} = \frac{2}{5}\overrightarrow{AB} + \frac{1}{3} \overrightarrow{AC}\)</span>，则<spanclass="math inline">\(\triangle ABP\)</span>和<spanclass="math inline">\(\triangle ABC\)</span>的面积之比为？</p><p>$18. $ 在<span class="math inline">\(Rt\triangleABC\)</span>中，斜边<spanclass="math inline">\(BC=a\)</span>，若长为<spanclass="math inline">\(2a\)</span>的线段<spanclass="math inline">\(PQ\)</span>以<spanclass="math inline">\(A\)</span>为中点，问<spanclass="math inline">\(\overrightarrow{PQ}\)</span>与<spanclass="math inline">\(\overrightarrow{BC}\)</span>的夹角<spanclass="math inline">\(\theta\)</span>取何值时，<spanclass="math inline">\(\overrightarrow{BP} \cdot\overrightarrow{CQ}\)</span>的值最大，并求出这个最大值。</p><p>$19. $ 已知<span class="math inline">\(\triangleABC\)</span>三内角满足<spanclass="math inline">\(2B=A+C\)</span>，求<spanclass="math inline">\(\sin^2 A + \sin^2 C\)</span>的取值范围。</p><p>$20. $ 已知<span class="math inline">\(f(\theta) = \cos^2 \theta +\cos^2 (\theta + \alpha) + \cos^2 (\theta +\beta)\)</span>，是否存在满足<span class="math inline">\(0\le \alpha&lt; \beta &lt; \pi\)</span>的<span class="math inline">\(\alpha,\beta\)</span>使得<spanclass="math inline">\(f(\theta)\)</span>的取值不随<spanclass="math inline">\(\theta\)</span>的变化而变化，如果存在，求出<spanclass="math inline">\(\alpha,\beta\)</span>的值，若不存在，请说明理由。</p><p>$21. $ 已知非零向量<span class="math inline">\(\vec a, \vece\)</span>, 满足<span class="math inline">\(\vec a \ne \vece\)</span>，且对任意的<span class="math inline">\(t \in\mathbb{R}\)</span>，有<span class="math inline">\(|\vec a - t \vec e|\ge |\vec a - \vec e|\)</span>，证明<span class="math inline">\(\vec e\perp (\vec a - \vec e)\)</span>。</p><p>$22. $ 已知<span class="math inline">\(P\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>内一点，且满足<spanclass="math inline">\(\overrightarrow {PA} + 2\overrightarrow {PB} +3\overrightarrow {PC} = \vec 0\)</span>，记<spanclass="math inline">\(\triangle ABP, \triangle BCP, \triangleCAP\)</span>的面积依次为<spanclass="math inline">\(S_1,S_2,S_3\)</span>，则<spanclass="math inline">\(S_1:S_2:S_3=?\)</span></p><p>$23. $ <span class="math inline">\(\triangleABC\)</span>内接于以点<spanclass="math inline">\(O\)</span>为圆心，<spanclass="math inline">\(1\)</span>为半径的圆，<spanclass="math inline">\(3 \overrightarrow{OA} + 4 \overrightarrow{OB} + 5\overrightarrow{OC} = 0\)</span>，求<br />（1）<span class="math inline">\(\overrightarrow{OA} \cdot\overrightarrow{OB}, \overrightarrow{OB}\cdot \overrightarrow{OC},\overrightarrow{OC} \cdot \overrightarrow{OA}\)</span>；<br />（2）三角形<span class="math inline">\(ABC\)</span>的面积。</p><p>$24. $ 在四面体<span class="math inline">\(ABCD\)</span>中，如果<spanclass="math inline">\(AB \perp CD, DB \perp AC\)</span>，证明<spanclass="math inline">\(DA \perp BC\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题2/xxx.5f9uqgn734o0.webp" width="28%"></p><p>$25. $ 一条直线上有三点<spanclass="math inline">\(A,B,C\)</span>，点<spanclass="math inline">\(C\)</span>在<spanclass="math inline">\(A,B\)</span>之间，点<spanclass="math inline">\(P\)</span>是此直线外一点，设<spanclass="math inline">\(\angle APC=\alpha, \angleBPC=\beta\)</span>，证明<span class="math inline">\(\displaystyle\frac{\sin (\alpha + \beta)}{PC} = \frac{\sin \alpha}{PB} + \frac{\sin\beta}{PA}\)</span>。</p><p>$26. $ 圆内接四边形<spanclass="math inline">\(ABCD\)</span>的边长分别为<spanclass="math inline">\(AB=2,BC=6,CD=DA=4\)</span>，求四边形的面积。</p><p>$27. $一三角形的三边长为连续的正整数，且最大角是最小角的两倍，求该三角形的三边长。</p><p>$28. $ 设空间中两个不同的向量<span class="math inline">\(\vec a =(x_1,y_1,0)\)</span>和<span class="math inline">\(\vec b =(x_2,y_2,0)\)</span>与向量<span class="math inline">\(\vecc=(1,1,1)\)</span>的夹角都为<span class="math inline">\(\displaystyle\frac{\pi}{4}\)</span>，求向量<span class="math inline">\(\veca\)</span>与<span class="math inline">\(\vec b\)</span>的夹角。</p><p>$29. $ 如图，<spanclass="math inline">\(\alpha-l-\beta\)</span>为<spanclass="math inline">\(60^\circ\)</span>的二面角，等腰直角三角形<spanclass="math inline">\(MPN\)</span>的直角顶点<spanclass="math inline">\(P\)</span>在<spanclass="math inline">\(l\)</span>上，<span class="math inline">\(M \in\alpha, N \in \beta\)</span>，且<spanclass="math inline">\(MP\)</span>与<spanclass="math inline">\(\beta\)</span>所成角等于<spanclass="math inline">\(NP\)</span>与<spanclass="math inline">\(\alpha\)</span>的成角，<br />证：（1）<span class="math inline">\(MN\)</span> 与 <spanclass="math inline">\(\alpha, \beta\)</span> 所成角相等；<br />（2）求<span class="math inline">\(MN\)</span>与<spanclass="math inline">\(\beta\)</span>所成角。</p><p>$30. $ 已知数集<span class="math inline">\(A = \{a_1, a_2, \cdots,a_n\}(1 \le a_1 &lt; a_2 &lt; \cdots &lt; a_n,n&gt;=2)\)</span>具有性质<spanclass="math inline">\(P\)</span>，即对任意<spanclass="math inline">\(i,j(1 \le i \le j \le n)\)</span>，<spanclass="math inline">\(a_ia_j\)</span>和<spanclass="math inline">\(\displaystyle\frac{a_j}{a_i}\)</span>至少有一个属于<spanclass="math inline">\(A\)</span>，<br />证：（1）<span class="math inline">\(a=1, \displaystyle \frac{a_1 + a_2+ \cdots + a_n}{a_1^{-1} + a_2^{-1} + \cdots + a_n^{-1}} =a_n\)</span>；<br />（2）当<span class="math inline">\(n=5\)</span>时，<spanclass="math inline">\(a_1, a_2, a_3, a_4, a_5\)</span>成等比数列。</p><p>$31. $ 已知<span class="math inline">\(\vec i\)</span>和<spanclass="math inline">\(\vec j\)</span>分别是<spanclass="math inline">\(x,y\)</span>轴方向上的单位向量，<spanclass="math inline">\(\overrightarrow{OA_1} = \vec j,\overrightarrow{OA_2} = 10 \vec j, \overrightarrow{A_{n-1}A_n} = 3\overrightarrow{A_nA_{n+1}}(n=2,3,4,\cdots)\)</span>，在射线<spanclass="math inline">\(y=x(x \ge 0)\)</span>上，从下到上依次有点<spanclass="math inline">\(B_k(k=1,2,3,\cdots), \overrightarrow{OB_1} = 3\vec i + 3 \vec j\)</span>，且<spanclass="math inline">\(|\overrightarrow{B_{n-1}B_n}| = 2 \sqrt {2}(n=2,3,4,\cdots)\)</span>，<br />（1）求<span class="math inline">\(\overrightarrow{OA_n},\overrightarrow{OB_n}\)</span>；<br />（2）求四边形<spanclass="math inline">\(A_nA_{n+1}B_nB_{n+1}\)</span>面积的最大值。</p><p>$32. $ 已知一簇椭圆<span class="math inline">\(\displaystyle C_n: x^2+ \frac{y^2}{b_n^2} = 1, 0 &lt; b_n &lt; 1,n=1,2,\cdots\)</span>，若椭圆<spanclass="math inline">\(C_n\)</span>上有一点<spanclass="math inline">\(P_n\)</span>，使得<spanclass="math inline">\(P_n\)</span>到右准线<spanclass="math inline">\(l_n\)</span>的距离<spanclass="math inline">\(d_n\)</span>是<spanclass="math inline">\(|P_nF_n|\)</span>与<spanclass="math inline">\(|P_nG_n|\)</span>的等差中项，其中<spanclass="math inline">\(F_n, G_n\)</span>是<spanclass="math inline">\(C_n\)</span>的左右焦点；<br />（1）试证<span class="math inline">\(\displaystyle b_n \le \frac{\sqrt3}{2} (n \ge 1)\)</span><br />（2）取<span class="math inline">\(\displaystyle b_n = \frac{\sqrt {2n +3}}{n+2}\)</span>，并用<span class="math inline">\(S_n\)</span>表示<spanclass="math inline">\(\triangle P_nF_nG_n\)</span>的面积，试证<spanclass="math inline">\(S_1 &lt; S_2\)</span>，且<spanclass="math inline">\(S_n &gt; S_{n+1} (n \ge 3)\)</span></p><p>$33. $ 已知抛物线<span class="math inline">\(C: y^2 =4x\)</span>，焦点<span class="math inline">\(F\)</span>，准线与<spanclass="math inline">\(x\)</span>轴交于点<spanclass="math inline">\(A\)</span>，过点<spanclass="math inline">\(A\)</span>且斜率为<spanclass="math inline">\(k\)</span>的直线<spanclass="math inline">\(l\)</span>与抛物线<spanclass="math inline">\(C\)</span>交于<spanclass="math inline">\(P,Q\)</span>两点；<br />（1）求满足<span class="math inline">\(\overrightarrow {FR} =\overrightarrow{FP} + \overrightarrow{FQ}\)</span>的点<spanclass="math inline">\(R\)</span>的轨迹方程；<br />（2）若<span class="math inline">\(\anglePFQ\)</span>为钝角，求直线<spanclass="math inline">\(l\)</span>的斜率<spanclass="math inline">\(k\)</span>的取值范围。</p><p>$34. $ 设椭圆中心在坐标原点，<span class="math inline">\(A(2,0),B(0,1)\)</span>是它的两个顶点，直线<span class="math inline">\(y=kx(k&gt;0)\)</span>与<span class="math inline">\(AB\)</span>相交于点<spanclass="math inline">\(D\)</span>，与椭圆相交于<spanclass="math inline">\(E,F\)</span>两点，<br />（1）若<span class="math inline">\(\overrightarrow{ED} = 6\overrightarrow{DF}\)</span>，求<spanclass="math inline">\(k\)</span>的值；<br />（2）求四边形<span class="math inline">\(AEBF\)</span>面积的最大值。</p><p>$35. $ 设<span class="math inline">\(A,B\)</span>是椭圆<spanclass="math inline">\(3x^2+y^2=\lambda\)</span>上的点，点<spanclass="math inline">\(N(1,3)\)</span>是<spanclass="math inline">\(AB\)</span>的中点，<spanclass="math inline">\(AB\)</span>的垂直平分线与椭圆相交于<spanclass="math inline">\(C,D\)</span>两点；<br />（1）确定<spanclass="math inline">\(\lambda\)</span>的取值范围，并求<spanclass="math inline">\(AB\)</span>的方程；<br />（2）试判断是否存在这样的<spanclass="math inline">\(\lambda\)</span>，使<spanclass="math inline">\(A,B,C,D\)</span>四点共圆。</p><p>$36. $ 已知椭圆的焦点在<spanclass="math inline">\(x\)</span>轴上，以<spanclass="math inline">\(O\)</span>为中心；斜率为<spanclass="math inline">\(1\)</span>过椭圆右焦点<spanclass="math inline">\(F\)</span>的直线交椭圆于<spanclass="math inline">\(A,B\)</span>两点，<spanclass="math inline">\(\overrightarrow{OA}+\overrightarrow{OB}\)</span>与<spanclass="math inline">\(\vec a = (3, -1)\)</span>共线；<br />（1）求椭圆的离心率；<br />（2）设<span class="math inline">\(M\)</span>为椭圆上一点，且<spanclass="math inline">\(\overrightarrow{OM} = \lambda \overrightarrow{OA}+ \mu \overrightarrow{OB}(\lambda, \mu \in\mathbb{R})\)</span>，求证<span class="math inline">\(\lambda^2 +\mu^2\)</span>为定值。</p><p>$37. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{4} + \frac{y^2}{3} = 1\)</span>，直线<spanclass="math inline">\(y = kx + m\)</span>与椭圆相交于<spanclass="math inline">\(A,B\)</span>两点（<spanclass="math inline">\(A,B\)</span>不是左右顶点），且以<spanclass="math inline">\(AB\)</span>为直径的圆过椭圆的右顶点，求证直线过定点。</p><p>$38. $ 圆<span class="math inline">\(x^2 + y^2 = 4\)</span>与<spanclass="math inline">\(y\)</span>轴的两个交点分别为<spanclass="math inline">\(A,B\)</span>，以<spanclass="math inline">\(A,B\)</span>为焦点，坐标为对称轴的双曲线与圆在<spanclass="math inline">\(y\)</span>轴左方的交点分别为<spanclass="math inline">\(C,D\)</span>，当梯形<spanclass="math inline">\(ABCD\)</span>的周长最大时，求双曲线的方程。</p><p>$39. $ 过抛物线<span class="math inline">\(y^2 =2x\)</span>的顶点作互相垂直的两条弦<spanclass="math inline">\(OA,OB\)</span>，<br />（1）求<span class="math inline">\(AB\)</span>中点轨迹方程；<br />（2）证明<span class="math inline">\(AB\)</span>过定点。</p><p>$40. $ 抛物线<span class="math inline">\(y^2 =2px(p&gt;0)\)</span>的焦点为<spanclass="math inline">\(F\)</span>，过<spanclass="math inline">\(F\)</span>的直线与抛物线交于<spanclass="math inline">\(A,B\)</span>两点，点<spanclass="math inline">\(C\)</span>在其准线上，且<spanclass="math inline">\(BC \parallel x\)</span>轴，求证直线<spanclass="math inline">\(AC\)</span>经过原点<spanclass="math inline">\(O\)</span>。</p><p>$41. $ 二次函数<span class="math inline">\(f(x) = ax^2 + bx + c (a&lt; b)\)</span>的值域为<span class="math inline">\([0,+\infty)\)</span>，则<span class="math inline">\(\displaystyle \frac{b -a}{a + b + c}\)</span>的最大值为？</p><p>$42. $ 椭圆<span class="math inline">\(\displaystyle \frac{x^2}{3} +y^2 = 1\)</span>与直线<span class="math inline">\(y = kx + m (k \ne0)\)</span>相交于不同两点<spanclass="math inline">\(M,N\)</span>，已知<spanclass="math inline">\(A(0,-1)\)</span>，当<spanclass="math inline">\(|AM| = |AN|\)</span>时，<br />求证：（1）<spanclass="math inline">\(MN\)</span>的中点的纵坐标为定值。<br />（2）<span class="math inline">\(\displaystyle \frac{1}{2} &lt; m &lt;2\)</span>。</p><p>$43. $ 边长为等差数列<spanclass="math inline">\(1,3,5,7,\cdots\)</span>的项一些等边三角形放置在同一条直线上，求证：它们的顶点在同一个抛物线上且各顶点到此抛物线的焦点的距离为整数。</p><p>$44. $ 一个酒杯的轴截面为抛物线的一部分，它的方程为<spanclass="math inline">\(x^2 = 2y (0 \le y \le20)\)</span>，在杯内放一个玻璃球，要使球触及杯的底部，则玻璃球的半径<spanclass="math inline">\(r\)</span>的取值范围为？</p><p>$45. $ 设抛物线<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>的轴和它的准线交于点<spanclass="math inline">\(E\)</span>，进过焦点<spanclass="math inline">\(F\)</span>的直线交抛物线于<spanclass="math inline">\(P,Q\)</span>两点（直线<spanclass="math inline">\(PQ\)</span>不与轴垂直），求证<spanclass="math inline">\(\angle FEP = \angle QEF\)</span>。</p><p>$46. $ 抛物线<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>的动弦<span class="math inline">\(AB\)</span>长为<spanclass="math inline">\(a(a \ge 2p)\)</span>，则<spanclass="math inline">\(AB\)</span>的中点<spanclass="math inline">\(M\)</span>到<spanclass="math inline">\(y\)</span>轴的最短距离为？</p><p>$47. $ 已知抛物线<span class="math inline">\(y^2 =8x\)</span>上的两个动点<spanclass="math inline">\(A,B\)</span>及一个定点<spanclass="math inline">\(M(x_0,y_0)\)</span>，<spanclass="math inline">\(F\)</span>是抛物线的焦点，且<spanclass="math inline">\(|AF|,|MF|,|BF|\)</span>构成等差数列，线段<spanclass="math inline">\(AB\)</span>的垂直平分线与<spanclass="math inline">\(x\)</span>轴交于一点<spanclass="math inline">\(N\)</span>，则<spanclass="math inline">\(N\)</span>的坐标为？（用<spanclass="math inline">\(x_0\)</span>表示）</p><p>$48. $ 已知<span class="math inline">\(A(x_1,y_1), B(x_2,y_2) (x_1x_2\ne 0)\)</span>是抛物线<span class="math inline">\(y^2 = 2px(p&gt;0)\)</span>上的两个动点，<spanclass="math inline">\(O\)</span>是坐标原点，<spanclass="math inline">\(\overrightarrow{OA} \cdot \overrightarrow{OB} =0\)</span>，设圆<span class="math inline">\(C\)</span>的方程为<spanclass="math inline">\(x^2+y^2 - (x_1+x_2)x - (y_1+y_2)y =0\)</span>，<br />（1）求圆心<span class="math inline">\(C\)</span>的轨迹方程；<br />（2）当圆心<span class="math inline">\(C\)</span>到直线<spanclass="math inline">\(x - 2y = 0\)</span>的距离最小值为<spanclass="math inline">\(\displaystyle \frac{2\sqrt5}{5}\)</span>时，求抛物线的方程。</p><p>$49. $ 已知动圆<span class="math inline">\(C\)</span>过定点<spanclass="math inline">\(\displaystyle (\frac{p}{2},0)\)</span>且与直线<span class="math inline">\(\displaystyle x = -\frac{p}{2}\)</span>相切，其中<spanclass="math inline">\(p&gt;0\)</span>，<br />（1）求圆<span class="math inline">\(C\)</span>的圆心轨迹方程；<br />（2）设<span class="math inline">\(A,B\)</span>是轨迹<spanclass="math inline">\(C\)</span>上异于原点<spanclass="math inline">\(O\)</span>的两个不同点，直线<spanclass="math inline">\(OA\)</span>和<spanclass="math inline">\(OB\)</span>的倾斜角分别是<spanclass="math inline">\(\alpha, \beta\)</span>，且<spanclass="math inline">\(\displaystyle \alpha + \beta =\frac{\pi}{4}\)</span>，证明直线<spanclass="math inline">\(AB\)</span>恒过定点。</p><p>$50. $ 已知抛物线<span class="math inline">\(C: x^2 = 2py(p&gt;0)\)</span>上一点<span class="math inline">\(A(m,4)\)</span>到其焦点的距离为<span class="math inline">\(\displaystyle\frac{17}{4}\)</span>，<br />（1）求<span class="math inline">\(p,m\)</span>的值；<br />（2）设抛物线<span class="math inline">\(C\)</span>是一点<spanclass="math inline">\(P\)</span>的横坐标为<spanclass="math inline">\(t(t&gt;0)\)</span>，过<spanclass="math inline">\(P\)</span>的直线交抛物线于另一点<spanclass="math inline">\(Q\)</span>，交<spanclass="math inline">\(x\)</span>轴于点<spanclass="math inline">\(M\)</span>，过点<spanclass="math inline">\(Q\)</span>作<spanclass="math inline">\(QP\)</span>的垂线交抛物线<spanclass="math inline">\(C\)</span>于另一点<spanclass="math inline">\(N\)</span>，若<spanclass="math inline">\(MN\)</span>是抛物线的切线，求<spanclass="math inline">\(t\)</span>的最小值。</p><p>$51. $ 已知抛物线<span class="math inline">\(y = x^2 -1\)</span>上一定点<spanclass="math inline">\(A(-1,0)\)</span>和两动点<spanclass="math inline">\(P,Q\)</span>，当<span class="math inline">\(PA\perp PQ\)</span>时，点<spanclass="math inline">\(Q\)</span>的横坐标的取值范围为？</p><p>$52. $ 过抛物线<span class="math inline">\(y^2 =4x\)</span>的焦点作弦<span class="math inline">\(AB\)</span>，<spanclass="math inline">\(M\)</span>为<spanclass="math inline">\(AB\)</span>的中点，则<spanclass="math inline">\(M\)</span>到直线<span class="math inline">\(x-y =0\)</span>的最短距离为？</p><p>$53. $ 抛物线<span class="math inline">\(x^2 = 2y\)</span>上距离<spanclass="math inline">\(A(0, a)(a &gt;0)\)</span>最近的点恰好是顶点，则<spanclass="math inline">\(a\)</span>的取值范围为？</p><p>$54. $ 设抛物线的方程<span class="math inline">\(x^2 = 2py(p&gt;0)\)</span>，<span class="math inline">\(M\)</span>为直线<spanclass="math inline">\(y = -2p\)</span>上任意一点，过<spanclass="math inline">\(M\)</span>引抛物线的切线，切点分别为<spanclass="math inline">\(A,B\)</span>，<br />（1）求证<spanclass="math inline">\(A,M,B\)</span>三点的横坐标成等差数列；<br />（2）已知<span class="math inline">\(M(2, -2p)\)</span>时，<spanclass="math inline">\(|AB| = 4\sqrt{10}\)</span>，求抛物线的方程；<br />（3）是否存在点<span class="math inline">\(M\)</span>使得点<spanclass="math inline">\(C\)</span>关于直线<spanclass="math inline">\(AB\)</span>对称的点<spanclass="math inline">\(D\)</span>在抛物线上，其中点<spanclass="math inline">\(C\)</span>满足<spanclass="math inline">\(\overrightarrow{OC} = \overrightarrow{OA} +\overrightarrow{OB}\)</span>(<spanclass="math inline">\(O\)</span>为坐标原点)，若存在，求出所有符合题意的点<spanclass="math inline">\(M\)</span>的坐标；若不存在，请说明理由。</p><p>$55. $ 已知<span class="math inline">\(P\)</span>是双曲线<spanclass="math inline">\(\displaystyle E: \frac{x^2}{a^2} - y^2 = 1(a&gt;0)\)</span>上的任意一点，<spanclass="math inline">\(F_1,F_2\)</span>分别是其左右焦点，过其中一焦点作<spanclass="math inline">\(\angleF_1PF_2\)</span>的内角平分线的垂线，垂足为<spanclass="math inline">\(M\)</span>，点<spanclass="math inline">\(M\)</span>的轨迹范围曲线<spanclass="math inline">\(C\)</span>，求曲线<spanclass="math inline">\(C\)</span>的方程。</p><p>$56. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2} (a&gt;b&gt;0)\)</span>，<spanclass="math inline">\(F_1,F_2\)</span>分别是左右焦点，若椭圆上存在点<spanclass="math inline">\(P\)</span>，使得<span class="math inline">\(\angleF_1PF_2 = 90^\circ\)</span>，求椭圆离心率<spanclass="math inline">\(e\)</span>的取值范围。</p><p>$57. $ 已知双曲线<span class="math inline">\(\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1(a&gt;0,b&gt;0)\)</span>的左右焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，若双曲线上存在点<spanclass="math inline">\(P\)</span>使得<spanclass="math inline">\(\displaystyle \frac{\sin \angle PF_1F_2}{\sin\angle PF_2F_1} = \frac{a}{c}\)</span>，则双曲线的离心率<spanclass="math inline">\(e\)</span>的取值范围为？</p><p>$58. $ 已知椭圆<span class="math inline">\(\displaystyle\frac{x^2}{a^2} + \frac{y^2}{b^2} (a&gt;b&gt;0)\)</span>的左右焦点<spanclass="math inline">\(F_1F_2\)</span>，离心率<spanclass="math inline">\(\displaystyle e = \frac{\sqrt2}{2}\)</span>，右准线方程为<span class="math inline">\(x =2\)</span>，<br />（1）求该椭圆的标准方程；<br />（2）过点<span class="math inline">\(F_1\)</span>的直线<spanclass="math inline">\(l\)</span>与该椭圆交于<spanclass="math inline">\(M,N\)</span>两点，且<spanclass="math inline">\(\displaystyle |\overrightarrow{F_2M} +\overrightarrow{F_2N}| = \frac{2\sqrt {26}}{3}\)</span>，求直线<spanclass="math inline">\(l\)</span>的方程。</p><p>$59. $ 已知双曲线<span class="math inline">\(\displaystyle\frac{x^2}{a^2} - \frac{y^2}{b^2} = 1(a&gt;0,b&gt;0)\)</span>的两个焦点分别为<spanclass="math inline">\(F_1,F_2\)</span>，<spanclass="math inline">\(P\)</span>是渐近线一点，且<spanclass="math inline">\(PF_1 \perp PF_2, |PF_1|\cdot |PF_2| =6ab\)</span>，则双曲线的离心率为？</p><p>$60. $ 已知<span class="math inline">\(AB\)</span>是过抛物线<spanclass="math inline">\(y^2 = 2px (p&gt;0)\)</span>的焦点<spanclass="math inline">\(F\)</span>的弦，<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(AB\)</span>的中点，<spanclass="math inline">\(l\)</span>是抛物线的准线，<spanclass="math inline">\(AC \perp l, BD \perp l, MN \perp l\)</span>，<spanclass="math inline">\(C,D,N\)</span>是垂足，则<spanclass="math inline">\((1) CF \perp DF, (2) CM \perp DM, (3) AN \perp BN,(4) NF \perp AB\)</span>中正确的有哪些？并证明。</p><p>$61. $ 设直线<span class="math inline">\(l: x = my + n (m \ne0)\)</span>交椭圆<span class="math inline">\(\displaystyle C:\frac{x^2}{4} + y^2 = 1\)</span>于<spanclass="math inline">\(A,B\)</span>两点<br />且坐标原点到直线<span class="math inline">\(l\)</span>的距离为<spanclass="math inline">\(1\)</span>；<br />（1）求<span class="math inline">\(|AB|\)</span>的最大值；<br />（2）当<span class="math inline">\(|AB|\)</span>取最大值时，直线<spanclass="math inline">\(l\)</span>是否过椭圆的一个焦点？</p><p>$62. $ 椭圆<span class="math inline">\(\displaystyle \frac{x^2}{a^2}+ \frac{y^2}{b^2} = 1 (a &gt; b &gt;0)\)</span>上的点<spanclass="math inline">\(M\)</span>与椭圆右焦点<spanclass="math inline">\(F_1\)</span>的连线<spanclass="math inline">\(MF_1\)</span>与<spanclass="math inline">\(x\)</span>轴垂直，且<spanclass="math inline">\(OM\)</span>(<spanclass="math inline">\(O\)</span>是坐标原点)与椭圆长轴和短轴端点的连线<spanclass="math inline">\(AB\)</span>平行；<br />（1）求椭圆的离心率；<br />（2）<span class="math inline">\(F_2\)</span>是椭圆的左焦点，<spanclass="math inline">\(C\)</span>是椭圆上任意一点，证明<spanclass="math inline">\(\displaystyle \angle F_1CF_2 \le\frac{\pi}{2}\)</span>；<br />（3）过<span class="math inline">\(F_1\)</span>且与<spanclass="math inline">\(AB\)</span>垂直的直线交椭圆于<spanclass="math inline">\(P,Q\)</span>两点，若<spanclass="math inline">\(\triangle PF_2Q\)</span>的面积为<spanclass="math inline">\(20\sqrt 3\)</span>，求此时椭圆的方程。</p><p>$63. $ 已知函数<span class="math inline">\(f(x) = x^3 + \sin x (x \in[-\pi, \pi])\)</span>的最小值<spanclass="math inline">\(M\)</span>，则<spanclass="math inline">\(f(x)\)</span>的最大值为？</p><p>$64. $ 非零向量<span class="math inline">\(\overrightarrow{OA} = \veca, \overrightarrow{OB} = \vec b\)</span>，若点<spanclass="math inline">\(B\)</span>关于<spanclass="math inline">\(\overrightarrow{OA}\)</span>所在直线对称点为<spanclass="math inline">\(B_1\)</span>，则向量<spanclass="math inline">\(\overrightarrow{OB} +\overrightarrow{OB_1}\)</span>为？</p><p>$65. $ 已知向量<span class="math inline">\(\displaystyle \vec a =(\lambda + 2, \lambda^2 - \cos^2 \theta), \vec b = (m, \frac{m}{2}+\sin\theta)\)</span>（其中<span class="math inline">\(\lambda, m, \theta \in\mathbb{R}\)</span>），且<span class="math inline">\(\vec a = 2 \vecb\)</span>，求<span class="math inline">\(\displaystyle\frac{\lambda}{m}\)</span>的取值范围。</p><p>$66. $ 求函数<span class="math inline">\(\displaystyle f(x) =\frac{\sin x + \cos x}{1 + \sin x + \cos x}\)</span>的最大和最小值。</p><p>$67. $ <span class="math inline">\(O\)</span>为<spanclass="math inline">\(\triangle ABC\)</span>的外心，<spanclass="math inline">\(H\)</span>为<span class="math inline">\(\triangleABC\)</span>的垂心，求证<span class="math inline">\(\overrightarrow{OH}= \overrightarrow{OA} + \overrightarrow{OB} +\overrightarrow{OC}\)</span>。</p><p>$68. $ <span class="math inline">\(O\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>内一点且<spanclass="math inline">\(\overrightarrow{OA} + 2 \overrightarrow{OB} + 2\overrightarrow{OC} = \vec 0\)</span>，则<spanclass="math inline">\(\triangle ABC\)</span>的面积与凹四边形<spanclass="math inline">\(ABCD\)</span>的面积之比为？</p><p>$69. $ 设<spanclass="math inline">\(A_1,A_2,\cdots,A_n\)</span>是单位圆上任意<spanclass="math inline">\(n\)</span>个点，求证在该圆上至少可以找打一个点<spanclass="math inline">\(M\)</span>，使<spanclass="math inline">\(|\overrightarrow{MA_1} + \overrightarrow{MA_2} +\cdots + \overrightarrow{MA_n}| \ge n\)</span>。</p><p>$70. $ <span class="math inline">\(O\)</span>为平面上一点，<spanclass="math inline">\(P,Q,R\)</span>是平面上不共线的三点，动点<spanclass="math inline">\(M\)</span>点满足<spanclass="math inline">\(\displaystyle \overrightarrow{OM} =\overrightarrow{OP} + k \left(\frac{\overrightarrow{PQ}}{|\overrightarrow{PQ}|} +\frac{\overrightarrow{PR}}{|\overrightarrow{PR}|} \right), k \in [0,+\infty)\)</span>，则<spanclass="math inline">\(M\)</span>的轨迹一定通过<spanclass="math inline">\(\triangle PQR\)</span>的__心？（内 外 垂 重）</p><p>$71. $ 已知<span class="math inline">\(H\)</span>是面积为<spanclass="math inline">\(2\)</span>的<span class="math inline">\(\triangleABC\)</span>的重心，并且<span class="math inline">\(\overrightarrow{BH}\cdot \overrightarrow{BC} = 4\)</span>，求<spanclass="math inline">\(\angle ABC\)</span>。</p><p>$72. $ 点<span class="math inline">\(P\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>内一点，且<spanclass="math inline">\(\overrightarrow{PA} + 2 \overrightarrow{PB} +3\overrightarrow{PC} = \vec 0\)</span>，则<spanclass="math inline">\(\triangle ABC\)</span>与<spanclass="math inline">\(\triangle APC\)</span>的面积之比为？</p><p>$73. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(O\)</span>为中线<spanclass="math inline">\(AM\)</span>上一动点，若<spanclass="math inline">\(AM = 2\)</span>，则<spanclass="math inline">\(\overrightarrow{OA} \cdot (\overrightarrow{OB} +\overrightarrow{OC})\)</span>的最小值为？</p><p>$74. $ 已知<span class="math inline">\(\displaystyle \sin \alpha +\sin \beta = \frac{\sqrt 2}{2}\)</span>，求<spanclass="math inline">\(\cos \alpha + \cos \beta\)</span>的取值范围。</p><p>$75. $ 求<span class="math inline">\((1+\tan 1^\circ)(1+\tan2^\circ)(1 + \tan 3^\circ)\cdots(1 + \tan 45^\circ)\)</span>的值。</p><p>$76. $ 已知<span class="math inline">\(\sin (\alpha + 2\beta) = 2\sin \alpha\)</span>，求<span class="math inline">\(\displaystyle\frac{\tan (\alpha + \beta)}{\tan \beta}\)</span>的值。</p><p>$77. $ 对任意的锐角<span class="math inline">\(\alpha,\beta\)</span>，下列命题中正确的有？<br />（1）<span class="math inline">\(\sin (\alpha + \beta) &gt; \sin \alpha+ \sin \beta\)</span>；<br />（2）<span class="math inline">\(\sin (\alpha + \beta) &gt; \cos \alpha+ \cos \beta\)</span>；<br />（3）<span class="math inline">\(\cos (\alpha + \beta) &gt; \sin \alpha+ \sin \beta\)</span>；<br />（4）<span class="math inline">\(\cos (\alpha + \beta) &gt; \cos \alpha+ \cos \beta\)</span>。</p><p>$78. $ 已知<span class="math inline">\(\displaystyle \sin \alpha \cos\beta = \frac{1}{2}\)</span>，则<span class="math inline">\(\cos \alpha\sin \beta\)</span>的取值范围是？</p><p>$79. $ 已知<span class="math inline">\(5 \sin 2\alpha = \sin2^\circ\)</span>，求<span class="math inline">\(\displaystyle \frac{\tan(\alpha + 1^\circ)}{\tan (\alpha - 1^\circ)}\)</span>。</p><p>$80. $ 求<span class="math inline">\(\cos 20^\circ cos 40^\circ \cos60^\circ \cos 80^\circ\)</span>。</p><p>$81. $ 求（1）<span class="math inline">\(\displaystyle \cos\frac{\pi}{11} \cos \frac{2\pi}{11} \cos \frac{3\pi}{11} \cos\frac{4\pi}{11} \cos \frac{5\pi}{11}\)</span>；<br />（2）<span class="math inline">\(\displaystyle \cos^4 \frac{\pi}{8} +\cos^4 \frac{3\pi}{8} + \cos^4 \frac{5\pi}{8} + \cos^4\frac{7\pi}{8}\)</span>；<br />（3）<span class="math inline">\(\displaystyle \cos \frac{2\pi}{7} +\cos \frac{4\pi}{7} + \cos \frac{6\pi}{7}\)</span>。</p><p>$82. $ 求<span class="math inline">\(\cos^2 36^\circ + \sin^218^\circ\)</span>的值。</p><p>$83. $ 试问是否存在同时满足下列条件的非零向量<spanclass="math inline">\(\vec a, \vec b\)</span>，<br />（1）<span class="math inline">\(|\vec a| &gt; |\vec b|\)</span>；<br />（2）<span class="math inline">\(\vec a\)</span>与<spanclass="math inline">\(\vec b\)</span>不垂直；<br />（3）<span class="math inline">\(|\vec a + \vec b| = |\vec a - \lambda\vec b|\)</span>，其中<spanclass="math inline">\(\lambda\)</span>为确定的整数。<br />若存在，试给出<span class="math inline">\(\vec a\)</span>和<spanclass="math inline">\(\vecb\)</span>所满足的条件，若不存在，则说明理由。</p><p>$84. $ 已知<span class="math inline">\(A,B,C\)</span>是<spanclass="math inline">\(\triangle ABC\)</span>的三个内角，<spanclass="math inline">\(\displaystyle y = \tan \frac{A}{2} + \frac{2 \cos\frac{A}{2}}{\sin \frac{A}{2} + \cos\frac{B-C}{2}}\)</span>，若任意交换两个角的位置<spanclass="math inline">\(y\)</span>的值是否变化？</p><p>$85. $ 已知<span class="math inline">\(\log_2 \sin 2x = \sin 2\theta\)</span>，求证<span class="math inline">\(\displaystyle \log_2(\tan x + \cos x) = 2 \cos^2 (\frac{\pi}{4} + \theta)\)</span>。</p><p>$86. $ 已知<span class="math inline">\(0 &lt; \alpha &lt;\pi\)</span>，证明<span class="math inline">\(\displaystyle 2 \sin2\alpha \le \cot \frac{\alpha}{2}\)</span>，并讨论<spanclass="math inline">\(\alpha\)</span>为何值时，等号成立。</p><p>$87. $ 已知<span class="math inline">\(\displaystyle \frac{1 + \tan\alpha}{1 - \tan \alpha} = 5 + 2 \sqrt 6\)</span>，求<spanclass="math inline">\(\displaystyle \frac{1 - \sin 2 \alpha}{\cos 2\alpha}\)</span>。</p><p>$88. $ 求<span class="math inline">\(\displaystyle \sin^4\frac{\pi}{16} + \sin^4 \frac{3\pi}{16} + \sin^4 \frac{5\pi}{16} +\sin^4 \frac{7\pi}{16}\)</span>。</p><p>$89. $ 求<span class="math inline">\(\sin^2 10^\circ + \cos^240^\circ + \sin 10^\circ \cos 40^\circ\)</span>。</p><p>$90. $ 设<spanclass="math inline">\(\alpha\)</span>是第四象限角，若<spanclass="math inline">\(\displaystyle \frac{\sin 3\alpha}{\sin \alpha} =\frac{13}{5}\)</span>，则<span class="math inline">\(\tan2\alpha=\)</span>？</p><p>$91. $ 已知<span class="math inline">\(\tan^2 x + \cot^2 x =4\)</span>，则<span class="math inline">\(\displaystyle \frac{3 + \cos4x}{1 - \cos 4x}=\)</span>?</p><p>$92. $ 求<span class="math inline">\(\displaystyle \frac{\sqrt 3 \tan12^\circ - 3}{(4\cos^2 12^\circ - 2)\sin 12^\circ}\)</span>。</p><p>$93. $ 在<span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(a,b, c\)</span>分别是角<spanclass="math inline">\(A,B,C\)</span>的对边，<spanclass="math inline">\(\displaystyle a^2 - c^2 = b^2 - \frac{8}{5}bc, a =3, S_{\triangle ABC} = 6\)</span>，若<spanclass="math inline">\(\triangle ABC\)</span>内任一点<spanclass="math inline">\(D\)</span>到三边距离之和为<spanclass="math inline">\(d\)</span>，求<spanclass="math inline">\(d\)</span>的取值范围。</p><p>$94. $ <span class="math inline">\(f(x) = \sin x + \tanx\)</span>，项数为<span class="math inline">\(27\)</span>的等差数列<spanclass="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(\displaystyle a_n \in (-\frac{\pi}{2},\frac{\pi}{2})\)</span>且公差<span class="math inline">\(d \ne0\)</span>，若<span class="math inline">\(f(a_1) + f(a_2) + \cdots +f(a_{27}) = 0\)</span>，则当<spanclass="math inline">\(k\)</span>为多少时，<spanclass="math inline">\(f(a_k) = 0\)</span>。</p><p>$95. $ 设函数<span class="math inline">\(f(x) = x - x \lnx\)</span>，数列<span class="math inline">\(\{a_n\}\)</span>满足<spanclass="math inline">\(0 &lt; a_1 &lt; 1, a_{n+1} =f(a_n)\)</span>；<br />证明：（1）函数<span class="math inline">\(f(x)\)</span>在区间<spanclass="math inline">\((0,1)\)</span>上是增函数；<br />（2）<span class="math inline">\(0 &lt; a_n &lt; a_{n+1} &lt;1\)</span>。</p><p>$97. $ 已知<span class="math inline">\(Rt\triangle ABC\)</span>中,<span class="math inline">\(\angle A = 90^\circ, AB = 1,BC=2\)</span>，<span class="math inline">\(D\)</span>为<spanclass="math inline">\(BC\)</span>的中点，将<spanclass="math inline">\(\triangle ABD\)</span>沿<spanclass="math inline">\(AD\)</span>折起，使点<spanclass="math inline">\(B\)</span>在面<spanclass="math inline">\(ADC\)</span>所在平面的投影<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(AC\)</span>上；<br />（1）求证：<span class="math inline">\(CD \perp\)</span>平面<spanclass="math inline">\(BDE\)</span>；<br />（2）求二面角<span class="math inline">\(B-AD-C\)</span>的余弦值；<br />（3）求<span class="math inline">\(AB\)</span>与平面<spanclass="math inline">\(BDE\)</span>所成的角。</p><p>$98. $ 设<spanclass="math inline">\(A,B,C,D\)</span>是空间不共面四点，<spanclass="math inline">\(AB \perp AC, AD \perp AC, AB \perpAD\)</span>，则<span class="math inline">\(\triangleBCD\)</span>是__三角形。（锐角，直角，钝角）</p><p>$99. $ 在平面直角坐标系<spanclass="math inline">\(xOy\)</span>中，过双曲线<spanclass="math inline">\(\displaystyle \frac{x^2}{a^2} - \frac{y^2}{b^2} =1(a&gt;0, b&gt;0)\)</span>的左焦点<spanclass="math inline">\(F\)</span>作圆<span class="math inline">\(x^2 +y^2 = a^2\)</span>的一条切线（切点为<spanclass="math inline">\(T\)</span>），交双曲线的右支于点<spanclass="math inline">\(P\)</span>，若<spanclass="math inline">\(M\)</span>为<spanclass="math inline">\(FP\)</span>的中点，则<spanclass="math inline">\(|OM| - |MT|=\)</span>（用<spanclass="math inline">\(a,b\)</span>）表示。</p><p>$100. $ 在数列<span class="math inline">\(\{a_n\}\)</span>中，<spanclass="math inline">\(a_1 = 0, a_2 = 6\)</span>，且<spanclass="math inline">\(a_{n+2} = 5a_{n+1} - 6 a_n\)</span>；<br />（1）求<span class="math inline">\(\{a_n\}\)</span>的通项公式；<br />（2）设<span class="math inline">\(m\)</span>是一个正数，无论<spanclass="math inline">\(m\)</span>为何值时，是否都有一个正整数<spanclass="math inline">\(n\)</span>，使<spanclass="math inline">\(\displaystyle \left|\frac{a_{n_1}}{a_b} - 3\right| &lt; m\)</span>恒成立。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pandasecharts使用示例</title>
      <link href="/2021/12/17/pandasecharts%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
      <url>/2021/12/17/pandasecharts%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><ahref="https://github.com/gamersover/pandasecharts">pandasecharts</a>是一款基于pandas和pyecharts的可视化工具，该文档适用于版本&gt;=0.4.1。</p><h4 id="bar柱状图">Bar柱状图</h4><span id="more"></span><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/bar_examples.html" frameBorder="0" width="1080px" height="11300px"></iframe></details><h4 id="bar3d柱状图">Bar3d柱状图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/bar3d_examples.html" frameBorder="0" width="1080px" height="1200px"></iframe></details><h4 id="line折线图">Line折线图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/line_examples.html" frameBorder="0" width="1080px" height="7200px"></iframe></details><h4 id="line3d折线图">Line3d折线图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/line3d_examples.html" frameBorder="0" width="1080px" height="1300px"></iframe></details><h4 id="scatter折线图">Scatter折线图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/scatter_examples.html" frameBorder="0" width="1080px" height="5800px"></iframe></details><h4 id="scatter3d折线图">Scatter3d折线图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/scatter3d_examples.html" frameBorder="0" width="1080px" height="1800px"></iframe></details><h4 id="pie饼图">Pie饼图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/pie_examples.html" frameBorder="0" width="1080px" height="7800px"></iframe></details><h4 id="boxplot箱形图">Boxplot箱形图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/boxplot_examples.html" frameBorder="0" width="1080px" height="4600px"></iframe></details><h4 id="funnel漏斗图">Funnel漏斗图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/funnel_examples.html" frameBorder="0" width="1080px" height="3700px"></iframe></details><h4 id="geo地理图">Geo地理图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/geo_examples.html" frameBorder="0" width="1080px" height="4200px"></iframe></details><h4 id="map地图">Map地图</h4><details><summary>展开</summary><iframe src="https://nbviewer.org/github/gamersover/gamersover.github.io/blob/hexo/source/_ipynotebook_html/map_examples.html" frameBorder="0" width="1080px" height="3700px"></iframe></details>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 可视化 </tag>
            
            <tag> pandasecharts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗篇：死有感</title>
      <link href="/2021/10/05/%E8%AF%97%E7%AF%87%EF%BC%9A%E6%AD%BB%E6%9C%89%E6%84%9F/"/>
      <url>/2021/10/05/%E8%AF%97%E7%AF%87%EF%BC%9A%E6%AD%BB%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <h3 id="死有感">死有感</h3><p>深秋叶落谢花飞，几许忧愁几许悲；<br />好雨清风终散去，夕阳皓月暂轮回。<br />焉无万紫争奇艳，更有千红斗正魁；<br />待到新春初霁后，凭风会自百花归。</p>            <i class="fa fa-quote-right"></i>          </blockquote>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗篇：生有感</title>
      <link href="/2021/08/17/%E8%AF%97%E7%AF%87%EF%BC%9A%E7%94%9F%E6%9C%89%E6%84%9F/"/>
      <url>/2021/08/17/%E8%AF%97%E7%AF%87%EF%BC%9A%E7%94%9F%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">            <i class="fa fa-quote-left"></i>            <h3 id="生有感">生有感</h3><p>魄净七重日，魂安一处沙；<br />平生趋富贵，暮世系荣华。<br />善水出坚木，春泥育毅花；<br />文章传万载，绿叶蔓青崖。</p>            <i class="fa fa-quote-right"></i>          </blockquote>]]></content>
      
      
      <categories>
          
          <category> 文章 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分在几何上的应用一：弧长，旋转曲面的面积与体积</title>
      <link href="/2021/08/11/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9C%A8%E5%87%A0%E4%BD%95%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A81/"/>
      <url>/2021/08/11/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9C%A8%E5%87%A0%E4%BD%95%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A81/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(\mathbb{R}^2\)</span>上的曲线<spanclass="math inline">\(\Gamma\)</span>由极坐标方程<br /><span class="math display">\[    r = r(\theta) \quad (\boldsymbol{\alpha} \le \theta \le\boldsymbol{\beta})\]</span><br />表示，从而由此曲线和射线<br /><span class="math display">\[    \theta = \alpha, \quad \theta = \beta\]</span><br />围城的区域的面积<span class="math inline">\(S\)</span>为<br /><span class="math display">\[    S = \frac{1}{2} \int_{\alpha}^{\beta} r^2 (\theta)\mathrm{d}(\theta)\]</span></p></blockquote><span id="more"></span><p>证：对<span class="math inline">\(\theta\)</span>的变化范围<spanclass="math inline">\([\alpha, \beta]\)</span>作一分割<br /><span class="math display">\[    \alpha = \theta_1 &lt; \theta_2 &lt; \cdots &lt; \theta_n = \beta\]</span><br />任取<span class="math inline">\(\xi_i \in [\theta_{i-1}, \theta_{i}](i=1,2,\cdots,n)\)</span>，从而夹在<span class="math inline">\(\theta =\theta_{i-1}, \theta = \theta_i\)</span>与<span class="math inline">\(r= r(\theta)\)</span>之间的区域的面积，在<spanclass="math inline">\(\Delta \theta_i = \theta_{i} -\theta_{i-1}\)</span>很小时可表示为<br /><span class="math display">\[    \Delta S_i \approx \frac{1}{2} r^2(\theta_{i}) \Delta \theta_i\]</span><br />令<span class="math inline">\(\max \limits_{1 \le i \le n} \Delta\theta_i \to 0\)</span>，得到<br /><span class="math display">\[    S = \frac{1}{2} \int_{\alpha}^{\beta} r^2 (\theta)\mathrm{d}(\theta)\]</span></p><p>Q.E.D.</p><h4 id="引理1">引理1</h4><blockquote><p>设<span class="math inline">\(x(t), y(t), z(t)\)</span>在<spanclass="math inline">\([\alpha, \beta]\)</span>上有连续的导函数，取<spanclass="math inline">\(t\)</span>的一个分割<br /><span class="math display">\[    \pi: \alpha = t_0 &lt; t_1 &lt; \cdots &lt; t_n = \beta\]</span><br />那么有<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^n\sqrt{(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2 +(z^\prime(\zeta_i))^2} \Delta t_i= \int_{\alpha}^{\beta}\sqrt{(x^\prime(t))^2 + (y^\prime(t))^2 + (z^\prime(t))^2} \mathrm{d}t\]</span><br />其中<span class="math inline">\(\xi_i, \eta_i,\zeta_i\)</span>分别为<span class="math inline">\(x, y,z\)</span>函数的值点，即<span class="math inline">\(\xi_i,\eta_i,\zeta_i\in [t_{i-1}, t_i]\)</span>。</p></blockquote><p>证： 由三角不等式<br /><span class="math display">\[    | \Vert \boldsymbol{a} \Vert - \Vert \boldsymbol{b}\Vert|  \le  \Vert \boldsymbol{a} - \boldsymbol{b} \Vert\]</span><br />得<br /><span class="math display">\[    \begin{aligned}    &amp; \left| \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\xi_i))^2 +(z^\prime(\xi_i))^2} - \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2+ (z^\prime(\zeta_i))^2} \right| \\    &amp; \le \sqrt {(y^\prime(\xi_i) - y^\prime(\eta_i))^2 +(z^\prime(\xi_i) - z^\prime(\zeta_i))^2} \\    &amp; \le |y^\prime(\xi_i) - y^\prime(\eta_i)| + |z^\prime(\xi_i) -z^\prime(\zeta_i)|    \end{aligned}\]</span><br />由于<span class="math inline">\(y^\prime(t)\)</span>与<spanclass="math inline">\(z^\prime(t)\)</span>在<spanclass="math inline">\([\alpha,\beta]\)</span>上连续，从而一致连续，因此对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta_1 &gt; 0\)</span>，当<spanclass="math inline">\(\Vert \pi \Vert &lt; \delta_1\)</span>时，<br /><span class="math display">\[    \left\{        \begin{aligned}            |y^\prime(\xi_i) - y^\prime(\eta_i)| &lt;\frac{\varepsilon}{4(\beta - \alpha)} \\            |z^\prime(\xi_i) - z^\prime(\zeta_i)| &lt;\frac{\varepsilon}{4(\beta - \alpha)} \\        \end{aligned}    \right.\]</span><br />对<span class="math inline">\(i=1,2,\cdots,n\)</span>都成立，令<br /><span class="math display">\[    \begin{aligned}    I = \int_{\alpha}^{\beta} \sqrt{(x^\prime(t))^2 + (y^\prime(t))^2 +(z^\prime(t))^2} \mathrm{d}t \\    S = \sum_{i=1}^n \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\xi_i))^2 +(z^\prime(\xi_i))^2} \Delta t_i    \end{aligned}\]</span><br />由积分的定义可知，对上述<spanclass="math inline">\(\varepsilon\)</span>，存在<spanclass="math inline">\(\delta_2 &gt; 0\)</span>，当<spanclass="math inline">\(\Vert \pi \Vert \le \delta_2\)</span>时，有<br /><span class="math display">\[    |S - I| &lt; \frac{\varepsilon}{2}\]</span><br />而不论<span class="math inline">\(\xi_i \in [t_{i-1}, t_i](i=1,2,\cdots,n)\)</span>如何选取，当<span class="math inline">\(\Vert\pi \Vert &lt; \min(\delta_1, \delta_2)\)</span>时，有<br /><span class="math display">\[    \begin{aligned}    &amp; |\sum_{i=1}^n \sqrt {(x^\prime(\xi_i))^2 +(y^\prime(\eta_i))^2 + (z^\prime(\zeta_i))^2} \Delta t_i- I| \\    &amp; \le |\sum_{i=1}^n \sqrt {(x^\prime(\xi_i))^2 +(y^\prime(\eta_i))^2 + (z^\prime(\zeta_i))^2} \Delta t_i - S| + |S - I|\\    &amp; &lt; \sum_{i=1}^n (|y^\prime(\xi_i) - y^\prime(\eta_i)| +|z^\prime(\xi_i) - z^\prime(\zeta_i)|) \Delta t_i +\frac{\varepsilon}{2} \\    &amp; &lt; \left( \frac{\varepsilon}{4(\beta - \alpha)}  +\frac{\varepsilon}{4(\beta - \alpha)} \right) \sum_{i=1}^n \Delta t_i +\frac{\varepsilon}{2} \\    &amp; = \varepsilon    \end{aligned}\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\mathbb{R}^3\)</span>的曲线<spanclass="math inline">\(\Gamma\)</span>的参数方程为<br /><span class="math display">\[    \left\{        \begin{aligned}            x = x(t), \\            y = y(t), \\            z = z(t),        \end{aligned}    \right.    \quad (\alpha \le t \le \beta)\]</span><br />或用向量形式表示为<br /><span class="math display">\[    \boldsymbol{r} = \boldsymbol{r}(t) \quad (\alpha \le t \le \beta)\]</span><br />其中<span class="math inline">\(x(t), y(t), z(t)\)</span>在<spanclass="math inline">\([\alpha, \beta]\)</span>上有连续的导数，点<spanclass="math inline">\(A = \boldsymbol{r}(\alpha)\)</span>与<spanclass="math inline">\(B = \boldsymbol{r}(\beta)\)</span>分别是<spanclass="math inline">\(\Gamma\)</span>的起点与终点。则该曲线的弧长公式为<br /><span class="math display">\[    s(\Gamma) = \int_{\alpha}^{\beta} \sqrt{(x^\prime(t))^2 +(y^\prime(t))^2 + (z^\prime(t))^2} \mathrm{d}t\]</span></p></blockquote><p>证：沿<span class="math inline">\(A\)</span>到<spanclass="math inline">\(B\)</span>的方向在<spanclass="math inline">\(\Gamma\)</span>上取<spanclass="math inline">\(n+1\)</span>个点：<br /><span class="math display">\[    A = A_0, A_1, A_2, \cdots, A_n = B\]</span><br />并把这<span class="math inline">\(n\)</span>条线段之和<spanclass="math inline">\(\sum_{i=1}^n |A_{i-1}A_i|\)</span>作为<spanclass="math inline">\(\Gamma\)</span>弧长的一个近似值，可知当分割点越来越细时，近似值的极限就是弧长。设点<spanclass="math inline">\(A_i\)</span>对应着参数值<spanclass="math inline">\(t_i (i=0,1,2,\cdots,n)\)</span>，则<br /><span class="math display">\[    \alpha = t_0 &lt; t_1 &lt; t_2 &lt; \cdots &lt; t_n = \beta\]</span><br />记为分割<span class="math inline">\(\pi\)</span>，从而<br /><span class="math display">\[    \begin{aligned}    |A_{i-1}A_i| &amp;= \Vert \boldsymbol{r}(t_i) -\boldsymbol{r}(t_{i-1}) \Vert \\    &amp;= \sqrt {((x(t_i) - x(t_{i-1}))^2 + (y(t_i) - y(t_{i-1}))^2 +(z(t_i) - z(t_{i-1}))^2)} \\    &amp;= \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2 +(z^\prime(\zeta_i))^2} \Delta t_i    \end{aligned}\]</span><br />其中<span class="math inline">\(\xi_i,\eta_i, \zeta_i \in (t_{i-1},t_i)\)</span>，又由于<span class="math inline">\(x^\prime, y^\prime,z^\prime\)</span>都是连续函数，所以存在一个常数<spanclass="math inline">\(K\)</span>，使得<br /><span class="math display">\[    |A_{i-1}A_i| \le K \Delta t_i \le K \Vert \pi \Vert\]</span><br />所以<br /><span class="math display">\[    \max \limits_{1 \le i \le n} | A_{i-1}A_i | \le K \Vert \pi \Vert\]</span><br />这表明，将分割<spanclass="math inline">\(\pi\)</span>无限加细，对应的曲线<spanclass="math inline">\(\Gamma\)</span>上的分割也会无限加细，从而<spanclass="math inline">\(\Gamma\)</span>的弧长为<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^n\sqrt{(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2 +(z^\prime(\zeta_i))^2} \Delta t_i\]</span><br />再由<a href="#引理1">引理1</a>可知，弧长<br /><span class="math display">\[    S(\Gamma) = \int_{\alpha}^{\beta} \sqrt {(x^\prime(t))^2 +(y^\prime(t))^2 + (z^\prime(t))^2} \mathrm{d} t\]</span></p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>（1）设<span class="math inline">\(y = f(x) \ge 0\)</span>是区间<spanclass="math inline">\([a,b]\)</span>上的一条连续曲线，让这条曲线绕<spanclass="math inline">\(x\)</span>轴旋转一周，得到的旋转体的体积公式为<br /><span class="math display">\[    V = \pi \int_a^b f^2(x) \mathrm{d} x\]</span><br />（2）设曲线<span class="math inline">\(\Gamma\)</span><br /><span class="math display">\[    x= x(t), y = y(t) \quad (\alpha \le t \le \beta)\]</span><br />是一条在上半平面不自交的<spanclass="math inline">\(C^1\)</span>类曲线，让这条曲线绕<spanclass="math inline">\(Ox\)</span>轴旋转一周，生成的旋转曲面的面积为<br /><span class="math display">\[    S = 2\pi \int_{\alpha}^{\beta} y(t) \sqrt {(x^\prime(t))^2 +(y^\prime(t))^2} \mathrm{d} t\]</span> b</p></blockquote><p>证：（1）作区间<spanclass="math inline">\([a,b]\)</span>的一个分割<br /><span class="math display">\[    \pi: a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b\]</span><br />将旋转体介于平面<span class="math inline">\(x = x_{k-1}, x=x_{k}\)</span>之间的体积记为<spanclass="math inline">\(V_k\)</span>，任取<spanclass="math inline">\(\xi_k \in [x_{k-1}, x_k]\)</span>，则<br /><span class="math display">\[    V_k \approx \pi f^2(\xi_k) \Delta x_k\]</span><br />从而<br /><span class="math display">\[    V = \lim \limits_{\Vert \pi \Vert \to 0} \sum_{k=1}^n \pi f^2(\xi_k)\Delta x_k = \pi \int_a^b f^2(x) \mathrm{d} x\]</span><br />（2）在<span class="math inline">\(\Gamma\)</span>上取<spanclass="math inline">\(n+1\)</span>个点<br /><span class="math display">\[    A_0,A_1,\cdots,A_n\]</span><br />从而对应的参数区间<span class="math inline">\([\alpha,\beta]\)</span>也有分点<br /><span class="math display">\[    \alpha = t_0 &lt; t_1 &lt; \cdots &lt; t_n = \beta\]</span><br />这时曲线上的第<span class="math inline">\(i\)</span>段<spanclass="math inline">\(A_{i-1}A_i\)</span>的弧长可近似为<br /><span class="math display">\[    \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2} \Delta t_i\]</span><br />其中<span class="math inline">\(\xi_i, \eta_i \in [t_{i-1},t_i]\)</span>，由这段曲线弧旋转而成的曲面面积可表示为<br /><span class="math display">\[    \Delta S_i \approx 2 \pi y(\zeta_i) \sqrt {(x^\prime(\xi_i))^2 +(y^\prime(\eta_i))^2} \Delta t_i\]</span><br />其中<span class="math inline">\(\zeta_i \in [t_{i-1},t_i]\)</span>，所以旋转曲面的总面积可表示为<br /><span class="math display">\[    S \approx \sum_{i=1}^n 2\pi y(\zeta_i) \sqrt {(x^\prime(\xi_i))^2 +(y^\prime(\eta_i))^2} \Delta t_i\]</span><br />当<span class="math inline">\(\Vert \pi \Vert \to0\)</span>时，利用类似<a href="#引理1">引理1</a>的证法，可得<br /><span class="math display">\[    S = \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^n 2\piy(\zeta_i) \sqrt {(x^\prime(\xi_i))^2 + (y^\prime(\eta_i))^2} \Delta t_i= 2\pi \int_{\alpha}^{\beta} y(t) \sqrt {(x^\prime(t))^2 +(y^\prime(t))^2} \mathrm{d} t\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 函数积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微积分在几何上的应用二：曲线的切线与曲面的切平面</title>
      <link href="/2021/08/11/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9C%A8%E5%87%A0%E4%BD%95%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A82/"/>
      <url>/2021/08/11/%E5%BE%AE%E7%A7%AF%E5%88%86%E5%9C%A8%E5%87%A0%E4%BD%95%E4%B8%8A%E7%9A%84%E5%BA%94%E7%94%A82/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设空间曲线段<spanclass="math inline">\(\Gamma\)</span>有参数方程<br /><span class="math display">\[    \left\{        \begin{aligned}            &amp; x = x(t), \\            &amp; y = y(t), \\            &amp; z = z(t),        \end{aligned}    \right.    \quad (\alpha \le t \le \beta)\]</span><br />或用向量形式表示为<br /><span class="math display">\[    \boldsymbol{r} = \boldsymbol{r}(t) \quad (\alpha \le t \le \beta)\]</span><br />其中<span class="math inline">\(x(t),y(t),z(t)\)</span>都在区间<spanclass="math inline">\(I = [\alpha,\beta]\)</span>上连续可导，且满足条件<br /><span class="math display">\[    (x^\prime(t))^2 + (y^\prime(t))^2 + (z^\prime(t))^2 \ne 0 \quad(\alpha \le t \le \beta)\]</span><br />称满足这些条件的曲线为光滑曲线。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>设光滑曲线<span class="math inline">\(\Gamma\)</span>上有一点<spanclass="math inline">\(P_0(x(t_0), y(t_0), z(t_0))\)</span>，则曲线<spanclass="math inline">\(\Gamma\)</span>在<spanclass="math inline">\(P_0\)</span>处的切线方程为<br /><span class="math display">\[    \frac{x - x(t_0)}{x^\prime(t_0)} = \frac{y - y(t_0)}{y^(t_0)} =\frac{z - z(t_0)}{z^\prime(t_0))}\]</span></p></blockquote><p>证：切线方向的一个向量为<br /><span class="math display">\[    \boldsymbol{r}^\prime(t) = \lim \limits_{t \to 0}\frac{\boldsymbol{r}(t) - \boldsymbol{r}(t_0)}{t - t_0} =(x^\prime(t_0), y^\prime(t_0), z^\prime(t_0))\]</span><br />称为曲线<span class="math inline">\(\Gamma\)</span>在点<spanclass="math inline">\(P_0\)</span>出的切向量，又由于切线过点<spanclass="math inline">\(P_0\)</span>，所以切线方程为<br /><span class="math display">\[    \frac{x - x(t_0)}{x^\prime(t_0)} = \frac{y - y(t_0)}{y^\prime(t_0)}= \frac{z - z(t_0)}{z^\prime(t_0))}\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>光滑曲线的弧长<spanclass="math inline">\(s\)</span>也可以作为曲线的参数，即<spanclass="math inline">\(\boldsymbol{r} =\boldsymbol{r}(s)\)</span>，且有<br /><span class="math display">\[    \Vert \boldsymbol{r}^\prime(s) \Vert = 1\]</span></p></blockquote><p>证明：由<ahref="https://gamersover.github.io/2021/08/11/微积分在几何上的应用1/#定理2">微积分在几何上的应用一的定理2</a>可知，在曲线参数为<spanclass="math inline">\(t \in [\alpha, \beta]\)</span>时，弧长<br /><span class="math display">\[    s(\Gamma) = \int_\alpha^\beta \Vert \boldsymbol{r}^{\prime}(t) \Vert\mathrm{d} t\]</span><br />记函数<span class="math inline">\(s(t)\)</span>为从曲线起点<spanclass="math inline">\(\boldsymbol{r}(\alpha)\)</span>沿着曲线到曲线上任意一点<spanclass="math inline">\(\boldsymbol{r}(t)\)</span>这一段弧长，则<br /><span class="math display">\[    s(t) = \int_\alpha^t \Vert \boldsymbol{r}^\prime(\tau)\Vert\mathrm{d} \tau \quad (\alpha \le t \le \beta)\]</span><br />而<span class="math inline">\(s(t)\)</span>是一个变上限积分，将其对<spanclass="math inline">\(t\)</span>求导得<br /><span class="math display">\[    \frac{\partial s}{\partial t} = \Vert \boldsymbol{r}^\prime(t) \Vert&gt; 0 \tag {1}\]</span><br />这表明<span class="math inline">\(s(t)\)</span>是关于<spanclass="math inline">\(t\)</span>的严格递增函数，意味着可以将<spanclass="math inline">\(t\)</span>作为<spanclass="math inline">\(s\)</span>得函数反解出来得到<spanclass="math inline">\(t =t(s)\)</span>，且这也是一个严格递增函数，所以<spanclass="math inline">\(s\)</span>也可以作为弧长的参数，映射关系为<br /><span class="math display">\[    s \rightarrow t \rightarrow \boldsymbol{r}\]</span><br />记以弧长<span class="math inline">\(s\)</span>为参数的曲线方程<spanclass="math inline">\(\boldsymbol{r} =\boldsymbol{r}(s)\)</span>，由式<spanclass="math inline">\((1)\)</span>可知<br /><span class="math display">\[   1 = \frac{\partial s}{\partial s} = \Vert \boldsymbol{r}^\prime(s)\Vert\]</span></p><p>Q.E.D.</p><h4 id="定义2">定义2</h4><blockquote><p>设<span class="math inline">\(\Gamma: \boldsymbol{r} =\boldsymbol{r}(t)(\alpha \le t \le \beta)\)</span>是一段光滑曲线，<spanclass="math inline">\(\boldsymbol{r}^\prime(t_0)\)</span>与<spanclass="math inline">\(\boldsymbol{r}^\prime(t_0 + \Deltat)\)</span>之间的夹角记为<span class="math inline">\(\Delta\theta\)</span>，<spanclass="math inline">\(\boldsymbol{r}(t_0)\)</span>与<spanclass="math inline">\(\boldsymbol{r}(t_0 + \Deltat)\)</span>之间的弧长记为<span class="math inline">\(\Deltas\)</span>，如果<span class="math inline">\(\lim \limits_{\Delta t \to0} |\Delta \theta / \Delta s|\)</span>存在，就称此极限为<spanclass="math inline">\(\Gamma\)</span>在<spanclass="math inline">\(\boldsymbol{r}(t_0)\)</span>处的曲率，记为<br /><span class="math display">\[    k(t_0) = \lim \limits_{\Delta t \to 0} \left|\frac{\Delta\theta}{\Delta s} \right|\]</span></p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设曲线<span class="math inline">\(\Gamma: \boldsymbol{r} =\boldsymbol{r}(s)(s\)</span>是弧长参数<spanclass="math inline">\()\)</span>的每一点处有一个单位向量<spanclass="math inline">\(\boldsymbol{s}\)</span>，记$ (s+s)<spanclass="math inline">\(和\)</span>(s)<spanclass="math inline">\(之间的夹角为\)</span><spanclass="math inline">\(，如果\)</span>(s)$可导，那么<br /><span class="math display">\[    \Vert \boldsymbol{a}^\prime(s) \Vert = \lim \limits_{\Delta s \to 0}\left| \frac{\Delta \theta}{\Delta s} \right|\]</span></p></blockquote><p>证明：由于<br /><span class="math display">\[    \begin{aligned}    \Vert \boldsymbol{a}^\prime(s) \Vert &amp; = \left\Vert \lim\limits_{\Delta s \to 0} \frac{\boldsymbol{a}(s + \Delta s) -\boldsymbol{a}(s)}{\Delta s} \right\Vert \\    &amp; = \lim \limits_{\Delta s \to 0} \frac{\Vert \boldsymbol{a}(s +\Delta s) - \boldsymbol{a}(s) \Vert}{\Vert \Delta s \Vert} \\    &amp;= \lim \limits_{\Delta s \to 0} \left| \frac{2 \sin (\Delta\theta / 2)}{\Delta s} \right| = \lim \limits_{\Delta s \to 0} \left|\frac{ \sin (\Delta \theta / 2)}{\Delta \theta / 2} \right| \left|    \frac{2 \Delta \theta}{2\Delta s} \right| \\    &amp; = \lim \limits_{\Delta s \to 0} \left| \frac{\Delta\theta}{\Delta s} \right|    \end{aligned}\]</span></p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设<span class="math inline">\(\Gamma: \boldsymbol{r} =\boldsymbol{r}(s)\)</span>是一条以弧长<spanclass="math inline">\(s\)</span>为参数的光滑曲线，且<spanclass="math inline">\(\boldsymbol{r}^{\prime\prime}(s)\)</span>存在，那么它的曲率为<br /><span class="math display">\[    k(s) = \Vert \boldsymbol{r}^{\prime\prime}(s) \Vert\]</span></p></blockquote><p>证明：由<ahref="https://gamersover.github.io/2021/08/11/微积分在几何上的应用2/#定理2">定理2</a>可知，曲线在<spanclass="math inline">\(s\)</span>处的切线向量为单位向量，令<spanclass="math inline">\(\boldsymbol{a}(s) =\boldsymbol{r}^\prime(s)\)</span>，此时再由<ahref="https://gamersover.github.io/2021/08/11/微积分在几何上的应用2/#定理3">定理3</a>可知，<br /><span class="math display">\[    k(s) = \lim \limits_{\Delta s \to 0} \left| \frac{\Delta\theta}{\Delta s} \right| = \Vert \boldsymbol{r}^{\prime\prime}(s) \Vert\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 切线 </tag>
            
            <tag> 切平面 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分十二：$n$重积分</title>
      <link href="/2021/08/02/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8612/"/>
      <url>/2021/08/02/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8612/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>定义<span class="math inline">\(f: I \to\mathbb{R}\)</span>，其中<span class="math inline">\(I\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的一个闭长方体，即<spanclass="math inline">\(I = I_1 \times I_2 \times \cdotsI_n\)</span>，其中<span class="math inline">\(i_i=[a_i, b_i](i=1,2,\cdots,n)\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>中的有界闭区间。<spanclass="math inline">\(I\)</span>的<spanclass="math inline">\(n\)</span>维体积定义为<br /><span class="math display">\[    \mu(I) = \prod_{i=1}^n (b_i - a_i)\]</span><br />用平行于各个坐标平面的<spanclass="math inline">\(n\)</span>组超平面对<spanclass="math inline">\(I\)</span>进行划分，得到有限多个小的子长方体，不妨设为<spanclass="math inline">\(k\)</span>个，这称为<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi\)</span>，这时可以定义Riemann和<br /><span class="math display">\[    \sum_{i=1}^k f(\boldsymbol{\xi_i}) \mu(I_i)\]</span><br />其中<span class="math inline">\(\boldsymbol{\xi_i} \inI_i\)</span>，<spanclass="math inline">\(\mu(I_i)\)</span>表示子长方体<spanclass="math inline">\(I_i\)</span>的体积。</p></blockquote><span id="more"></span><p>有了定义1，仿照二重积分，三重积分的推理方法，可以定义和证明相似的定理。比如可以记<spanclass="math inline">\(\Vert \pi\Vert\)</span>为这些子长方体的对角线的长度的最大值，若<spanclass="math inline">\(\Vert \pi \Vert \to0\)</span>时，上式的Riemann和极限存在且不依赖于子长方体中值点的选取，则称该极限为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的积分，记作<br /><span class="math display">\[    \idotsint \limits_I f(x_1, x_2, \cdots, x_n) \mathrm{d} x_1\mathrm{d} x_2 \cdots \mathrm{d} x_n\]</span><br />也记为<br /><span class="math display">\[    \int_I f \mathrm{d} \mu\]</span><br />这时称<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积，而且若<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>可积，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上必有界。包括上和，下和以及可积性的充分必要条件都与前面二重积分的结论一样，以及<spanclass="math inline">\(I\)</span>上的<spanclass="math inline">\(n\)</span>重积分计算，也可以化为累次积分来进行，这时共有<spanclass="math inline">\(n!\)</span>中不同的顺序。关于<spanclass="math inline">\(n\)</span>重积分的Lebesgue定理，也可以引入零测集与零体积集的概念，可以证明：一个有界点集有体积的充分必要条件是它的边界是零体积集。同理，<spanclass="math inline">\(n\)</span>重积分也可以化为一个<spanclass="math inline">\(n-1\)</span>重积分和一个定积分来计算。</p><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(V \subset\mathbb{R}^n\)</span>是有体积的有界闭集，有界函数<spanclass="math inline">\(f: V \to \mathbb{R}\)</span>连续，<br />（1）如果<br /><span class="math inline">\(V = \{ \boldsymbol{x} = (x_1,x_2,\cdots,x_n) \in \mathbb{R}^n \}\)</span>，当<spanclass="math inline">\((x_1, x_2, \cdots, x_{n-1}） \in D \subset\mathbb{R}^{n-1}\)</span>时，<br /><span class="math display">\[    \varphi_1(x_1, x_2, \cdots, x_{n-1}) \le x_n \le \varphi_2(x_1, x_2,\cdots,x_{n-1})\]</span><br />其中<span class="math inline">\(\varphi_1, \varphi_2\)</span>是<spanclass="math inline">\(D\)</span>上的连续函数，那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \idotsint \limits_D \mathrm{d} x_1\mathrm{d} x_2 \mathrm{d} x_{n-1} \int_{\varphi_1(x_1, x_2, \cdots,x_{n-1})}^{\varphi_2(x_1, x_2, \cdots, x_{n-1})} f(x_1,x_2,\cdots,x_{n-1}, x_n) \mathrm{d} x_n\]</span><br />（2）如果<br /><span class="math inline">\(V = \{ \boldsymbol{x} = (x_1, x_2, \cdots,x_{n}) \in \mathbb{R}^n\}\)</span>，当<span class="math inline">\(x_n\in [a, b]\)</span>时,<br /><span class="math display">\[    (x_1,x_2,\cdots, x_{n-1}) \in D_{x_n} \in \mathbb{R}^{n-1}\]</span><br />那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \int_a^b \mathrm{d} x_n \idotsint\limits_{D_{x_n}} f(x_1, x_2,\cdots,x_n) \mathrm{d} x_1 \mathrm{d} x_2\cdots \mathrm{d} x_{n-1}\]</span><br />（3）当然，也可把<spanclass="math inline">\(n\)</span>重积分化成一个<spanclass="math inline">\(k (1 \le k &lt; n)\)</span>重积分与一个<spanclass="math inline">\(n-k\)</span>重积分来计算，即当<spanclass="math inline">\((x_{k+1}, \cdots, x_n) \in D_1 \subset\mathbb{R}^{n-k}\)</span>时，<br /><span class="math display">\[    (x_1, x_2, \cdots, x_{k}) \in D_2 \subset \mathbb{R}^{k}\]</span><br />那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \overbrace{\idotsint \limits_{D_1}}^{n-k\text{个}} \mathrm{d} x_{k+1} \cdots \mathrm{d}x_n  \overbrace{\idotsint \limits_{D_2}}^{k \text{个}} f(x_1,x_2,\cdots,x_n) \mathrm{d} x_{1} \cdots \mathrm{d} x_k\]</span></p></blockquote><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\Omega\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的开集，<spanclass="math inline">\(\Delta \subset \Omega\)</span>有体积，映射<spanclass="math inline">\(\boldsymbol{\varphi}: x_i =x_i(u_1,u_2,\cdots,u_n) (i=1,2,\cdots,n)\)</span>在<spanclass="math inline">\(\Delta\)</span>上是正则的，那么对<spanclass="math inline">\(\boldsymbol{\varphi}(\Delta)\)</span>上的连续函数<spanclass="math inline">\(\boldsymbol{F}\)</span>，有<br /><span class="math display">\[    \idotsint \limits_{\boldsymbol{\varphi}(\Delta)} \boldsymbol{F}(x_1,x_2, \cdots,x_n) \mathrm{d} x_1 \mathrm{d} x_2 \cdots \mathrm{d} x_n =\idotsint \limits_{\Delta} \boldsymbol{F}(x_1(u_1,\cdots,u_n), \cdots,x_n(u_1,\cdots,u_n)) \left|        \frac{\partial (x_1, \cdots,x_n)}{\partial (u_1, \cdots, u_n)}    \right| \mathrm{d} u_1 \cdots \mathrm{d} u_n\]</span></p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>令映射<br /><span class="math display">\[    \left\{        \begin{matrix}        x_1 = &amp; r \cos \theta_1,  \\        x_2 = &amp; r \sin \theta_1 \cos \theta_2, \\        x_3 = &amp; r \sin \theta_1 \sin \theta_2 \cos \theta_2, \\        \cdots\\        x_{n-1} = &amp; r \sin \theta_1 \sin \theta_2 \cdots r \sin\theta_{n-2} \cos \theta_{n-1} \\        x_n = &amp; r \sin \theta_1 \sin \theta_2 \cdots \sin\theta_{n-2} \sin \theta_{n-1}        \end{matrix}    \right.\]</span><br />称为<spanclass="math inline">\(n\)</span>维球坐标变换，改变换将有界集<spanclass="math inline">\(\Delta\)</span>映射到<spanclass="math inline">\(V\)</span>，则<br /><span class="math display">\[\int_V F(x_1,\cdots, x_n) \mathrm{d} \mu = \idotsint \limits_{\Delta}\boldsymbol{F}(\theta_1, \cdots, \theta_n) r^{n-1} \sin^{n-2} \theta_1\sin ^{n-3} \theta_2 \cdots \sin \theta_{n-2} \mathrm{d} \theta_1 \cdots\mathrm{d} \theta_n\]</span></p></blockquote><p>证：关键需要证明<br /><span class="math display">\[    \frac{\partial (x_1, x_2, \cdots, x_n)}{\partial (r, \theta_1,\cdots, \theta_{n-1})} = r^{n-1} \sin^{n-2} \theta_1 \sin ^{n-3}\theta_2 \cdots \sin \theta_{n-2}\]</span><br />这时考虑方程组<br /><span class="math display">\[    \left\{        \begin{matrix}        F_1 = &amp; r^2 - (x_1^2 + x_2^2 + \cdots + x_n^2) = 0 \\        F_2 = &amp; r^2 \sin^2 \theta_1 - (x_2^2 + \cdots + x_n^2) = 0\\        F_3 = &amp; r^2 \sin^2 \theta_1 \sin^2 \theta_2 - (x_3^2 +\cdots + x_n^2) = 0 \\        \cdots \\        F_n = &amp; r^2 \sin^2 \theta_1 \cdots \sin^ \theta_{n-1} -x_n^2 = 0        \end{matrix}    \right. \tag {1}\]</span><br />令<span class="math inline">\(\boldsymbol{u} = (r, \theta_1, \cdots,\theta_{n-1}), \boldsymbol{x} = (x_1, x_2, \cdots,x_n)\)</span>，则根据<ahref="https://gamersover.github.io/2021/04/13/函数导数10#定理3：隐映射定理">隐映射定理</a>可知<br /><span class="math display">\[    \left(\begin{matrix}    \frac{\partial r}{\partial \theta_1} &amp; \cdots &amp;\frac{\partial x_1}{\partial \theta_{n-1}} \\    \vdots &amp; &amp; \vdots \\    \frac{x_n}{\partial r} &amp; \cdots &amp; \frac{x_n}{\partial\theta_{n-1}}    \end{matrix} \right) = - (J_{\boldsymbol{x}}F(\boldsymbol{x},\boldsymbol{u}))^{-1} J_{\boldsymbol{u}}F(\boldsymbol{x},\boldsymbol{u})\]</span><br />两边取行列式即得<br /><span class="math display">\[    \frac{\partial (x_1, x_2, \cdots, x_n)}{\partial (r, \theta_1,\cdots, \theta_{n-1})} = (-1)^n \frac{\detJ_{\boldsymbol{u}}F(\boldsymbol{x}, \boldsymbol{u})}{\detJ_{x}F(\boldsymbol{x}, \boldsymbol{u})}\]</span><br />通过方程组(1)可以求出<br /><span class="math display">\[    \begin{aligned}    &amp;\det J_{\boldsymbol{u}}F(\boldsymbol{x}, \boldsymbol{u}) = 2^nr^{2n-1} \sin^{2n-3} \theta_1 \cos \theta_1 \sin^{2n-5} \theta_2 \cos\theta_2 \cdots \sin \theta_{n-1} \cos \theta_{n-1} \\    &amp;\det J_{\boldsymbol{x}} F(\boldsymbol{x}, \boldsymbol{u}) =(-1)^n 2^n r^n \sin^{n-1} \theta_1  \cos \theta_1 \sin^{n-2} \theta_2\cos \theta_2 \cdots \sin \theta_{n-1} \cos \theta_{n-1}    \end{aligned}\]</span><br />所以<br /><span class="math display">\[\frac{\partial (x_1, x_2, \cdots, x_n)}{\partial (r, \theta_1, \cdots,\theta_{n-1})} = r^{n-1} \sin^{n-2} \theta_1 \sin ^{n-3} \theta_2 \cdots\sin \theta_{n-2}\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> n重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分十一：三重积分</title>
      <link href="/2021/07/29/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8611/"/>
      <url>/2021/07/29/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8611/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>定义<span class="math inline">\(f: I \to\mathbb{R}\)</span>，其中<span class="math inline">\(I\)</span>是<spanclass="math inline">\(\mathbb{R}^3\)</span>中的一个有限长方体，即<spanclass="math inline">\(I = I_1 \times I_2 \times I_3\)</span>，其中<spanclass="math inline">\(i_i=[a_i, b_i] (i=1,2,3)\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>中的有界闭区间。长方体<spanclass="math inline">\(I\)</span>的体积定义为<br /><span class="math display">\[    \mu(I) = (b_1 - a_1)(b_2 - a_2)(b_3 - a_3)\]</span><br />用平行于三个坐标平面的三组平面对<spanclass="math inline">\(I\)</span>进行划分，得到有限多个小的长方体，不妨设为<spanclass="math inline">\(k\)</span>个，这称为<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi\)</span>，这时可以定义Riemann和<br /><span class="math display">\[    \sum_{i=1}^k f(\boldsymbol{\xi_i}) \mu(I_i)\]</span><br />其中<span class="math inline">\(\boldsymbol{\xi_i} \inI_i\)</span>，<spanclass="math inline">\(\mu(I_i)\)</span>表示子长方体<spanclass="math inline">\(I_i\)</span>的体积。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>记<span class="math inline">\(\Vert \pi\Vert\)</span>为小长方体对角线的最大者，称为分割<spanclass="math inline">\(\Vert \pi \Vert\)</span>的宽度，在<spanclass="math inline">\(\Vert \pi \Vert \to 0\)</span>对<ahref="#定义1">定义1</a>中的Riemann和取极限，如果该极限的存在性和数值不依赖与小长方体中值点的选择，则这个极限值就称为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的积分，记作<br /><span class="math display">\[    \iiint \nolimits_I f(x,y,z) \mathrm{d} x \mathrm{d} y \mathrm{d} z\]</span><br />或<br /><span class="math display">\[    \int_I f \mathrm{d} \mu\]</span><br />仿照二重积分的方法，可以依次定义上和，下和，并且可以得到关于可积充分必要条件的相同结论；三重积分的累次积分也同样可以证明。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积，那么<spanclass="math inline">\(f\)</span>必在<spanclass="math inline">\(I\)</span>上有界。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/14/函数积分3#定理1">函数积分三的定理1</a>证明方法一样。</p><p>Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>点集<span class="math inline">\(B \subset\mathbb{R}^3\)</span>称为零测集（零面积集），是指对任何的<spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在可数（有限）个长方体<spanclass="math inline">\(J_i\)</span>，使得<br /><span class="math display">\[    \bigcup_{i} J_i \subset B, \quad \sum_{i} \mu(J_i) &lt; \varepsilon\]</span></p></blockquote><h4 id="定理2lebesgue">定理2：Lebesgue</h4><blockquote><p>设长方体<span class="math inline">\(I \subset \mathbb{R}^3, f \to\mathbb{R}\)</span>，则积分<span class="math inline">\(\displaystyle\int_I f \mathrm{d} \mu\)</span>存在的充分必要条件是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的间断点集为零测集。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/06/29/函数积分8#定理7：Lebesgue">函数积分八的定理7</a>证明方法一致。</p><p>Q.E.D</p><h4 id="定义4">定义4</h4><blockquote><p>设有界点集<span class="math inline">\(B \subset \mathbb{R}^3, f: B\to \mathbb{R}\)</span>，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上的积分定义与<ahref="https://gamersover.github.io/2021/07/13/函数积分9#定义2">函数积分九的定义2</a>完全一致，也记为<br /><span class="math display">\[    \int_B f \mathrm{d} \mu\]</span><br />同样可以定义<span class="math inline">\(B\)</span>的面积为<br /><span class="math display">\[    \mu(B) = \int_B 1 \mathrm{d} \mu\]</span><br />定义一样，相关结论也与二重积分一样。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p><span class="math inline">\(\mathbb{R}^3\)</span>上的有界点集<spanclass="math inline">\(B\)</span>为零体积集当且仅当<spanclass="math inline">\(\mu(B) = 0\)</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/07/13/函数积分9#定理5">函数积分九的定理5</a>的证明方法一致。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设有界集<span class="math inline">\(B \subset\mathbb{R}^3\)</span>，则<spanclass="math inline">\(B\)</span>有面积当且仅当<spanclass="math inline">\(B\)</span>的边界<spanclass="math inline">\(\partial B\)</span>是一零面积集。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/07/13/函数积分9#定理6">函数积分九的定理6</a>的证明方法一致。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设有界集<span class="math inline">\(V \subset\mathbb{R}^3\)</span>有体积，有界函数<span class="math inline">\(f: V\to \mathbb{R}\)</span>连续<br />（1）设<span class="math inline">\(V\)</span>在<spanclass="math inline">\(xy\)</span>平面上的垂直投影为<spanclass="math inline">\(D\)</span>，且当<span class="math inline">\((x, y)\in D\)</span>时，过这一点且垂直于<spanclass="math inline">\(D\)</span>的直线与<spanclass="math inline">\(V\)</span>交成一个区间<spanclass="math inline">\([\varphi_1(x, y), \varphi_2(x,y)]\)</span>，那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \iint_D \mathrm{d}x \mathrm{d}y\int_{\varphi_1(x, y)}^{\varphi_2(x, y)} f(x, y, z) \mathrm{z}\]</span><br />（2）设<span class="math inline">\(V\)</span>在<spanclass="math inline">\(z\)</span>轴上的垂直投影为区间<spanclass="math inline">\(J\)</span>，且当<span class="math inline">\(z \inJ\)</span>时，通过点<span class="math inline">\((0, 0,z)\)</span>又垂直于<span class="math inline">\(z\)</span>轴的平面同<spanclass="math inline">\(V\)</span>交成的图形在<spanclass="math inline">\(xy\)</span>平面上的垂直投影是易有面积的点集<spanclass="math inline">\(D_z\)</span>，那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \int_J \mathrm{d} z \iint_{D_z} f(x, y, z)\mathrm{d}x \mathrm{d} y\]</span></p></blockquote><p>证：可知<span class="math inline">\(f\)</span>在<spanclass="math inline">\(V\)</span>上可积，作<span class="math inline">\(I= I_1 \times I_2 \times I_3 \supset V\)</span>，其中<spanclass="math inline">\(I_1, I_2, I_3\)</span>都是<spanclass="math inline">\(\mathbb{R}\)</span>中的区间，令<br /><span class="math display">\[    f_V(\boldsymbol{p}) = \left\{ \begin{aligned}    &amp; f(\boldsymbol{p}), \quad &amp; \boldsymbol{p} \in V \\    &amp; 0, \quad &amp; \boldsymbol{p} \notin V    \end{aligned}    \right.\]</span><br />那么<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \int_I f_V \mathrm{d} \mu\]</span><br />（1）当<span class="math inline">\((x, y) \in D(x,y)\)</span>时，关于<span class="math inline">\(z\)</span>的函数<spanclass="math inline">\(f(x, y, z)\)</span>在区间<spanclass="math inline">\([\varphi_1(x, y), \varphi_2(x,y)]\)</span>上连续，从而是可积的，所以有<br /><span class="math display">\[    \int_{I_3} f_V (x, y, z) \mathrm{d} z = \int_{\varphi_1(x,y)}^{\varphi_2(x, y)} f_V(x, y, z) \mathrm{d} z\]</span><br />而当<span class="math inline">\((x,y) \notin D\)</span>时，<spanclass="math inline">\(f_V(x, y, z) = 0\)</span>，这时<spanclass="math inline">\(\displaystyle \int_{I_3} f_V(x, y, z) =0\)</span>，所以<br /><span class="math display">\[    \int_I f \mathrm{d} \mu = \int_I f_V \mathrm{d} \mu = \iint\limits_{I_1 \times I_2} \mathrm{d} x \mathrm{d} y \int_{I_3} f_V (x, y,z) \mathrm{d} z = \iint \limits_{I_1 \times I_2} \mathrm{d} x \mathrm{d}y \int_{\varphi_1(x, y)}^{\varphi_2(x, y)} f(x, y, z) \mathrm{d} z\]</span><br />（2）当<span class="math inline">\(z \in J\)</span>时，<spanclass="math inline">\(D_z \in I_1 \times I_2\)</span>且<spanclass="math inline">\(\mu(\partial D_z) = 0\)</span>，而关于<spanclass="math inline">\(x,y\)</span>的函数<spanclass="math inline">\(f(x,y,z)\)</span>在<spanclass="math inline">\(D_z\)</span>上有界连续，所以<spanclass="math inline">\(f(x,y,z)\)</span>在<spanclass="math inline">\(D_z\)</span>上可积，所以有<br /><span class="math display">\[    \iint \limits_{I_1 \times I_2} f_V(x, y, z) \mathrm{d} x \mathrm{d}y = \iint \limits_{D_z} f(x, y, z) \mathrm{d} x \mathrm{d} y\]</span><br />当<span class="math inline">\(z \notin J\)</span>时，<spanclass="math inline">\(f_V(x, y, z) = 0\)</span>，此时<br /><span class="math display">\[    \iint \limits_{I_1 \times I_2} f_V(x, y, z) \mathrm{d} x \mathrm{d}y = 0\]</span><br />从而<br /><span class="math display">\[    \int_V f \mathrm{d} \mu = \int_I f_V \mathrm{d} \mu = \int_{I_3}\mathrm{d}z \iint \limits_{I_1 \times I_2} f_V(x, y, z) \mathrm{d} x\mathrm{d} y = \int_{I_3} \mathrm{d}z \iint \limits_{D_z} f(x, y, z)\mathrm{d} x \mathrm{d} y\]</span></p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设有界的闭区域<span class="math inline">\(D \subset\mathbb{R}^3\)</span>有体积，函数<span class="math inline">\(F: D \to\mathbb{R}\)</span>连续，映射<br /><span class="math display">\[    \boldsymbol{\varphi}: \left\{        \begin{aligned}            x = x(u, v, w), \\            y = y(u, v, w), \\            z = z(u, v, w)        \end{aligned}    \right.    \quad ((u, v, w) \in \Delta)\]</span><br />是从<span class="math inline">\(\Delta\)</span>到<spanclass="math inline">\(D\)</span>上的正则映射，即<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>将<spanclass="math inline">\(\Delta\)</span>一对一地映射成<spanclass="math inline">\(D\)</span>，<spanclass="math inline">\(\boldsymbol{\varphi} \inC^1(\Delta)\)</span>，并且在<spanclass="math inline">\(\Delta\)</span>上，<br /><span class="math display">\[    \det J\boldsymbol{\varphi} = \frac{\partial(x, y, z)}{\partial(u, v,w)} = \left| \begin{matrix}    \frac{\partial x}{\partial u} \quad \frac{\partial x}{\partial v}\quad \frac{\partial x}{\partial w} \\    \frac{\partial y}{\partial u} \quad \frac{\partial y}{\partial v}\quad \frac{\partial y}{\partial w} \\    \frac{\partial z}{\partial u} \quad \frac{\partial z}{\partial v}\quad \frac{\partial z}{\partial w}    \end{matrix} \right| \ne 0\]</span><br />则有<br /><span class="math display">\[    \int_{\boldsymbol{\varphi}(\Delta)} F \mathrm{d} \mu = \int_{\Delta}F \circ \boldsymbol{\varphi} |\det J \boldsymbol{\varphi}| \mathrm{d}\mu\]</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/07/19/函数积分10/#定理6">函数积分十的定理6</a>证明几乎一样。</p><p>Q.E.D.</p><h4 id="定理7球坐标换元公式">定理7：球坐标换元公式</h4><blockquote><p>令映射<br /><span class="math display">\[    \boldsymbol{\varphi} = \left\{        \begin{matrix}        x &amp;= &amp;r \sin \theta \cos \varphi,  \\        y &amp;= &amp;r \sin \theta \sin \varphi, \\        z &amp;=&amp; r \cos \theta        \end{matrix}    \right.    \quad (r, \theta, \varphi) \in \Delta\]</span><br />则<br /><span class="math display">\[    \int_{\boldsymbol{\varphi}(\Delta)} F \mathrm{d} \mu = \iiint\limits_{\Delta} F \circ \boldsymbol{\varphi} r^2 \sin \theta \mathrm{d}r \mathrm{d} \theta \mathrm{d} \varphi\]</span></p></blockquote><p>证： 由于<br /><span class="math display">\[    \frac{\partial(x, y, z)}{\partial(r, \theta, \varphi)} = r^2 \sin\theta\]</span><br />再由<a href="#定理6">定理6</a>可证。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 三重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分十：二重积分的计算</title>
      <link href="/2021/07/19/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8610/"/>
      <url>/2021/07/19/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%8610/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1">定理1</h4><blockquote><p>如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I = [a,b] \times[c,d]\)</span>上可积，那么单变量函数<spanclass="math inline">\(\displaystyle \varphi(x) = \underline \int_c^df(x, y) \mathrm{d} y\)</span>和<span class="math inline">\(\displaystyle\psi(x) = \overline \int_c^d f(x, y) \mathrm{d} y\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上可积，且<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_a^b \varphi(x) \mathrm{d} x =\int_a^b \psi(x) \mathrm{d} x\]</span></p></blockquote><span id="more"></span><p>证：分别对<span class="math inline">\([a,b]\)</span>和<spanclass="math inline">\([c,d]\)</span>的分割<br /><span class="math display">\[    \begin{aligned}    \pi_x: a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b, \\    \pi_y: c = y_0 &lt; y_1 &lt; \cdots &lt; y_m = d,    \end{aligned}\]</span><br />令<br /><span class="math display">\[    \begin{aligned}        &amp; I_i = [x_{i-1}, x_i] \quad (i=1,2,\cdots,n) \\        &amp; J_j = [y_{j-1}, y_j] \quad (j=1,2,\cdots,m)    \end{aligned}\]</span><br />则子矩形<br /><span class="math display">\[    I_i \times I_j \quad (i=1,2,\cdots,n; j=1,2,\cdots,m)\]</span><br />形成了矩形<span class="math inline">\(I\)</span>的分割<spanclass="math inline">\(\pi = \pi_x \times \pi_y\)</span>。令<spanclass="math inline">\(\displaystyle A = \int_I f \mathrm{d}\sigma\)</span>，由积分存在的定义可知，对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，当<spanclass="math inline">\(I\)</span>的分割<spanclass="math inline">\(\pi\)</span>满足<span class="math inline">\(\Vert\pi \Vert &lt; \delta\)</span>时，必有<br /><span class="math display">\[    A - \varepsilon &lt; \sum_{i=1}^n \sum_{j=1}^m f(\xi_i, \eta_j)\Delta x_i \Delta y_j &lt; A + \varepsilon\]</span><br />其中<span class="math inline">\(\xi_i \in I_i, \eta_j \in J_j(i=1,2,\cdots,n;j=1,2,\cdots,m)\)</span>，现取分割<spanclass="math inline">\(\pi_x, \pi_y\)</span>满足<spanclass="math inline">\(\Vert \pi_x \Vert &lt; \delta / \sqrt 2, \Vert\pi_y \Vert &lt; \delta / \sqrt 2\)</span>，那么<spanclass="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>，从而上式成立，所以有<br /><span class="math display">\[    \begin{aligned}    A - \varepsilon &amp;\le \sum_{i=1}^n \sum_{j=1}^m \inf f(\xi_i,\eta_j) \Delta x_i \Delta y_j  \\    &amp; \le \sum_{i=1}^n \sum_{j=1}^m \sup f(\xi_i, \eta_j) \Delta x_i\Delta y_j \\    &amp; \le A + \varepsilon    \end{aligned}\]</span><br />而<span class="math inline">\(\displaystyle \sum_{j=1}^m \inf f(\xi_i,\eta_j) \Delta y_j\)</span>表示函数<spanclass="math inline">\(f(\xi_i)\)</span>在<spanclass="math inline">\([c,d]\)</span>上的下和，所以<br /><span class="math display">\[    \sum_{j=1}^m \inf f(\xi_i, \eta_j) \Delta y_j \le \underline\int_c^d f(\xi_i, y) \mathrm{d} y = \varphi(\xi_i)\]</span><br />同理<br /><span class="math display">\[    \sum_{j=1}^m \sup f(\xi_i, \eta_j) \Delta y_j \le \overline \int_c^df(\xi_i, y) \mathrm{d} y = \psi(\xi_i)\]</span><br />从而<br /><span class="math display">\[    A - \varepsilon \le \sum_{i=1}^n \varphi(\xi_i) \Delta x_i \le\sum_{i=1}^n \psi(\xi_i) \Delta x_i \le A + \varepsilon\]</span><br />即<br /><span class="math display">\[    \lim_{\Vert \pi_x \Vert \to 0} \sum_{i=1}^n \varphi(\xi_i) \Deltax_i = \lim_{\Vert \pi \Vert \to 0} \sum_{i=1}^n \psi(\xi_i) \Delta x_i =A\]</span><br />成立</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I = [a,b] \times [c,d]\)</span>上可积，如果对每一个<span class="math inline">\(x \in[a,b]\)</span>，函数<span class="math inline">\(f(x, y)\)</span>在<spanclass="math inline">\([c, d]\)</span>上可积，则<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_a^b \left(\int_c^d f(x, y)\mathrm{d} y \right) \mathrm{d} x\]</span><br />上面等式右边称为累次积分，也可以记为<br /><span class="math display">\[\int_a^b \mathrm{d} x \int_c^d f(x, y) \mathrm{d} y\]</span><br />同样，如果对于每一个<span class="math inline">\(y \in [c,d]\)</span>，函数<span class="math inline">\(f(x, y)\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，那么有<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_c^d \left(\int_a^b f(x, y)\mathrm{d} x \right) \mathrm{d} y\]</span><br />上面等式右边也可以记为<br /><span class="math display">\[\int_c^d \mathrm{d} y \int_a^b f(x, y) \mathrm{d} x\]</span></p></blockquote><p>证：由<a href="#定理1">定理1</a>可知，<br /><span class="math display">\[    \varphi(x) = \psi(x) = \int_c^d f(x, y) \mathrm{d} y\]</span><br />所以<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_a^b \varphi(x) \mathrm{d} x =\int_a^b \mathrm{d} x \int_c^d f(x, y) \mathrm{d} y\]</span><br />后半部分同样的证明方法。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(f\)</span>是<spanclass="math inline">\([a,b] \times [c,d]\)</span>上的连续函数，则有<br /><span class="math display">\[    \int_c^d \mathrm{d} y \int_a^b f(x, y) \mathrm{d} x = \int_a^b\mathrm{d} x \int_c^d f(x, y) \mathrm{d} y\]</span></p></blockquote><p>证：由于<span class="math inline">\(f\)</span>连续，从而<spanclass="math inline">\(\varphi(x)\)</span>与<spanclass="math inline">\(\psi(x)\)</span>都可积，再由<ahref="#定理2">定理2</a>易证。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设点集<br /><span class="math display">\[    B = \{(x, y): y_1(x) \le y \le y_2(x), a \le x \le b\}\]</span><br />其中函数<span class="math inline">\(y_1,y_2\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积。如果对任意的<spanclass="math inline">\(x \in [a,b]\)</span>，单变量积分<br /><span class="math display">\[    \int_{y_1(x)}^{y_2(x)} f(x, y) \mathrm{d} y\]</span><br />存在，那么<br /><span class="math display">\[    \int_B f \mathrm{d} \sigma = \int_a^b \mathrm{d} x\int_{y_1(x)}^{y_2(x)} f(x, y) \mathrm{d} y\]</span></p></blockquote><p>证：令<span class="math inline">\(c = \inf y_1([a, b]), d = \supy_2([a, b])\)</span>，从而<span class="math inline">\(I = [a, b] \times[c, d] \supset B\)</span>，由于<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积，从而<spanclass="math inline">\(f_B\)</span>在<spanclass="math inline">\(I\)</span>上可积，而且<br /><span class="math display">\[    \int_B f \mathrm{d} \sigma = \int_I f_B \mathrm{d} \sigma\]</span><br />显然易知，对每一个<span class="math inline">\(x \in[a,b]\)</span>，<span class="math inline">\(f_B(x, y)\)</span>在<spanclass="math inline">\([c, d]\)</span>上可积，所以由<ahref="#定理2">定理2</a>可知，<br /><span class="math display">\[    \int_I f_B \mathrm{d} \sigma = \int_a^b \mathrm{d} x \int_c^d f_B(x,y) \mathrm{d} y = \int_a^b \mathrm{d} x \int_{y_1(x)}^{y_2(x)} f_B\mathrm{d} y = \int_a^b \mathrm{d} x\int_{y_1(x)}^{y_2(x)} f(x, y)\mathrm{d} y\]</span></p><p>Q.E.D.</p><h4 id="定义1正则映射">定义1：正则映射</h4><blockquote><p>设有界闭域<span class="math inline">\(D \subset\mathbb{R}^2\)</span>，连续函数<span class="math inline">\(F: D \to\mathbb{R}\)</span>，映射<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>由公式<br /><span class="math display">\[    x = x(u, v), \quad y = y(u, v) \quad ((u, v) \in \Delta)\]</span><br />定义，其中<span class="math inline">\(\Delta\)</span>是<spanclass="math inline">\(uv\)</span>平面上的有界闭区域，设映射<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>是正则的，即<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>是从<spanclass="math inline">\(\Delta\)</span>到<spanclass="math inline">\(D\)</span>上的一对一的映射，<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>在<spanclass="math inline">\(\Delta\)</span>上连续可导，并且<br /><span class="math display">\[    \frac{\partial (x, y) }{\partial (u, v)} = \begin{vmatrix}    \frac{\partial x}{\partial u} &amp; \frac{\partial x}{\partial v} \\    \frac{\partial y}{\partial u} &amp; \frac{\partial y}{\partial v}    \end{vmatrix} \neq 0\]</span><br />在<span class="math inline">\(\Delta\)</span>上成立。</p></blockquote><h4 id="定理5">定理5</h4><blockquote><p>设正则映射<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>把<spanclass="math inline">\(\mathbb{R}^2\)</span>中以<br /><span class="math display">\[    (u_0, v_0), \quad (u_0 + h, v_0), \quad (u_0+h, v_0 +h), \quad (u_0,v_0 +h)\]</span><br />为顶点的的矩形<spanclass="math inline">\(A_{hk}\)</span>一对一的映射为<spanclass="math inline">\(\boldsymbol{\varphi}(A_{hk})\)</span>，那么<br /><span class="math display">\[    \lim \limits_{ h\to 0, k \to 0}\frac{\sigma(\boldsymbol{\varphi}(A_{hk}))}{\sigma(A_{hk})} =  \left|\frac{\partial(x, y)}{\partial(u, v)} \right|_{(u_0, v_0)}\]</span></p></blockquote><p>证：由映射后的图像有<br /><span class="math display">\[    \sigma(\boldsymbol{\varphi}(A_{hk})) \approx \Vert(\boldsymbol{\varphi}(u_0 + h, v_0) - \boldsymbol{\varphi}(u_0, v_0))\times (\boldsymbol{\varphi}(u_0, v_0 + k) - \boldsymbol{\varphi}(u_0,v_0))  \Vert\]</span><br />由于<br /><span class="math display">\[    \begin{aligned}    \boldsymbol{\varphi}(u_0 + h, v_0) - \boldsymbol{\varphi}(u_0, v_0)= \frac{\partial \boldsymbol{\varphi}}{\partial u} (u_0, v_0) h +\boldsymbol{\xi} \\    \boldsymbol{\varphi}(u_0, v_0+h) - \boldsymbol{\varphi}(u_0, v_0) =\frac{\partial \boldsymbol{\varphi}}{\partial v} (u_0, v_0) h +\boldsymbol{\eta}    \end{aligned}\]</span><br />其中<br /><span class="math display">\[    \Vert \boldsymbol{\xi} \Vert = o(h), \quad \Vert \boldsymbol{\eta}\Vert = o(k)\]</span><br />所以<br /><span class="math display">\[    \sigma(\boldsymbol{\varphi}(A_{hk})) \approx \Vert \frac{\partial\boldsymbol{\varphi}}{\partial u}(u_0, v_0) \times \frac{\partial\boldsymbol{\varphi}}{\partial v}(u_0, v_0) \Vert hk + o(hk)\]</span><br />而<br /><span class="math display">\[    hk = \sigma(A_{hk})\]</span><br />所以上式可以写为<br /><span class="math display">\[    \frac{\sigma (\boldsymbol{\varphi}(A_{hk}))}{\sigma(A_{hk})} \approx\Vert \frac{\partial \boldsymbol{\varphi}}{\partial u}(u_0, v_0) \times\frac{\partial \boldsymbol{\varphi}}{\partial v}(u_0, v_0) \Vert + o(1)\]</span><br />又因为<br /><span class="math display">\[    \frac{\partial \boldsymbol{\varphi}}{\partial u} \times\frac{\partial \boldsymbol{\varphi}}{\partial v} = \left|    \begin{matrix}    \boldsymbol{i} &amp; \boldsymbol{j} &amp; \boldsymbol{k}\\    \frac{\partial x}{\partial u} &amp; \frac{\partial x}{\partial v}&amp; 0 \\    \frac{\partial y}{\partial u} &amp; \frac{\partial y}{\partial v}&amp; 0 \\    \end{matrix}    \right| = \frac{\partial(x, y)}{\partial(u, v)} \boldsymbol{k}\]</span><br />所以<br /><span class="math display">\[    \Vert \frac{\partial \boldsymbol{\varphi}}{\partial u} \times\frac{\partial \boldsymbol{\varphi}}{\partial v} \Vert = \left|\frac{\partial (x, y)}{\partial(u, v)} \right|\]</span><br />从而<br /><span class="math display">\[\frac{\sigma (\boldsymbol{\varphi}(A_{hk}))}{\sigma(A_{hk})} \approx\left| \frac{\partial(x, y)}{\partial(u, v)} \right|_{(u_0, v_0)} +o(hk)\]</span><br />所以当<span class="math inline">\(h \to 0, k \to 0\)</span>时，有<br /><span class="math display">\[    \frac{\sigma (\boldsymbol{\varphi}(A_{hk}))}{\sigma(A_{hk})} =\left| \frac{\partial(x, y)}{\partial(u, v)} \right|_{(u_0, v_0)}\]</span></p><blockquote><p>笔者注：感觉该证明方法不太好，约等于记号不应该用在这里，就算使用也应该讲明原因。</p></blockquote><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设<spanclass="math inline">\(\mathbb{R}^2\)</span>中的有界闭区域<spanclass="math inline">\(D\)</span>有面积，函数<spanclass="math inline">\(F: \to \mathbb{R}\)</span>，映射<br /><span class="math display">\[    \boldsymbol{\varphi}: \left\{ \begin{aligned}    x = x(u, v) \\    y = y(u, v)    \end{aligned} \right.  \quad (u, v) \in \Delta\]</span><br />是从<span class="math inline">\(\Delta\)</span>到<spanclass="math inline">\(D\)</span>上的正则映射，那么<br /><span class="math display">\[    \iint \limits_D F(x, y) \mathrm{d} x \mathrm{d} y = \iint\limits_\Delta F \circ \boldsymbol{\varphi}(u, v) \left|\frac{\partial(x, y)}{\partial(u, v)} \right| \mathrm{d} u \mathrm{d} v\]</span></p></blockquote><p>证：用矩形<span class="math inline">\(I\)</span>把<spanclass="math inline">\(uv\)</span>平面上的闭区域<spanclass="math inline">\(\Delta\)</span>覆盖起来，用两族平行直线<spanclass="math inline">\(u =u_i (i=0,1,2, \cdots, m)\)</span>和<spanclass="math inline">\(v = v_j (j=0,1,2, \cdots,n)\)</span>分割<spanclass="math inline">\(I\)</span>，其中<br /><span class="math display">\[    u_0 &lt; u_1 &lt; \cdots &lt; u_{m-1} &lt; u_m, \quad v_0 &lt; v_1&lt; \cdots &lt; v_{n-1} &lt; v_n\]</span><br />令<span class="math inline">\(\Delta u_i = u_i -u_{i-1}(i=1,2,\cdots,m), \Delta v_j = v_j -v_{j-1}(j=1,2,\cdots,n)\)</span>。分割后可以得到<spanclass="math inline">\(mn\)</span>个矩形，在映射<spanclass="math inline">\(\boldsymbol{\varphi}\)</span>的作用下，它们变成了<spanclass="math inline">\(xy\)</span>平面下的<spanclass="math inline">\(mn\)</span>个曲边平行四边形，这时只需要考虑那些完全被包含在<spanclass="math inline">\(D\)</span>中的曲边平行四边形，将它们记为<spanclass="math inline">\(D_i(i=1,2,\cdots,k)\)</span>，即<spanclass="math inline">\(D_i=\boldsymbol{\varphi}(\Delta_i)\)</span>，其中<spanclass="math inline">\(\Delta_i(i=1,2,\cdots,k)\)</span>是完全被包含在<spanclass="math inline">\(\Delta\)</span>中的矩形，任取一点<spanclass="math inline">\(\boldsymbol{\eta}_i \in D_i\)</span> ，并设<spanclass="math inline">\(\Delta_i\)</span>中唯一的点<spanclass="math inline">\(\xi_i\)</span>，使得<spanclass="math inline">\(\boldsymbol{\varphi} (\xi_i) =\eta_i(i=1,2,\cdots,k)\)</span>，作积分和<br /><span class="math display">\[    \sum_{i=1}^k F(\boldsymbol{\eta}_i) \sigma(D_i)\]</span><br />由<a href="#定理5">定理5</a>可知<br /><span class="math display">\[    \sigma(D_i) \sim |det J \boldsymbol{\varphi}(\xi_i)|\sigma(\Delta_i) \quad (i=1,2,\cdots, k)\]</span><br />所以得到<br /><span class="math display">\[    \sum_{i=1}^k F(\boldsymbol{\eta}_i) \sigma(D_i) \sim \sum_{i=1}^k F\circ \boldsymbol{\varphi} (\boldsymbol{\xi}_i) |det J\boldsymbol{\varphi} (\boldsymbol{\xi}_i)|  \sigma(\Delta_i)\]</span><br />当分割无限细时，由<ahref="https://gamersover.github.io/2021/07/13/函数积分9#定理7">函数积分九的定理7</a>可得，<br /><span class="math display">\[    \int_D F \mathrm{d} \sigma = \int_\Delta F \circ\boldsymbol{\varphi} |J \boldsymbol{\varphi}| \mathrm{d} \sigma\]</span></p><p>Q.E.D.</p><h4 id="定理7极坐标换元">定理7：极坐标换元</h4><blockquote><p>令<span class="math inline">\(x = r \cos \theta, y= r \sin\theta\)</span>，则<br /><span class="math display">\[    \iint \limits_D F(x, y) \mathrm{d} x \mathrm{d} y = \iint\limits_\Delta F(r \cos \theta, r \sin \theta) r \mathrm{d} r \mathrm{d}\theta\]</span></p></blockquote><p>证：这时<br /><span class="math display">\[    \frac{\partial(x, y)}{\partial (u, v)} = \left| \begin{matrix}    \cos \theta &amp; -r\sin \theta \\    \sin \theta &amp; r \cos \theta    \end{matrix}    \right| = r\]</span><br />代入<a href="#定理6">定理6</a>的结果即证。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解25：K个一组翻转链表</title>
      <link href="/2021/07/18/leetcode%E9%A2%98%E8%A7%A325/"/>
      <url>/2021/07/18/leetcode%E9%A2%98%E8%A7%A325/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">力扣第25题</a></p><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。<br />k 是一个正整数，它的值小于或等于链表的长度。<br />如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>进阶：<br />你可以设计一个只使用常数额外空间的算法来解决此问题吗？<br />你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入：head = [1,2,3,4,5], k = 2<br />输出：[2,1,4,3,5]</p></blockquote><p>示例 2：</p><blockquote><p>输入：head = [1,2,3,4,5], k = 3<br />输出：[3,2,1,4,5]</p></blockquote><p>示例 3：</p><blockquote><p>输入：head = [1,2,3,4,5], k = 1<br />输出：[1,2,3,4,5]</p></blockquote><p>示例 4：</p><blockquote><p>输入：head = [1], k = 1<br />输出：[1]<br />提示：</p></blockquote><p>列表中节点的数量在范围 <code>sz</code> 内</p><ul><li>1 &lt;= sz &lt;= 5000</li><li>0 &lt;= Node.val &lt;= 1000</li><li>1 &lt;= k &lt;= sz</li></ul><h2 id="分析">分析</h2><p>思路比较直观，首先从当前节点开始往后数节点的个数，如果不超过<code>k</code>个，直接返回头节点；如果达到<code>k</code>个节点，则翻转这<code>k</code>个节点并返回翻转后的头节点，然后循环上述步骤就可以了。这里重点分析如何翻转<code>k</code>个节点，比如说翻转<code>1-&gt;2-&gt;3-&gt;4</code>的步骤如下：<br />1. 将2放到前面，<code>2-&gt;1-&gt;3-&gt;4</code><br />2. 将3放到前面，<code>3-&gt;2-&gt;1-&gt;4</code><br />3. 将4放到前面，<code>4-&gt;3-&gt;2-&gt;1</code></p><p>所以依次仿照上述操作即可翻转任意<code>k</code>个节点了，假设已知<code>k</code>个节点的头指针<code>head</code>和尾指针<code>tail</code>，并且指针<code>curr</code>前面已经翻转，现在需要翻转<code>curr</code>后的节点，如下所示<br /><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -&gt; ... -&gt; curr -&gt; <span class="built_in">first</span> -&gt; ... -&gt;</span><br></pre></td></tr></table></figure><br /><code>head</code>到<code>curr</code>已经翻转了，那么接下来需要将<code>first</code>放到前面即可，可以进行以下操作<br />1. <code>first = curr.next</code><br />2. <code>curr.next = first.next</code><br />3. <code>first.next = head</code><br />4. 最后更新<code>head</code>方便下次循环，<code>head = first</code></p><p>直到<code>head</code>与<code>tail</code>相等，表示<code>tail</code>已经在头部了，所以不需要再翻转了。</p><h2 id="算法">算法</h2><ol type="1"><li>初始化<code>fakeHead</code>，并令<code>fakeHead.next = head</code>，初始<code>pre</code>，并令<code>pre = fakeHead</code></li><li>进入循环，循环条件是<code>head != null</code></li><li>判断从<code>head</code>开始是否有<code>k</code>个节点，如果没有进入步骤4，如果有进入步骤5</li><li>由于不足<code>k</code>个节点，直接返回<code>fakeHead.next</code>，退出程序</li><li>获取<code>k</code>个节点的头<code>head</code>和尾<code>tail</code>，并翻转这<code>k</code>个节点，得到新的头<code>head</code>和尾<code>tail</code></li><li>拼接翻转后的链表<code>pre.next = head</code></li><li>更新<code>pre</code>,<code>head</code>准备下次循环，<code>pre=tail</code>，<code>head=pre.next</code>，回到步骤2</li><li>循环条件不满足退出并返回<code>fakeHead.next</code></li></ol><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head, tail</span>):</span><br><span class="line">        curr = head</span><br><span class="line">        <span class="keyword">while</span> head != tail:</span><br><span class="line">            first = curr.<span class="built_in">next</span></span><br><span class="line">            curr.<span class="built_in">next</span> = first.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = head</span><br><span class="line">            head = first</span><br><span class="line">        <span class="keyword">return</span> head, curr</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseKGroup</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        fakeHead = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        pre = fakeHead</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            tail = pre</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">                tail = tail.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">if</span> tail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">return</span> fakeHead.<span class="built_in">next</span></span><br><span class="line">            head, tail = self.reverse(head, tail)</span><br><span class="line">            pre.<span class="built_in">next</span> = head</span><br><span class="line">            pre = tail</span><br><span class="line">            head = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> fakeHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(ListNode* &amp;head, ListNode* &amp;tail)</span> </span>&#123;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">            ListNode* first = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = first-&gt;next;</span><br><span class="line">            first-&gt;next = head;</span><br><span class="line">            head = first;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = curr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode* fakeHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* pre = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode* tail = pre;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">                <span class="keyword">if</span> (tail == <span class="literal">nullptr</span>) <span class="keyword">return</span> fakeHead-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reverse</span>(head, tail);</span><br><span class="line">            pre-&gt;next = head;</span><br><span class="line">            pre = tail;</span><br><span class="line">            head = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(head != tail) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = first.next;</span><br><span class="line">            first.next = head;</span><br><span class="line">            head = first;</span><br><span class="line">        &#125;</span><br><span class="line">        tail = curr;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fakeHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> fakeHead;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> pre;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                tail = tail.next;</span><br><span class="line">                <span class="keyword">if</span> (tail == <span class="literal">null</span>) <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">newTail</span> <span class="operator">=</span> reverse(head, tail);</span><br><span class="line">            pre.next = tail;</span><br><span class="line">            pre = newTail;</span><br><span class="line">            head = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分九：有界区域上的二重积分</title>
      <link href="/2021/07/13/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%869/"/>
      <url>/2021/07/13/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%869/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>是有界集，函数<span class="math inline">\(f: B \to\mathbb{R}\)</span>，令<br /><span class="math display">\[    f_B(\boldsymbol{p}) = \left\{          \begin{aligned}            &amp; f(\boldsymbol{p}), &amp; \boldsymbol{p} \in B \\            &amp; 0, &amp; \boldsymbol{p} \in B^c        \end{aligned}     \right.\]</span><br />则函数<span class="math inline">\(f_B\)</span>在全平面<spanclass="math inline">\(\mathbb{R}^2\)</span>上有定义，如果限制在集合<spanclass="math inline">\(B\)</span>上，<spanclass="math inline">\(f_B\)</span>与<spanclass="math inline">\(f\)</span>相等。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>任取有界的闭矩形<span class="math inline">\(I \supsetB\)</span>，如果函数<span class="math inline">\(f_B\)</span>在<spanclass="math inline">\(I\)</span>上可积，则称函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积，并称数值<spanclass="math inline">\(\displaystyle \int_I f_B \mathrm{d}\sigma\)</span>为函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上的（二重）积分，记作<br /><span class="math display">\[    \iint \limits_B f(x, y) \mathrm{d} x \mathrm{d} y \quad 或 \quad\int_B f \mathrm{d} \sigma\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>设有界集<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，函数<span class="math inline">\(f: B \to\mathbb{R}\)</span>有界，如果集合<spanclass="math inline">\(B\)</span>的边界<spanclass="math inline">\(\partial B\)</span>和<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上的间断点都是零测集，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积。</p></blockquote><p>证：取闭矩形<span class="math inline">\(I\)</span>，满足<spanclass="math inline">\(I^\circ \supset \overline B\)</span>，由于<spanclass="math inline">\(f_B\)</span>在<spanclass="math inline">\(\overline B^c\)</span>上处处为零，所以<spanclass="math inline">\(\overline B^c\)</span>中的每个点都是<spanclass="math inline">\(f_B\)</span>的连续点，在<spanclass="math inline">\(B^\circ\)</span>上，<spanclass="math inline">\(f_B = f\)</span>，所以在<spanclass="math inline">\(B^\circ\)</span>上<spanclass="math inline">\(f_B\)</span>的不连续点就是<spanclass="math inline">\(f\)</span>的不连续点，从而<br /><span class="math display">\[    D(f_B) \subset D(f) \cup \partial B\]</span><br />由于<span class="math inline">\(D(f)\)</span>与<spanclass="math inline">\(\partial B\)</span>都是零测集，所以<spanclass="math inline">\(D(f_B)\)</span>也是零测集，即<spanclass="math inline">\(f_B\)</span>在<spanclass="math inline">\(I\)</span>上可积，从而<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设有界集<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，<span class="math inline">\(f: B \to\mathbb{R}\)</span>在<spanclass="math inline">\(B\)</span>上可积，那么对任意常数<spanclass="math inline">\(c\)</span>，函数<spanclass="math inline">\(cf\)</span>在<spanclass="math inline">\(B\)</span>上也可积，并且<br /><span class="math display">\[    \int_B cf \mathrm{d} \sigma = c \int_B f \mathrm{d} \sigma\]</span><br />又若<span class="math inline">\(g: B \to \mathbb{R}\)</span>在<spanclass="math inline">\(B\)</span>上可积，那么<spanclass="math inline">\(f \pm g\)</span>也在<spanclass="math inline">\(B\)</span>上可积，且<br /><span class="math display">\[    \int_B (f \pm g) \mathrm{d} \sigma = \int_B f \mathrm{d} \sigma \pm\int_B g \mathrm{d} \sigma\]</span></p></blockquote><p>证：对于第一个等式，设闭矩形<span class="math inline">\(I \supsetB\)</span>，有<br /><span class="math display">\[    \int_B cf \mathrm{d} \sigma = \int_I cf_B \mathrm{d} \sigma = c\int_I f_B \mathrm{d} \sigma = c \int_B f \mathrm{d} \sigma\]</span><br />对于第二个等式，同样有<br /><span class="math display">\[    \int_B (f \pm g) \mathrm{d} \sigma = \int_I (f_B \pm g_B) \mathrm{d}\sigma = \int_I f_B \mathrm{d} \sigma \pm \int_I g_B \mathrm{d} \sigma =\int_B f \mathrm{d} \sigma \pm \int_B g \mathrm{d} \sigma\]</span></p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(B_1, B_2 \subset\mathbb{R}^2\)</span>有界，且<span class="math inline">\(B_1 \capB_2\)</span>是零面积集，若函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B_1\)</span>和<spanclass="math inline">\(B_2\)</span>上都可积，那么<spanclass="math inline">\(f\)</span>在<span class="math inline">\(B_1 \cupB_2\)</span>上可积，且<br /><span class="math display">\[    \int_{B_1 \cup B_2} f \mathrm{d} \sigma = \int_{B_1} f \mathrm{d}\sigma + \int_{B_2} f \mathrm{d} \sigma\]</span></p></blockquote><p>证：易知，只要<span class="math inline">\(\boldsymbol{x} \notin B_1\cap B_2\)</span>，有<span class="math inline">\(f_{B_1 \cupB_2}(\boldsymbol{x}) = f_{B_1}(\boldsymbol{x}) +f_{B_2}(\boldsymbol{x})\)</span>，从而使得<spanclass="math inline">\(f_{B_1 \cup B_2}\)</span>与<spanclass="math inline">\(f_{B_1} + f_{B_2}\)</span>不相等的集合必属于<spanclass="math inline">\(B_1 \cap B_2\)</span>，即为零面积集。所以由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理9">函数积分八的定理9</a>可知，<br /><span class="math display">\[    \int_I (f_{B_1} + f_{B_2}) \mathrm{d} \sigma = \int_I f_{B_1 \capB_2} \mathrm{d} \sigma\]</span><br />设矩形<span class="math inline">\(I \supset B\)</span>，则有<br /><span class="math display">\[    \int_{B_1} f \mathrm{d} \sigma + \int_{B_2} f \mathrm{d} \sigma =\int_I f_{B_1} \mathrm{d} \sigma + \int_I f_{B_2} \mathrm{d} \sigma =\int_I (f_{B_1} + f_{B_2}) \mathrm{d} \sigma = \int_I f_{B_1 \cap B_2}\mathrm{d} \sigma\]</span></p><p>Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>有界，若常值函数<spanclass="math inline">\(1\)</span>在<spanclass="math inline">\(B\)</span>上可积，那么积分<spanclass="math inline">\(\displaystyle \int_B 1 \mathrm{d}\sigma\)</span>称为点集<spanclass="math inline">\(B\)</span>的面积，记为<spanclass="math inline">\(\sigma(B)\)</span>，这时称<spanclass="math inline">\(B\)</span>是有面积的。记函数<br /><span class="math display">\[    \chi_B (\boldsymbol{p}) = \left\{        \begin{aligned}        1, &amp; \quad \boldsymbol{p} \in B \\        0, &amp; \quad \boldsymbol{p} \notin B        \end{aligned}        \right.\]</span><br />称为<span class="math inline">\(B\)</span>的特征函数，从而<spanclass="math inline">\(B\)</span>的面积也可以写为<br /><span class="math display">\[    \sigma(B) = \int_B 1 \mathrm{d} \sigma = \int_I \chi_B \mathrm{d}\sigma\]</span><br />这里<span class="math inline">\(I\)</span>是任何一个包含<spanclass="math inline">\(B\)</span>的闭矩形。</p></blockquote><h4 id="定理4">定理4</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>是一个有界集，且<spanclass="math inline">\(\displaystyle \sigma(B) = \int_B 1 \mathrm{d}\sigma\)</span>存在，则<br /><span class="math display">\[    D(\chi_B) = \partial B\]</span></p></blockquote><p>证：由于<br /><span class="math display">\[    \mathbb{R}^2 = B^\circ \cup \partial B \cup (B^c)^\circ\]</span><br />而在开集<span class="math inline">\(B^\circ\)</span>和<spanclass="math inline">\((B^c)^\circ\)</span>上，<spanclass="math inline">\(\chi_B\)</span>分别为<spanclass="math inline">\(1\)</span>和<spanclass="math inline">\(0\)</span>，所以<spanclass="math inline">\(\chi_B\)</span>在<spanclass="math inline">\(B^\circ\)</span>和<spanclass="math inline">\((B^c)^\circ\)</span>上连续，从而<br /><span class="math display">\[    D(\chi_B) \subset \partial B   \tag {1}\]</span><br />任取<span class="math inline">\(\boldsymbol{p} \in \partialB\)</span>，则在<spanclass="math inline">\(\boldsymbol{p}\)</span>的任意小的领域内即有<spanclass="math inline">\(B\)</span>中的点<spanclass="math inline">\(\boldsymbol{p}^\prime\)</span>，又有<spanclass="math inline">\(B^c\)</span>中的点<spanclass="math inline">\(\boldsymbol{p}^{\prime\prime}\)</span>，而<spanclass="math inline">\(\chi_B(\boldsymbol{p}^\prime) = 1,\chi_B(\boldsymbol{p}^{\prime\prime})=0\)</span>，所以<spanclass="math inline">\(\chi_B\)</span>在<spanclass="math inline">\(\boldsymbol{p}\)</span>处不连续，所以<br /><span class="math display">\[    \partial B \subset D(\chi_B) \tag {2}\]</span><br />由<span class="math inline">\((1)(2)\)</span>即得<spanclass="math inline">\(D(\chi_B) = \partial B\)</span>。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>是一个有界集，则点集<spanclass="math inline">\(B\)</span>为零面积集的充分必要条件是<br /><span class="math display">\[    \sigma (B) = \int_B 1 \mathrm{d} \sigma = 0\]</span></p></blockquote><p>证：必要性。作闭矩形<span class="math inline">\(I\)</span>使得<spanclass="math inline">\(I^{\circ} \supset \overline B\)</span>，则<spanclass="math inline">\(B\)</span>上的特征函数<spanclass="math inline">\(\chi_B\)</span>在<spanclass="math inline">\(I\)</span>上取非零值的点集正好是<spanclass="math inline">\(B\)</span>，而<spanclass="math inline">\(B\)</span>是零面积集，由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理8">函数积分八的定理8</a>可知，<span class="math inline">\(\chi_B\)</span>在<spanclass="math inline">\(I\)</span>上可积且<br /><span class="math display">\[    \sigma(B) = \int_B 1 \mathrm{d} \sigma = \int_I \chi_B \mathrm{d}\sigma = 0\]</span><br />这表明<span class="math inline">\(B\)</span>的面积为零。</p><p>充分性。由于<span class="math inline">\(\sigma(B) =0\)</span>，从而<span class="math inline">\(B^\circ =\varnothing\)</span>，又因为<spanclass="math inline">\(\chi_B\)</span>可积，从而<spanclass="math inline">\(D(\chi_B)\)</span>是零测集，再由<ahref="https://gamersover.github.io/2021/07/13/函数积分9/#定理4">定理4</a>可知<spanclass="math inline">\(\partial B\)</span>是零测集，而<spanclass="math inline">\(\partial B\)</span>又是有界闭集，从而由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理1">函数积分八的定理1</a>可知<spanclass="math inline">\(\partial B\)</span>是零面积集，由<spanclass="math inline">\(B \subset \partial B \cup B^\circ = \partialB\)</span>，得<span class="math inline">\(B \subset \partialB\)</span>，所以<span class="math inline">\(B\)</span>也是零面积集。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设有界集<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，则<spanclass="math inline">\(B\)</span>有面积当且仅当<spanclass="math inline">\(B\)</span>的边界<spanclass="math inline">\(\partial B\)</span>是一零面积集。</p></blockquote><p>证：由于<span class="math inline">\(\partialB\)</span>是有界闭集，所以<span class="math inline">\(\partialB\)</span>是零面积集<span class="math inline">\(\Leftrightarrow \partialB\)</span>是零测集<span class="math inline">\(\LeftrightarrowD(\chi_B)\)</span>是零测集<span class="math inline">\(\Leftrightarrow\sigma(B)\)</span>存在<span class="math inline">\(\LeftrightarrowB\)</span>有面积。</p><p>Q.E.D.</p><h4 id="定理7">定理7</h4><blockquote><p>设<span class="math inline">\(B\)</span>是<spanclass="math inline">\(\mathbb{R}^2\)</span>中的有面积的点集，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积，对<spanclass="math inline">\(B\)</span>的任意分割<spanclass="math inline">\(T\)</span>作Riemann和，那么对任意的<spanclass="math inline">\(\boldsymbol{\xi}_i \inD_i(i=1,2,\cdots,m)\)</span>有<br /><span class="math display">\[    \lim_{\Vert T \Vert \to 0} \sum_{i=1}^m f(\boldsymbol{\xi}_i)\sigma(D_i) = \int_B f \mathrm{d} \sigma\]</span><br />其中<span class="math inline">\(\Vert T \Vert = \max \limits_{1 \le i\le m} \mathrm{diam}(D_i)\)</span>。也就是说，对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta&gt;0\)</span>，只要分割<spanclass="math inline">\(T = \{D_1, D_2, \cdots, D_n\}\)</span>满足<spanclass="math inline">\(\Vert T \Vert &lt; \delta\)</span>，就有<br /><span class="math display">\[    \left|\sum_{i=1}^m f(\boldsymbol{\xi}_i) \sigma(D_i) - \int_B f\mathrm{d} \sigma \right| &lt; \varepsilon\]</span></p></blockquote><p>证：由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上可积，从而对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在矩形网的分割<spanclass="math inline">\(\pi_{\varepsilon} = \{J_1, J_2, \cdots, J_t\}\)</span>，使得<br /><span class="math display">\[    \overline S(f, \pi_{\varepsilon}) - \underline S(f,\pi_{\varepsilon}) &lt; \frac{\varepsilon}{2}\]</span><br />即<br /><span class="math display">\[    \sum_{i=1}^t (\sup f(J_i) - \inf f(J_i)) \sigma(J_i) &lt;\frac{\varepsilon}{2}\]</span><br />这里<span class="math inline">\(J_i \subset B(i=1,2,\cdots,t)\)</span>，现将子矩形<spanclass="math inline">\(J_i\)</span>的每一边平行地向内部收缩同一距离<spanclass="math inline">\(\delta &gt; 0\)</span>，作成一个开矩形<spanclass="math inline">\(\tilde {J_i} \subset J_i(i=1,2,\cdots,t)\)</span>。记<br /><span class="math display">\[    K = I \bigcap (\bigcup \limits_{i=1}^t \tilde J_i)^c\]</span><br />这里<span class="math inline">\(I\)</span>是所有包含在<spanclass="math inline">\(B\)</span>中的闭子矩形<spanclass="math inline">\(J_i\)</span>的并，显然<spanclass="math inline">\(K\)</span>是闭集，现取<spanclass="math inline">\(\delta &gt; 0\)</span>充分小，使得<spanclass="math inline">\(\sigma(K) &lt; \varepsilon /2\omega\)</span>，这里<span class="math inline">\(\omega\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B\)</span>上的振幅。对这个<spanclass="math inline">\(\delta &gt; 0\)</span>，任取分割<spanclass="math inline">\(T = \{D_1, D_2, \cdots, D_m\}\)</span>，使得<spanclass="math inline">\(\Vert T \Vert &lt; \delta\)</span>，记<spanclass="math inline">\(\displaystyle A = \int_B f \mathrm{d}\sigma\)</span>，则有<br /><span class="math display">\[    A = \sum_{i=1}^m \int_{D_i} f \mathrm{d} \sigma\]</span><br />设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D_i\)</span>上的上、下确界分别为<spanclass="math inline">\(M_i, m_i\)</span>，则<br /><span class="math display">\[    m_i \sigma(D_i) \le \int_{D_i} f \mathrm{d} \sigma \le M_i\sigma(D_i)\]</span><br />记<span class="math inline">\(\displaystyle \mu_i =\frac{1}{\sigma(D_i)} \int_{D_i} f \mathrm{d} \sigma\)</span>，从而<spanclass="math inline">\(m_i \le \mu_i \le M_i\)</span>，又有<br /><span class="math display">\[    \begin{aligned}    \left| A - \sum_{i=1}^m f(\boldsymbol{\xi}_i)\sigma(D_i) \right|&amp;= \left| \sum_{i=1}^m (\mu_i - f(\boldsymbol{\xi}_i)) \sigma(D_i)\right| \\    &amp; \le \sum_{i=1}^m \left| \mu_i - f(\boldsymbol{\xi}_i) \right|\sigma(D_i) \\    &amp; \le \sum_{i=1}^m (M_i - m_i) \sigma(D_i) \\    &amp; = \sum_{i=1}^m \omega_i \sigma(D_i) \\    &amp; = \sum \nolimits_1 + \sum \nolimits_2    \end{aligned}\]</span><br />其中<br /><span class="math display">\[    \sum \nolimits_1 = \sum_{D_i \subset K} \omega_i \sigma(D_i) \quad\sum \nolimits_2 = \sum_{D_i \nsubseteq K}\omega_i \sigma(D_i)\]</span><br />而<br /><span class="math display">\[    \sum \nolimits_1 \le \omega \sum_{D_1 \subset K} \sigma(D_i) \le\omega_i \sigma(K) &lt; \frac{\varepsilon}{2}\]</span><br />对于<span class="math inline">\(\sum_2\)</span>，由于<spanclass="math inline">\(D_i \nsubseteq K\)</span>，从而<spanclass="math inline">\(D_i\)</span>必与某个<spanclass="math inline">\(\tilde {J_j}\)</span>相交，所以必有<spanclass="math inline">\(D_i \subset J_j\)</span>，从而有<br /><span class="math display">\[    \begin{aligned}    \sum \nolimits_2 = \sum_{j=1}^t \sum_{D_i \subset J_j} \omega_i\sigma(D_i) &amp; \le \sum_{j=1}^t (\sup f(J_j) - \inf f(J_j)) \sum_{D_i\subset J_j} \sigma(D_i) \\    &amp; \le \sum_{j=1}^t (\sup f(J_j) - \inf f(J_j)) \sigma(J_i) &lt;\frac{\varepsilon}{2}    \end{aligned}\]</span><br />所以有<br /><span class="math display">\[    \left| A - \sum_{i=1}^m f(\boldsymbol{\xi}_i)\sigma(D_i)  \right|\le \sum \nolimits_1 + \sum \nolimits_2 &lt; \varepsilon\]</span></p><p>Q.E.D.</p><h4 id="定理8积分平均值定理">定理8：积分平均值定理</h4><blockquote><p>设<span class="math inline">\(K\)</span>是<spanclass="math inline">\(\mathbb{R}^2\)</span>中的有线条光滑曲线围成的有界闭区域，函数<spanclass="math inline">\(f, g: K \to \mathbb{R}\)</span>连续且<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(K\)</span>上不变号，于是存在一点<spanclass="math inline">\(\boldsymbol{\xi} \in K\)</span>，满足<br /><span class="math display">\[    \int_K fg \mathrm{d} \sigma = f(\boldsymbol{\xi}) \int_K g\mathrm{d} \sigma\]</span></p></blockquote><p>证：连续函数<span class="math inline">\(g\)</span>与<spanclass="math inline">\(fg\)</span>在<spanclass="math inline">\(K\)</span>上都可积，因为<spanclass="math inline">\(K\)</span>是紧致集，所以连续函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(K\)</span>上取得最小值<spanclass="math inline">\(f(\boldsymbol{a})\)</span>与最大值<spanclass="math inline">\(f(\boldsymbol{b})\)</span>，不妨设在<spanclass="math inline">\(K\)</span>上<span class="math inline">\(g \le0\)</span>，于是<br /><span class="math display">\[    f(\boldsymbol{a})g(\boldsymbol{p}) \leg(\boldsymbol{p})g(\boldsymbol{p}) \lef(\boldsymbol{b})g(\boldsymbol{p})\]</span><br />对一切<span class="math inline">\(\boldsymbol{p} \inK\)</span>都成立，从而有<br /><span class="math display">\[    f(\boldsymbol{a})\int_K g \mathrm{d} \sigma \le \int_K fg \mathrm{d}\sigma \le f(\boldsymbol{b}) \int_K g \mathrm{d} \sigma\]</span><br />若<span class="math inline">\(\displaystyle \int_K g \mathrm{d} \sigma =0\)</span>，这时<span class="math inline">\(g =0\)</span>，定理自然成立。现设<span class="math inline">\(\displaystyle\int_K g \mathrm{d} \sigma &gt; 0\)</span>，于是<br /><span class="math display">\[    f(\boldsymbol{a}) \le \left( \int_k g \mathrm{d} \sigma \right)^{-1}\int_K fg \mathrm{d} \sigma \le f(\boldsymbol{b})\]</span><br />由于<span class="math inline">\(K\)</span>是连通集，而<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(K\)</span>上连续，从而由介值定理可知，存在一点<spanclass="math inline">\(\boldsymbol{\xi} \in K\)</span>，使得<br /><span class="math display">\[    f(\boldsymbol{\xi}) = \left( \int_K g \mathrm{d} \sigma \right)^{-1}\int_K fg \mathrm{d} \sigma\]</span></p><p>Q.E.D.</p><h4 id="定理9">定理9</h4><blockquote><p>设<span class="math inline">\(K\)</span>是<spanclass="math inline">\(\mathbb{R}^2\)</span>中的有界闭区域，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(K\)</span>上连续，那么存在一点<spanclass="math inline">\(\boldsymbol{\xi} \in K\)</span>，使得<br /><span class="math display">\[    \int_K f \mathrm{d} \sigma = f(\boldsymbol{\xi}) \sigma(K)\]</span></p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/07/13/函数积分9/#定理8：积分平均值定理">定理8</a>，令<spanclass="math inline">\(g = 1\)</span>即得。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解24：两两交换链表中的节点</title>
      <link href="/2021/07/11/leetcode%E9%A2%98%E8%A7%A324/"/>
      <url>/2021/07/11/leetcode%E9%A2%98%E8%A7%A324/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">力扣第24题</a></p><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。<br />你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><span id="more"></span><p>示例1：</p><blockquote><p>输入：head = [1,2,3,4]<br />输出：[2,1,4,3]</p></blockquote><p>示例2：</p><blockquote><p>输入：head = []<br />输出：[]</p></blockquote><p>示例3：</p><blockquote><p>输入：head = [1]<br />输出：[1]</p></blockquote><p>提示：</p><ul><li>链表中节点的数目在范围<code>[0, 100]</code>内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h2 id="分析">分析</h2><p>假设当前节点<code>curr</code>以及两个相邻的节点指针<code>first, second</code>，其中<code>curr-&gt;first-&gt;second</code>，想要交换两个节点，只需要执行以下两步：<br />1. <code>first-&gt;next = second-&gt;next</code><br />2. <code>second-&gt;next = first</code></p><p>此时链表为<code>(curr,second)-&gt;first</code>，需再执行一步<code>curr.next = second</code>，链表才会变成<code>curr-&gt;second-&gt;first</code></p><p>另外就是需要注意几种特殊情况：<br />1.对于头部而言，如果<code>first = head</code>，那么<code>curr</code>就不存在，这时只需要设计一个<code>fakeHead</code>指针指向<code>head</code>即可<br />2.如果<code>first==null</code>或者<code>second==null</code>，直接结束就可以，因为已经不需要交换了</p><h2 id="算法">算法</h2><ol type="1"><li>初始一个<code>fakeHead</code>节点，使其指向链表头部<code>head</code></li><li>令<code>curr = fakeHead</code></li><li>进入循环，循环终止条件为<code>curr.next == null</code>或者<code>curr.next.next == null</code></li><li>令<code>first = curr.next</code>，<code>second = first.next</code></li><li>交换节点<code>first-&gt;next = second-&gt;next</code>，<code>second-&gt;next = first</code>，<code>curr.next = second</code></li><li>更新<code>curr = first</code>，并回到循环初始即步骤3</li><li>循环退出，返回新的链表头节点<code>fakeHead.next</code>，程序结束</li></ol><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        fakeHead = ListNode(<span class="number">0</span>, head)</span><br><span class="line">        curr = fakeHead</span><br><span class="line">        <span class="keyword">while</span> curr.<span class="built_in">next</span> <span class="keyword">and</span> curr.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            first = curr.<span class="built_in">next</span></span><br><span class="line">            second = first.<span class="built_in">next</span></span><br><span class="line">            first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line">            curr.<span class="built_in">next</span> = second</span><br><span class="line">            curr = first</span><br><span class="line">        <span class="keyword">return</span> fakeHead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* fakeHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* curr = fakeHead;</span><br><span class="line">        <span class="keyword">while</span> ((curr-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (curr-&gt;next-&gt;next != <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            ListNode* first = curr-&gt;next;</span><br><span class="line">            ListNode* second = first-&gt;next;</span><br><span class="line">            first-&gt;next = second-&gt;next;</span><br><span class="line">            second-&gt;next = first;</span><br><span class="line">            curr-&gt;next = second;</span><br><span class="line">            curr = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode() &#123;&#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">    ListNode(<span class="type">int</span> val, ListNode next) &#123; <span class="built_in">this</span>.val = val; <span class="built_in">this</span>.next = next; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fakeHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> fakeHead;</span><br><span class="line">        <span class="keyword">while</span> ((curr.next != <span class="literal">null</span>) &amp;&amp; (curr.next.next != <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">first</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">second</span> <span class="operator">=</span> first.next;</span><br><span class="line">            first.next = second.next;</span><br><span class="line">            second.next = first;</span><br><span class="line">            curr.next = second;</span><br><span class="line">            curr = first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fakeHead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分八：Lebesgue定理</title>
      <link href="/2021/06/29/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%868/"/>
      <url>/2021/06/29/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%868/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1零测集">定义1：零测集</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，如果对任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在可数个闭矩形序列<spanclass="math inline">\(\{I_i\}(i=1,2,\cdots)\)</span>，使得<br /><span class="math display">\[    B \subset \bigcup \limits_{i=1}^\infty I_i, \qquad \sum_{i=1}^\infty\sigma(I_i) &lt; \varepsilon\]</span><br />则称<spanclass="math inline">\(B\)</span>为(二维)零测集。定义中的闭矩形可以换成开矩形。</p></blockquote><span id="more"></span><h4 id="定义2零面积集">定义2：零面积集</h4><blockquote><p>设<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，如果对任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在有限个闭矩形序列<span class="math inline">\(I_1, I_2,\cdots, I_m\)</span>，使得<br /><span class="math display">\[    B \subset \bigcup \limits_{i=1}^m I_i, \qquad \sum_{i=1}^m\sigma(I_i) &lt; \varepsilon\]</span><br />则称<spanclass="math inline">\(B\)</span>为零面积集。定义中的闭矩形可以换成开矩形。</p></blockquote><!--more--><h4 id="定理1">定理1</h4><blockquote><ol type="1"><li>至多可数集是零测集；</li><li>至多可数个零测集的并是零测集；</li><li>有限个零面积集的并是零面积集；</li><li><span class="math inline">\(B\)</span>为零面积集，必须且只需<spanclass="math inline">\(\bar B\)</span>也是零面积集。</li><li>如果<span class="math inline">\(B\)</span>是有界闭集，则<spanclass="math inline">\(B\)</span>为零测集的充分必要条件是<spanclass="math inline">\(B\)</span>为零面积集。</li></ol></blockquote><p>证：(1)(2)(3)易证，这里只证(4)(5)。<br />(4)的充分性。由于<span class="math inline">\(B \subset \barB\)</span>，从而由定义可知，对于任意给定的<spanclass="math inline">\(\varepsilon &gt;0\)</span>，存在有限个闭矩形序列<span class="math inline">\(I_1, I_2,\cdots, I_m\)</span>使得<br /><span class="math display">\[    B \subset \bar B \subset \bigcup \limits_{i=1}^m I_i, \quad\sum_{i=1}^m \sigma(I_i) &lt; \varepsilon\]</span><br />所以<span class="math inline">\(B\)</span>是零面积集。<br />必要性。有定义知<span class="math inline">\(B \subset \bigcup\limits_{i=1}^m I_i\)</span>，而<span class="math inline">\(\bigcup\limits_{i=1}^m I_i\)</span>是闭集，从而<span class="math inline">\(\barB \subset \bigcup \limits_{i=1}^m I_i\)</span>，在由定义可知，<spanclass="math inline">\(\bar B\)</span>是零面积集。<br />(5)的充分性由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定义2：零面积集">定义2</a>显然得出。<br />必要性。可知<spanclass="math inline">\(B\)</span>是紧致集而且是零测集，从而对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在开矩形序列<spanclass="math inline">\(\{I_i\}\)</span>，使得<br /><span class="math display">\[    B \subset \bigcup \limits_{i=1}^\infty I_i, \qquad \sum_{i=1}^\infty\sigma(I_i) &lt; \varepsilon\]</span><br />由<ahref="https://gamersover.github.io/2020/11/10/点列极限6/#定理2">点列极限六的定理2</a>可知，从<spanclass="math inline">\(\{I_i\}\)</span>中可以选取有限个开矩形仍能覆盖住<spanclass="math inline">\(B\)</span>，这些开矩形的面积和自然小于<spanclass="math inline">\(\varepsilon\)</span>，从而<spanclass="math inline">\(B\)</span>是零面积集。</p><p>Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>设集合<span class="math inline">\(B \subset \mathbb{R}^2, f: B \to\mathbb{R}\)</span>有界。对任何<spanclass="math inline">\(\boldsymbol{x} \in B\)</span>及<spanclass="math inline">\(r &gt; 0\)</span>，令<spanclass="math inline">\(I_{x,r} = B \capB_r(\boldsymbol{x})\)</span>。用<spanclass="math inline">\(\omega_f(\boldsymbol{x}, r)\)</span>表示<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I_{r,\boldsymbol{x}}\)</span>上的振幅。令<br /><span class="math display">\[    \omega_f(\boldsymbol{x}) = \lim \limits_{r \to 0^+}\omega_f(\boldsymbol{x}, r)\]</span><br />称之为函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x}\)</span>处的振幅。</p></blockquote><h4 id="定理2">定理2</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I_{r, \boldsymbol{x}}\)</span>上的振幅<br /><span class="math display">\[    \omega_f(\boldsymbol{x}, r) = \sup \{ |f(\boldsymbol{y}_1) -f(\boldsymbol{y}_2)|: \boldsymbol{y}_1,\boldsymbol{y}_2 \inI_{\boldsymbol{x}, r} \}\]</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理2">函数积分四的定理2</a>证明方法一样。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设集合<span class="math inline">\(B \subset\mathbb{R}^2\)</span>，函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x} \inB\)</span>处连续的充分必要条件是<spanclass="math inline">\(\omega_f(\boldsymbol{x}) = 0\)</span>。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理4">函数积分四的定理4</a>证明方法一样。</p><h4 id="定理5">定理5</h4><blockquote><p>设<span class="math inline">\(I\)</span>是一个矩形，对<spanclass="math inline">\(\delta &lt; 0\)</span>， 记<br /><span class="math display">\[    D_\delta = \{ \boldsymbol{x} \in I: \omega_f(\boldsymbol{x}) \ge\delta \}\]</span><br />用<span class="math inline">\(D(f)\)</span>表示<spanclass="math inline">\(f\)</span>在矩形<spanclass="math inline">\(I\)</span>上不连续点的全体，那么有<br /><span class="math display">\[    \displaystyle D(f) = \bigcup_{n=1}^\infty D_{1/n}\]</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理5">函数积分四的定理5</a>证明方法一样。</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(f\)</span>是定义在有限闭矩形<spanclass="math inline">\(I\)</span>上的函数，如果存在一列开矩形<spanclass="math inline">\(I_j(j=1,2,\cdots)\)</span>使得<spanclass="math inline">\(\displaystyle D(f) \subset \bigcup\limits_{j=1}^\infty I_j\)</span>，记<span class="math inline">\(K = I\backslash \bigcup \limits_{j=1}^\infty I_j\)</span>，那么对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，一定存在<spanclass="math inline">\(\delta &gt; 0\)</span>，当<spanclass="math inline">\(\boldsymbol{x} \in K,\boldsymbol{I}\)</span>且<span class="math inline">\(\Vert\boldsymbol{x} - \boldsymbol{y} \Vert &lt; \delta\)</span>时，有<spanclass="math inline">\(|f(\boldsymbol{x}) - f(\boldsymbol{y})| &lt;\varepsilon\)</span>。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理6">函数积分四的定理6</a>证明方法一样。</p><h4 id="定理7lebesgue">定理7：Lebesgue</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在闭矩形<spanclass="math inline">\(I\)</span>上有界，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上Riemann可积的充分必要条件是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>的全体不连续点组成的集<spanclass="math inline">\(D(f)\)</span>是零测集。</p></blockquote><p>证：必要性。由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理5">定理5</a>可知，要证明<spanclass="math inline">\(D(f)\)</span>是零测集，只需证明<spanclass="math inline">\(D_{1/n}\)</span>是零测集，由于<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积，从而对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi = \{ I_1, I_2, \cdots, I_m\}\)</span>，使得<br /><span class="math display">\[    \sum_{i=1}^m \omega_i \sigma(I_i) &lt; \frac{\varepsilon}{n} \tag{1}\]</span><br />令<span class="math inline">\(E_n = D_{1/n} \backslashl(\pi)\)</span>，这里<span class="math inline">\(l(\pi)\)</span>为<spanclass="math inline">\(\pi\)</span>的分割线所构成的集合，易知<spanclass="math inline">\(l(\pi)\)</span>是一个零面积集，从而只要证明<spanclass="math inline">\(E_n\)</span>是零测集即可。由于<spanclass="math inline">\(\displaystyle I \backslash l(\pi) =\bigcup_{i=1}^m I_i\)</span>，这里<spanclass="math inline">\(I_i(i=1,2,\cdots,m)\)</span>都是开矩形，所以<br /><span class="math display">\[    E_n = D_{1/n} \cap (\bigcup_{i=1}^m I_i) \subset \{I_i: I_i \capD_{1/n} \ne \varnothing \}\]</span><br />表明<spanclass="math inline">\(E_n\)</span>被一列开区间的并所覆盖，这一列矩形每一个都含有<spanclass="math inline">\(D_{1/n}\)</span>中的点，任取<spanclass="math inline">\(\boldsymbol{\alpha} \in D_{1/n} \capI_i\)</span>，则必能取到充分小的<spanclass="math inline">\(r\)</span>，使得<spanclass="math inline">\(B_r(\boldsymbol{\alpha}) \in I_i\)</span>，用<spanclass="math inline">\(\omega_i\)</span>和<spanclass="math inline">\(\omega_f(\boldsymbol{\alpha},r)\)</span>分别记<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I_i\)</span>和<spanclass="math inline">\(B_{r}(\alpha)\)</span>上的振幅，那么<br /><span class="math display">\[    \omega_i \ge \omega_f(\boldsymbol{\alpha}, r) \ge\omega_f(\boldsymbol{\alpha}) \ge \frac{1}{n} \tag{2}\]</span><br />如果用<span class="math inline">\(\sum\nolimits^\prime\)</span>表示对那些满足<spanclass="math inline">\(D_{1/n} \cap I_i \ne \varnothing\)</span>的<spanclass="math inline">\(i\)</span>求和，那么由式(1)和式(2)可得<br /><span class="math display">\[    \frac{\varepsilon}{n} &gt; \sum_{i=1}^m \omega_i \sigma(I_i) \le\sum \nolimits^\prime \omega_i \sigma(I_i) \ge \frac{1}{n} \sum\nolimits^\prime \sigma(I_i)\]</span><br />即<br /><span class="math display">\[    \sum \nolimits^\prime \sigma(I_i) &lt; \varepsilon\]</span><br />这正好说明<spanclass="math inline">\(E_n\)</span>是一个零面积集，所以<spanclass="math inline">\(D_{1/n}\)</span>是零测集。<br />充分性。设<spanclass="math inline">\(D(f)\)</span>是一个零测集，从而对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在一列开矩形<spanclass="math inline">\(J_i(i=1,2,\cdots)\)</span>，使得<br /><span class="math display">\[    D(f) \subset \bigcup_{i=1}^\infty J_i \qquad \sum_{i=1}^\infty\sigma(J_i) &lt; \frac{\varepsilon}{2\omega}\]</span><br />这里<span class="math inline">\(\omega\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的振幅。令<br /><span class="math display">\[    K = I \backslash \bigcup \limits_{i=1}^\infty J_i\]</span><br />由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理6">定理6</a>可知，对上述的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x} \in K, \boldsymbol{y} \inI\)</span>，且<span class="math inline">\(\Vert \boldsymbol{x} -\boldsymbol{y} \Vert &lt; \delta\)</span>时，有<br /><span class="math display">\[    |f(\boldsymbol{x}) - f(\boldsymbol{y})| &lt;\frac{\varepsilon}{4\sigma(I)}\]</span><br />现取分割<span class="math inline">\(\pi = \{ I_1, I_2, \cdots,I_m\}\)</span>，使得<span class="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>，令<br /><span class="math display">\[    \sum_{i=1}^m \omega_i \sigma(I_i) = \sum \nolimits_1 \omega_i\sigma(I_i) + \sum \nolimits_2 \omega_i \sigma(I_i)\]</span><br />其中<span class="math inline">\(\sum \nolimits_1\)</span>表示对<spanclass="math inline">\(K\)</span>和<spanclass="math inline">\(I_i\)</span>相交的那些<spanclass="math inline">\(i\)</span>求和，<span class="math inline">\(\sum\nolimits_2\)</span>表示对<span class="math inline">\(K\)</span>和<spanclass="math inline">\(I_i\)</span>不相交的那些<spanclass="math inline">\(i\)</span>求和。对<span class="math inline">\(\sum\nolimits_1\)</span>中的项，因为<span class="math inline">\(K \cap I_i\ne \varnothing\)</span>，任取<spanclass="math inline">\(\boldsymbol{y}_i \in K \cap I_i\)</span>，则<br /><span class="math display">\[    \begin{aligned}    \omega_i &amp; = \sup\{ |f(\boldsymbol{z}_1) - f(\boldsymbol{z}_2)|:\boldsymbol{z}_1, \boldsymbol{z}_2 \in I_i \} \\    &amp; \le \sup \{ |f(\boldsymbol{z}_1) - f(\boldsymbol{y}_i)| +|f(\boldsymbol{z}_2) - f(\boldsymbol{y}_i) |: \boldsymbol{z}_1,\boldsymbol{z}_2 \in I_i, \boldsymbol{y}_i \in K \cap I_i \} \\    &amp; \le \frac{\varepsilon}{2\sigma(I)}    \end{aligned}\]</span><br />从而<br /><span class="math display">\[    \sum \nolimits_1 \omega_i \sigma(I_i) \le\frac{\varepsilon}{2\sigma(I)} \sigma(I) = \frac{\varepsilon}{2} \tag{3}\]</span><br />对<span class="math inline">\(\sum \nolimits_2\)</span>中的项，由于<spanclass="math inline">\(K \cap I_i = \varnothing\)</span>吗，所以当<spanclass="math inline">\(\boldsymbol{x} \in I_i\)</span>，<spanclass="math inline">\(\boldsymbol{x} \notin K\)</span>，从而<spanclass="math inline">\(\displaystyle \boldsymbol{x} \in\bigcup_{i=1}^\infty J_i\)</span>，即<span class="math inline">\(I_i\subset \bigcup \limits_{i=1}^\infty J_i\)</span>，所以<br /><span class="math display">\[    \sum \nolimits_2 \sigma(I_i) \le \sum_{i=1}^\infty \sigma(J_i) &lt;\frac{\varepsilon}{2\omega}\]</span><br />从而<br /><span class="math display">\[    \sum \nolimits_2 \omega_i \sigma(I_i) \le \omega \sum \nolimits_2\sigma(I_i) &lt; \frac{\varepsilon}{2} \tag{4}\]</span><br />由式(3)和式(4)可知，<br /><span class="math display">\[    \sum_{i=1}^m \omega_i \sigma(I_i) &lt; \varepsilon\]</span><br />所以<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积。</p><p>Q.E.D.</p><h4 id="定理8">定理8</h4><blockquote><p>设函数<span class="math inline">\(f: I \to\mathbb{R}\)</span>有界。如果集合<span class="math inline">\(B =\{\boldsymbol{x} \in I, f(\boldsymbol{x}) \ne 0\}\)</span>为一零面积集，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积，并且<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = 0\]</span></p></blockquote><p>证：显然<span class="math inline">\(I^\circ \backslash \overlineB\)</span>中的点都是<spanclass="math inline">\(f\)</span>的连续点，从而<spanclass="math inline">\(D(f) \subset \partial I \cup \overlineB\)</span>，而<span class="math inline">\(\partial I\)</span>和<spanclass="math inline">\(\overline B\)</span>都是零面积集（<spanclass="math inline">\(I\)</span>是有界闭矩形，要证明<spanclass="math inline">\(\partialI\)</span>是零面积集，即证明线段是零面积集，这里略证），从而<spanclass="math inline">\(D(f)\)</span>是零测集，所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积。对于<spanclass="math inline">\(I\)</span>的任一分割<spanclass="math inline">\(\pi = \{ I_1, I_2, \cdots, I_k\}\)</span>，由于<span class="math inline">\(\overlineB\)</span>是零面积集，那么对任何子矩形<spanclass="math inline">\(I_i\)</span>，比如存在点<spanclass="math inline">\(\boldsymbol{\xi}_i \in I_i\)</span>，使得<br /><span class="math inline">\(f(\boldsymbol{\xi}_i) =0\)</span>，从而Riemann和<br /><span class="math display">\[    \sum_{i=1}^k f(\boldsymbol{\xi_i}) \sigma(I_i) = 0\]</span><br />由积分的存在性可知<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = 0\]</span></p><p>Q.E.D.</p><h4 id="定理9">定理9</h4><blockquote><p>设函数<span class="math inline">\(f, g\)</span>在<spanclass="math inline">\(I\)</span>上有界，且集合<spanclass="math inline">\(B = \{ \boldsymbol{x} \in I, f(\boldsymbol{x}) \neg(\boldsymbol{x}) \}\)</span>为一个零面积集，那么若<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>有一个在<spanclass="math inline">\(I\)</span>可积，则另一个也在<spanclass="math inline">\(I\)</span>上可积，并且<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_I g \mathrm{d} \sigma\]</span></p></blockquote><p>证：不妨设<span class="math inline">\(g\)</span>在<spanclass="math inline">\(I\)</span>上可积，零<span class="math inline">\(h= f - g\)</span>，由<ahref="https://gamersover.github.io/2021/06/29/函数积分8/#定理8">定理8</a>可知，<spanclass="math inline">\(h\)</span>在<spanclass="math inline">\(I\)</span>上可积，且<br /><span class="math display">\[    \int_I h \mathrm{d} \sigma = 0\]</span><br />从而<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma = \int_I h \mathrm{d} \sigma + \int_I g\mathrm{d} \sigma = \int_I g \mathrm{d} \sigma\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 二重积分 </tag>
            
            <tag> 零测集 </tag>
            
            <tag> 零面积集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分七：矩形区域的二重积分</title>
      <link href="/2021/06/21/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%867/"/>
      <url>/2021/06/21/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%867/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>定义<span class="math inline">\(f: I \to \mathbb{R}\)</span>，其中<span class="math inline">\(I\)</span>是<spanclass="math inline">\(\mathbb{R}^2\)</span>中的闭矩形，<spanclass="math inline">\(I = [a,b] \times [c, d]\)</span>，作<spanclass="math inline">\([a,b]\)</span>的分割<br /><span class="math display">\[    \pi_x : a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b;\]</span><br />又作<span class="math inline">\([c,d]\)</span>的分割<br /><span class="math display">\[    \pi_y : c = y_0 &lt; y_1 &lt; \cdots &lt; y_n = d;\]</span><br />两族平行直线<span class="math inline">\(x =x_i(i=0,1,\cdots,n)\)</span>与<spanclass="math inline">\(y=y_j(j=0,1,\cdots,m)\)</span>把<spanclass="math inline">\(I\)</span>分割成<span class="math inline">\(k= n\times m\)</span>个子矩形：<br /><span class="math display">\[    [x_{i-1}, x_i] \times [y_{j-1}, y_j] \quad (i=1,2,\cdots,n;j=1,2,\cdots,m)\]</span><br />这<span class="math inline">\(k\)</span>个子矩形的全体组成<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi = \pi_x \times\pi_y\)</span>，用一定次序重排这<spanclass="math inline">\(k\)</span>个子矩形，将它们编号为<spanclass="math inline">\(I_1,I_2,\cdots, I_k\)</span>，在每一个<spanclass="math inline">\(I_i\)</span>中任取一点<spanclass="math inline">\(\xi_i (i=1,2,\cdots,k)\)</span>，作积分和<br /><span class="math display">\[    \sum_{i=1}^k f(\xi_i) \sigma(I_i) \tag{1}\]</span><br />其中<span class="math inline">\(\sigma(I_i)\)</span>表示<spanclass="math inline">\(I_i\)</span>区域的面积。记<br /><span class="math display">\[    \Vert \pi \Vert = \max(\mathrm{diam}(I_1), \mathrm{diam}(I_2),\cdots, \mathrm{diam}(I_k))\]</span><br />这里<span class="math inline">\(\mathrm{diam}(I_i)\)</span>表示矩形<spanclass="math inline">\(I_i\)</span>的对角线的长度，称<spanclass="math inline">\(\Vert \pi \Vert\)</span>为分割<spanclass="math inline">\(\pi\)</span>的宽度。令<spanclass="math inline">\(\boldsymbol{\xi} = (\boldsymbol{\xi_1},\boldsymbol{\xi_2}, \cdots, \boldsymbol{\xi_k})\)</span>，称<spanclass="math inline">\(\boldsymbol{\xi}\)</span>为积分和<spanclass="math inline">\((1)\)</span>的值点向量，称<spanclass="math inline">\(\boldsymbol{\xi_1}, \boldsymbol{\xi_2},\cdots,\boldsymbol{\xi_k}\)</span>为值点。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>如果存在数<spanclass="math inline">\(A\)</span>，使得对任意的给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，当<spanclass="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>时，不论值点<spanclass="math inline">\(\xi_i\)</span>在子矩形<spanclass="math inline">\(I_i\)</span>中如何选择，都有<br /><span class="math display">\[    \left| \sum_{i=1}^k f(\boldsymbol{\xi_i}) \sigma(I_i) - A \right|&lt; \varepsilon\]</span><br />则称函数<span class="math inline">\(f\)</span>在矩形<spanclass="math inline">\(I\)</span>上可积，并将<spanclass="math inline">\(A\)</span>写作<br /><span class="math display">\[    \iint \limits_I f(x,y) \mathrm{d}x \mathrm{d}y \quad 或 \quad \int_If \mathrm{d} \sigma\]</span><br />称之为<span class="math inline">\(f\)</span>在矩形<spanclass="math inline">\(I\)</span>上的二重积分，也可简称为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的积分，这里<spanclass="math inline">\(f\)</span>称为被积函数，<spanclass="math inline">\(I\)</span>称为积分区域。上述定义用极限过程记为<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^kf(\boldsymbol{\xi_i}) \sigma(I_i) = A\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积，那么<spanclass="math inline">\(f\)</span>必在<spanclass="math inline">\(I\)</span>上有界。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/14/函数积分3#定理1">函数积分三的定理1</a>证明方法一样。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(I\)</span>上可积，那么<br />（1）若<span class="math inline">\(c\)</span>为任何常数，那么<spanclass="math inline">\(cf\)</span>在<spanclass="math inline">\(I\)</span>上也可积，并且<br /><span class="math display">\[    \int_I (cf) \mathrm{d} \sigma = c \int_I f \mathrm{d} \sigma\]</span><br />（2）<span class="math inline">\(f \pm g\)</span>在<spanclass="math inline">\(I\)</span>上可积，并且<br /><span class="math display">\[    \int_I (f \pm g) \mathrm{d} \sigma = \int_I f \mathrm{d} \sigma \pm\int_I g \mathrm{d} \sigma\]</span><br />（3）若<span class="math inline">\(f \ge 0\)</span>，则<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma \ge 0\]</span><br />（4）若<span class="math inline">\(f \ge g\)</span>，则<br /><span class="math display">\[    \int_I f \mathrm{d} \sigma \ge \int_I g \mathrm{d} \sigma\]</span></p></blockquote><p>证：由积分的定义易推出（1）（2）（3）；由（2）（3）易推出（4）。</p><p>Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>设<span class="math inline">\(f\)</span>定义在<spanclass="math inline">\(I\)</span>上，有分割<br /><span class="math display">\[    \pi: I_1, I_2, \cdots, I_k\]</span><br />则<br /><span class="math display">\[    S(f, \pi) = \sum_{i=1}^k f(\boldsymbol{\xi_i}) \sigma(I_i)\]</span><br />称为<span class="math inline">\(f\)</span>关于分割<spanclass="math inline">\(\pi\)</span>的Riemann和。令<br /><span class="math display">\[    m_i = \inf f(I_i), \quad M_i = \sup f(I_i) \quad (i=1,2,\cdots,k)\]</span><br />定义<br /><span class="math display">\[    \underline S(f, \pi) = \sum_{i=1}^k m_i \sigma(I_i), \quad \overlineS(f, \pi) = \sum_{i=1}^k M_i \sigma(I_i)\]</span><br />分别称为<span class="math inline">\(f\)</span>关于分割<spanclass="math inline">\(\pi\)</span>的下和与上和。</p></blockquote><h4 id="定义4">定义4</h4><blockquote><p>设分割<span class="math inline">\(\pi = \pi_x \times\pi_y\)</span>与<span class="math inline">\(\pi^\prime = \pi_x^\prime\times \pi_y^\prime\)</span>是<spanclass="math inline">\(I\)</span>的两个分割，如果<spanclass="math inline">\(\pi_x \le \pi_x^\prime\)</span>且<spanclass="math inline">\(\pi_y \le \pi^\prime\)</span>，那么称分割<spanclass="math inline">\(\pi\)</span>比<spanclass="math inline">\(\pi^\prime\)</span>粗，或者称分割<spanclass="math inline">\(\pi^\prime\)</span>比<spanclass="math inline">\(\pi\)</span>细，记<span class="math inline">\(\pi\le \pi^\prime\)</span>。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(\pi\)</span>和<spanclass="math inline">\(\pi^\prime\)</span>是矩形<spanclass="math inline">\(I\)</span>的两个分割，并且<spanclass="math inline">\(\pi \le \pi^\prime\)</span>，那么<br /><span class="math display">\[    \underline S(f, \pi) \le \underline S(f, \pi^\prime) \le \overlineS(f, \pi^\prime) \le \overline S(f, \pi)\]</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/14/函数积分3#定理2">函数积分三的定理2</a>证明方法类似。</p><h4 id="定理4">定理4</h4><blockquote><p>设<span class="math inline">\(\pi_1\)</span>和<spanclass="math inline">\(\pi_2\)</span>是<spanclass="math inline">\(I\)</span>的任何两个分割，那么<br /><span class="math display">\[    \underline S(f, \pi) \le \overline S(f, \pi)\]</span></p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/05/14/函数积分3#定理3">函数积分三的定理3</a>证明方法类似。</p><h4 id="定义5">定义5</h4><blockquote><p>所有下和构成的集合有上界，从而有上确界，令<br /><span class="math display">\[    \underline {\int}_I f \mathrm{d} \sigma = \sup \limits_\pi\underline S(f, \pi)\]</span><br />称这个数为<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的下积分；而所有上和构成的集合有下界，从而有下确界，令<br /><span class="math display">\[    \overline {\int}_I f \mathrm{d} \sigma = \inf \limits_\pi \overlineS(f, \pi)\]</span><br />称这个数为<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的上积分。</p></blockquote><h4 id="定理6">定理6</h4><blockquote><p>等式<br /><span class="math display">\[    \underline {\int}_I f \mathrm{d} \sigma = \overline {\int}_I\mathrm{d} \sigma\]</span><br />成立的充分必要条件是，对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi\)</span>，使得<br /><span class="math display">\[    \overline S(f, \pi) - \underline S(f, \pi) &lt; \varepsilon\]</span></p></blockquote><p>证：必要性。设<br /><span class="math display">\[    A = \underline {\int}_I f \mathrm{d} \sigma = \overline {\int}\mathrm{d} \sigma\]</span><br />由下积分的定义可知，对任意给定的<span class="math inline">\(\varepsilon&gt; 0\)</span>，存在矩形<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi_1\)</span>，使得<br /><span class="math display">\[    \underline S(f, \pi_1) &gt; A - \frac{\varepsilon}{2}\]</span><br />又由上积分的定义可知，存在矩形<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi_2\)</span>，使得<br /><span class="math display">\[    \overline S(f, \pi_2) &lt; A + \frac{\varepsilon}{2}\]</span><br />把分割<span class="math inline">\(\pi_1\)</span>与<spanclass="math inline">\(\pi_2\)</span>合在一起得到分割<spanclass="math inline">\(\pi\)</span>，从而有<br /><span class="math display">\[    A - \frac{\varepsilon}{2} &lt; \underline S(f, \pi_1) \le \underlineS(f, \pi) \le \overline S(f, \pi) \le \overline S(f, \pi_2) &lt; A +\frac{\varepsilon}{2}\]</span><br />从而有<br /><span class="math display">\[    \overline S (f, \pi) - \underline S(f, \pi) &lt; A +\frac{\varepsilon}{2} - (A - \frac{\varepsilon}{2}) = \varepsilon\]</span><br />充分性。有<br /><span class="math display">\[    0 \le \overline \int_I f \mathrm{d} \sigma - \underline \int_I f\mathrm{d} \sigma \le \overline S(f, \pi) - \underline S(f, \pi) &lt;\varepsilon\]</span><br />由于<spanclass="math inline">\(\varepsilon\)</span>是任意的正数，从而必有<br /><span class="math display">\[    \underline \int_I f \mathrm{d} \sigma = \overline \int_I f\mathrm{d} \sigma\]</span></p><p>Q.E.D.</p><h4 id="定理7">定理7</h4><blockquote><p>有界函数<span class="math inline">\(f\)</span>在矩形<spanclass="math inline">\(I\)</span>上可积的充分必要条件是<br /><span class="math display">\[    \underline \int_I f \mathrm{d} \sigma = \overline \int_I f\mathrm{d} \sigma\]</span><br />这个公共的值就是积分值<span class="math inline">\(\displaystyle \int_I f\mathrm{d} \sigma\)</span>。</p></blockquote><p>证：必要性。设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的积分值为<spanclass="math inline">\(A\)</span>，从而对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，必存在<spanclass="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi = \{I_1, I_2, \cdots, I_k\}\)</span>，对任意的值点$ I_i (i=1,2,,k) $，有不等式<br /><span class="math display">\[    A - \varepsilon &lt; \sum_{i=1}^k f(\boldsymbol{\xi_i}) \sigma(I_i)&lt; A + \varepsilon\]</span><br />由于<spanclass="math inline">\(\boldsymbol{\xi_i}\)</span>是任取的，所以有<br /><span class="math display">\[    A - \varepsilon \le \underline S(f, \pi) \le \overline S(f, \pi) \leA + \varepsilon\]</span><br />从而<br /><span class="math display">\[    A - \varepsilon \le \underline \int_I f \mathrm{d} \sigma \le\overline \int_I f \mathrm{d} \sigma \le A + \varepsilon\]</span><br />令<span class="math inline">\(\varepsilon \to 0\)</span>，可得<br /><span class="math display">\[    \underline \int_I f \mathrm{d} \sigma = \overline \int_I f\mathrm{d} \sigma = A\]</span><br />充分性。假设<br /><span class="math display">\[    \underline \int_I f \mathrm{d} \sigma = \overline \int_I f\mathrm{d} \sigma = A\]</span><br />成立。要证对任意<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，只要<span class="math inline">\(I\)</span>的分割<spanclass="math inline">\(\pi = \{ I_1, I_2, \cdots, I_k\}\)</span>满足<span class="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>，有<br /><span class="math display">\[    |S(f, \pi) - A| &lt; \varepsilon\]</span><br />首先有<br /><span class="math display">\[    \underline S(f, \pi) \le S(f, \pi) \le \overline S(f, \pi)\]</span><br />而<br /><span class="math display">\[    \underline S(f, \pi) \le A \le \overline S(f, \pi)\]</span><br />所以<br /><span class="math display">\[    |S(f, \pi) - A| \le \overline S(f, \pi) - \underline S(f, \pi) =\sum_{j=1}^k f(M_j - m_j) \sigma(I_j) \tag{2}\]</span><br />由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上有界，不妨设<spanclass="math inline">\(|f(\boldsymbol{p})| \le M (\boldsymbol{p} \inI)\)</span>；而由<ahref="https://gamersover.github.io/2021/06/21/函数积分7/#定理6">定理6</a>可知，存在<spanclass="math inline">\(I\)</span>的分割<spanclass="math inline">\(\pi_\varepsilon = \{J_1, J_2, \cdots,J_t\}\)</span>，使得<br /><span class="math display">\[    \overline S(f, \pi_\varepsilon) - \underline S(f, \pi_\varepsilon)&lt; \frac{\varepsilon}{2}\]</span><br />将子矩形<spanclass="math inline">\(J_i\)</span>的每一边平行的向矩形内部收缩同一距离<spanclass="math inline">\(\delta&gt;0\)</span>，得到一个开矩形<spanclass="math inline">\(\tilde{J_i} \subset J_i (i=1,2,\cdots,t)\)</span>，令<br /><span class="math display">\[    K = I \cap \left( \bigcup \limits_{i=1}^t \tilde {J_i} \right)^c\]</span><br />显然<span class="math inline">\(K\)</span>是一个闭集，取<spanclass="math inline">\(\delta\)</span>充分小，使得<br /><span class="math display">\[    \sigma(K) &lt; \frac{\varepsilon}{4M}\]</span><br />这时将<span class="math inline">\((2)\)</span>式写为<br /><span class="math display">\[     |S(f, \pi) - A| \le  \sum_{j=1}^k f(M_j - m_j) \sigma(I_j) = \sum\nolimits_1 + \sum \nolimits_2\]</span><br />其中<br /><span class="math display">\[    \begin{aligned}    \sum \nolimits_1 = \sum_{I_j \subset K} (M_j - m_j) \sigma(I_j) \\    \sum \nolimits_2 = \sum_{I_j \nsubseteq K} (M_j - m_j) \sigma(I_j)    \end{aligned}\]</span><br />一方面<br /><span class="math display">\[    \sum \nolimits_1 \le 2M \sum_{I_j \subset K} \sigma(I_j) &lt; 2M\cdot \frac{\varepsilon}{4M} = \frac{\varepsilon}{2}\]</span><br />另一方面，<span class="math inline">\(\sum \nolimits_2\)</span>中的<spanclass="math inline">\(I_j \nsubseteq K\)</span>，从而<spanclass="math inline">\(I_j\)</span>必与某个<spanclass="math inline">\(\tilde {J_i}\)</span>相交，而<spanclass="math inline">\(\Vert \pi \Vert &lt; \delta\)</span>，所以<spanclass="math inline">\(I_j \subset J_i\)</span>，所以<br /><span class="math display">\[    \begin{aligned}    \sum \nolimits_2 &amp;= \sum_{i=1}^t \sum_{I_j \subset J_i} (M_j -m_j) \sigma(I_j) \\    &amp; \le \sum_{i=1}^t (\sup f(J_i) - \inf f(J_i)) \sum_{I_j \subsetJ_i} \sigma(I_j) \\    &amp; \le \sum_{i=1}^t (\sup f(J_i) - \inf f(J_i)) \sigma(J_i) \\    &amp; = \overline S(f, \pi) - \underline S(f, \pi) &lt;\frac{\varepsilon}{2}    \end{aligned}\]</span><br />从而<br /><span class="math display">\[    \sum \nolimits_1 + \sum \nolimits_2 &lt; \frac{\varepsilon}{2} +\frac{\varepsilon}{2} = \varepsilon\]</span><br />即<br /><span class="math display">\[    |S(f, \pi) - A| &lt; \varepsilon\]</span></p><p>Q.E.D.</p><h4 id="定理8">定理8</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I = [a, b] \times [c,d]\)</span>上有界，那么以下条件等价：<br />（1）<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上可积；<br />（2）<span class="math inline">\(\displaystyle \lim_{\Vert \pi \Vert \to0} \sum_{i=1}^k \omega_i \sigma(I_i) = 0\)</span>，其中<spanclass="math inline">\(\omega_i = M_i - m_i(i=1,2,\cdots,k)\)</span>；<br />（3）对任意的<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(I\)</span>的一个分割<spanclass="math inline">\(\pi\)</span>，使得<br /><span class="math display">\[    \overline S(f, \pi) - \underline S(f, \pi) &lt; \varepsilon\]</span><br />（4）<span class="math inline">\(\displaystyle \underline \int_I f\mathrm{d} \sigma = \overline \int_I f \mathrm{d} \sigma\)</span>。</p></blockquote><p>证：<span class="math inline">\((2) \Rightarrow(3)\)</span>显然；<span class="math inline">\((3) \Rightarrow(4)\)</span>由<ahref="https://gamersover.github.io/2021/06/21/函数积分7/#定理6">定理6</a>可知；<spanclass="math inline">\((4) \Rightarrow (1)\)</span>由<ahref="https://gamersover.github.io/2021/06/21/函数积分7/#定理7">定理7</a>可知；下面证<spanclass="math inline">\(（1）\Rightarrow （2）\)</span>。假设<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的积分值为<spanclass="math inline">\(A\)</span>，由可积的定义知，对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得对于分割<spanclass="math inline">\(\pi = \{ I_1, I_2, \cdots, I_k\}\)</span>满足<span class="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>，则对任意的值点<spanclass="math inline">\(\boldsymbol{\xi_i}\)</span>有<br /><span class="math display">\[    A - \frac{\varepsilon}{2} &lt; \sum_{i=1}^k f(\xi_i) &lt; A +\frac{\varepsilon}{2}\]</span><br />由于<spanclass="math inline">\(\boldsymbol{\xi_i}\)</span>是任取的，所以<br /><span class="math display">\[    A - \frac{\varepsilon}{2} \le \underline S(f, \pi) \le \overlineS(f, \pi) \le A + \frac{\varepsilon}{2}\]</span><br />即<br /><span class="math display">\[    \overline S(f, \pi) - \underline S(f, \pi) = \sum_{i=1}^k \omega_i\sigma(I_i) &lt; \varepsilon\]</span><br />所以<br /><span class="math display">\[    \lim_{\Vert \pi \Vert \to 0} \sum_{i=1}^k \omega_i\sigma(I_i) = 0\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 二重积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分六：微积分基本定理</title>
      <link href="/2021/06/05/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%866/"/>
      <url>/2021/06/05/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%866/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1变上限积分">定义1：变上限积分</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，从而对任何<spanclass="math inline">\(x \in [a,b]\)</span>，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,x]\)</span>上也可积，因此定义函数<br /><span class="math display">\[    F(x) = \int_a^x f(t) \mathrm{d} t\]</span><br />其中<span class="math inline">\(x\)</span>可在<spanclass="math inline">\([a,b]\)</span>上变化，称<spanclass="math inline">\(F(x)\)</span>为上限变动的积分。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，那么变上限积分<spanclass="math inline">\(\displaystyle F(x) = \int_a^x f(t) \mathrm{d}t\)</span>在<span class="math inline">\([a,b]\)</span>上连续。</p></blockquote><p>证：任取一点<span class="math inline">\(x_0 \in(a,b)\)</span>，则<br /><span class="math display">\[    \begin{aligned}    F(x_0 + h) - F(x_0) &amp;= \int_a^{x_0+h} f(t) \mathrm{d} t -\int_a^{x_0} f(t) \mathrm{d} t \\    &amp;= \int_{x_0}^{x_0 + h} f(t) \mathrm{d} t    \end{aligned}\]</span><br />这里<span class="math inline">\(h\)</span>可正可负，但是<spanclass="math inline">\(x_0 + h \in [a,b]\)</span>。由于<spanclass="math inline">\(f\)</span>可知，从而由<ahref="https://gamersover.github.io/2021/05/14/函数积分3/#定理1">函数积分三的定理1</a>可知，<spanclass="math inline">\(f\)</span>有界，设<spanclass="math inline">\(|f(x)| \le M\)</span>。当<spanclass="math inline">\(h&gt;0\)</span>时，由<ahref="https://gamersover.github.io/2021/05/28/函数积分5/#定理3">函数积分五的定理3</a>可知<br /><span class="math display">\[    |F(x_0 + h) - F(x_0)| = \left| \int_{x_0}^{x_0 + h} f(t) \mathrm{d}t \right| \le \int_{x_0}^{x_0 + h} |f(t)| \mathrm{d} t \le Mh\]</span><br />当<span class="math inline">\(h &lt; 0\)</span>时，<br /><span class="math display">\[    |F(x_0 + h) - F(x_0)| = \left| \int_{x_0}^{x_0 + h} f(t) \mathrm{d}t \right| = \left| \int_{x_0+h}^{x_0} f(t) \mathrm{d} t \right| \le\int_{x_0+h}^{x_0} |f(t)| \mathrm{d} t \le M (-h) \le M|h|\]</span><br />所以<br /><span class="math display">\[    |F(x_0 + h) - F(x_0)| \le |Mh|\]</span><br />令<span class="math inline">\(h \to 0\)</span>，可知<spanclass="math inline">\(F\)</span>在<span class="math inline">\(x_0 \in(a,b)\)</span>处连续。<span class="math inline">\(x_0 =a\)</span>或<span class="math inline">\(x_0 =b\)</span>时，利用上述方法容易证得。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，在点<spanclass="math inline">\(x_0 \in [a,b]\)</span>出连续，那么<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(x_0\)</span>处可导，且<br /><span class="math display">\[    F^\prime(x_0) = f(x_0)\]</span></p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/06/05/函数积分6/#定理1">定理1</a>可得<br /><span class="math display">\[    F(x_0 + h) - F(x_0) = \int_{x_0}^{x_0 + h} f(t) \mathrm{d} t\]</span><br />从而<br /><span class="math display">\[    \begin{aligned}    \frac{F(x_0 + h) - F(x_0)}{h} - f(x_0) &amp;= \frac{1}{h}\int_{x_0}^{x_0 + h} f(t) \mathrm{d} t - \frac{1}{h} \int_{x_0}^{x_0 +h} f(x_0) \mathrm{d} t \\    &amp;= \frac{1}{h} \int_{x_0}^{x_0 + h} (f(t) - f(x_0)) \mathrm{d} t    \end{aligned}\]</span><br />由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(|t - x_0| &lt; \delta\)</span>且<spanclass="math inline">\(t \in (a,b)\)</span>时，有<br /><span class="math display">\[    |f(t) - f(x_0)| &lt; \varepsilon\]</span><br />现取<span class="math inline">\(0 &lt; |h| &lt;\delta\)</span>，从而有<br /><span class="math display">\[    \begin{aligned}    \left| \frac{F(x_0 + h) - F(x_0)}{h} - f(x_0) \right| &amp;\le\frac{1}{|h|} \left|\int_{x_0}^{x_0 + h} |f(t) - f(x_0)| \mathrm{d} t\right|\\    &amp; &lt; \frac{1}{|h|} \varepsilon |h| = \varepsilon    \end{aligned}\]</span><br />从而<br /><span class="math display">\[    F^\prime(x_0) = \lim \limits_{h \to 0} \frac{F(x_0 + h) - F(x_0)}{h}= f(x_0)\]</span><br />Q.E.D.</p><h4 id="定理3微积分基本定理">定理3：微积分基本定理</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，那么<br /><span class="math display">\[    \frac{\mathrm{d}}{\mathrm{d}x} \int_a^x f(t) \mathrm{d} t = f(x)\quad (a \le x \le b)\]</span></p></blockquote><p>证：利用<ahref="https://gamersover.github.io/2021/06/05/函数积分6/#定理2">定理2</a>可直接推出。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>[a,b]上的连续函数一定有原函数。</p></blockquote><p>证：利用<ahref="https://gamersover.github.io/2021/06/05/函数积分6/#定理3">定理3</a>可直接推出。</p><p>Q.E.D.</p><h4 id="定理5newton-leibniz">定理5：Newton-Leibniz</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，<spanclass="math inline">\(G\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的任一原函数，那么<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = G(b) - G(a)\]</span></p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/06/05/函数积分6/#定理3">定理3</a>可知<spanclass="math inline">\(\displaystyle F(x) = \int_a^x f(t) \mathrm{d}t\)</span>是<spanclass="math inline">\(f\)</span>的一个原函数，所以<br /><span class="math display">\[    \int_a^x f(t) \mathrm{d} t = G(x) + c\]</span><br />在上式中令<span class="math inline">\(x = a\)</span>，得<spanclass="math inline">\(c = -G(a)\)</span>，将<spanclass="math inline">\(c\)</span>代入上式，再令<spanclass="math inline">\(x=b\)</span>即证得。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>如果函数<span class="math inline">\(G\)</span>在<spanclass="math inline">\([a,b]\)</span>上有连续的导函数，那么<br /><span class="math display">\[    \int_a^x G^\prime(t) \mathrm{d} t = G(x) - G(a) \quad (a \le x \leb)\]</span></p></blockquote><p>证：从<ahref="https://gamersover.github.io/2021/06/05/函数积分6/#定理5：Newton-Leibniz">定理5</a>的证明过程可以立即得出。</p><p>Q.E.D.</p><h4 id="定理7taylor公式的积分余项">定理7：Taylor公式的积分余项</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上有直到<spanclass="math inline">\(n+1\)</span>阶的连续导函数，那么对任意固定的<spanclass="math inline">\(x_0 \in (a,b)\)</span>，有<br /><span class="math display">\[    f(x) = f(x_0) + \frac{1}{1!}f^\prime(x_0) (x - x_0) + \cdots +\frac{1}{n!}f^{(n)} (x_0) (x - x_0)^n + R_n(x)\]</span><br />其中<br /><span class="math display">\[    R_n (x) = \frac{1}{n!}\int_{x_0}^x (x - t)^n f^{(n+1)}(t) \mathrm{d}t \quad (a &lt; x &lt; b)\]</span></p></blockquote><p>证：记<br /><span class="math display">\[    T_n(f, x_0;x) = \sum_{k=0}^n \frac{f^{(k)}(x_0)}{k!}(x - x_0)^k\]</span><br />则<br /><span class="math display">\[    R_n(x) = f(x) - T_n(f, x_0;x)\]</span><br />可知<br /><span class="math display">\[    R_n^{(k)}(x_0) = 0 (k=0,1,\cdots,n), \quad R_n^{(n+1)}(x) =f^{(n+1)}(x)\]</span><br />连续使用分部积分公式可得<br /><span class="math display">\[    \begin{aligned}    R_n(x) &amp;= \int_{x_0}^x R^\prime_n(t) \mathrm{d} t = \int_{x_0}^xR^\prime_n(t) \mathrm{d} (t-x) \\    &amp;= (t-x)R^\prime_n(t) \Big|_{x_0}^x - \int_{x_0}^x(t-x)R_n^{\prime\prime} \mathrm{d}t \\    &amp;= -\frac{1}{2} \int_{x_0}^x R_n^{\prime\prime}(t) \mathrm{d} (t- x)^2 \\    &amp;= -\frac{1}{2} (t-x)^2 R_n^{\prime\prime}(t) \Big|_{x_0}^x +\frac{1}{2}\int_{x_0}^x (t - x)^2 R_n^{\prime\prime\prime}(t) \mathrm{d}t \\    &amp;= \frac{1}{2} \int_{x_0}^x (t - x)^2 R^{\prime\prime\prime}(t)\mathrm{d} t \\    &amp;= \cdots \\    &amp;= (-1)^n \frac{1}{n!}\int_{x_0}^x (t - x)^n R_n^{(n+1)} (t)\mathrm{d} t \\    &amp;= \frac{1}{n!} \int_{x_0}^x (x - t)^n f^{(n+1)}(t) \mathrm{d} t    \end{aligned}\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> Riemann积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分五：可积函数的性质</title>
      <link href="/2021/05/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%865/"/>
      <url>/2021/05/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%865/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1积分的可加性">定理1：积分的可加性</h4><blockquote><p>设<span class="math inline">\(c \in (a,b)\)</span>，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,c],[c,b]\)</span>上可积，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上也可积，且<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = \int_a^c f(x) \mathrm{d} x + \int_c^bf(x) \mathrm{d} x\]</span></p></blockquote><span id="more"></span><p>证：由<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理7：Lebesgue">Lebesgue定理</a>易知<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，取分割<br /><span class="math display">\[    \begin{aligned}    &amp; \pi_1: a &lt; a + \frac{1}{n}(c-a) &lt; a+\frac{2}{n}(c-a)&lt; \cdots &lt; c \\    &amp; \pi_2: c &lt; c + \frac{1}{n}(b-c) &lt; a+\frac{2}{n}(b-c)&lt; \cdots &lt; b    \end{aligned}\]</span><br />而<br /><span class="math display">\[    \begin{aligned}    \int_a^c f(x) \mathrm{d} x = \lim_{n \to \infty} \sum_{i=1}^n f(a +\frac{i}{n}(c-a)) \frac{1}{n} \\    \int_c^b f(x) \mathrm{d} x = \lim_{n \to \infty} \sum_{i=1}^n f(c +\frac{i}{n}(b-c)) \frac{1}{n}    \end{aligned}\]</span><br />取分割<span class="math inline">\(\pi = \pi_1 + \pi_2\)</span>，即<br /><span class="math display">\[    \pi: a = x_0 &lt; x_1 &lt; \cdots &lt; x_n &lt; x_{n+1} &lt; \cdots&lt; x_{2n} = b\]</span><br />其中<br /><span class="math display">\[x_i = \left\{    \begin{aligned}    &amp;a+\frac{i}{n}(c - a) &amp;(i=1, 2, \cdots, n) \\    &amp;c+\frac{i-n}{n}(b - c) &amp;(i=n+1, \cdots, 2n)    \end{aligned}\right.\]</span><br />此时有<br /><span class="math display">\[    \int_a^c f(x) \mathrm{d} x + \int_c^b f(x) \mathrm{d} x = \lim_{n\to \infty} \sum_{i=1}^{2n} f(x_i) \frac{1}{n}\]</span><br />有因为<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，所以<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = \lim_{n \to \infty} \sum_{i=1}^{2n}f(x_i) \frac{1}{n} = \int_a^c f(x) \mathrm{d} x + \int_c^b f(x)\mathrm{d} x\]</span></p><p>Q.E.D.</p><h4 id="定义1">定义1</h4><blockquote><p>为了后续积分的扩展，这里定义两个等式。设函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，则定义<br />（1）<span class="math inline">\(\displaystyle \int_a^a f(x) \mathrm{d}x = 0\)</span><br />（2）<span class="math inline">\(\displaystyle \int_b^a f(x) \mathrm{d}x = - \int_a^b f(x) \mathrm{d} x\)</span></p></blockquote><h4 id="定理2">定理2</h4><blockquote><p>如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续且非负，但<spanclass="math inline">\(f\)</span>不恒等于<spanclass="math inline">\(0\)</span>，那么<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x &gt; 0\]</span></p></blockquote><p>证：设有一点<span class="math inline">\(x_0 \in[a,b]\)</span>，使得<span class="math inline">\(f(x_0) &gt;0\)</span>，则由连续函数的性质可知，存在一个子区间<spanclass="math inline">\([\alpha, \beta]\)</span>，满足<spanclass="math inline">\(x_0 \in [\alpha, \beta] \subset[a,b]\)</span>，使得对一切<span class="math inline">\(x \in [\alpha,\beta]\)</span>有<br /><span class="math display">\[    f(x) \ge \frac{f(x_0)}{2}\]</span><br />从而<br /><span class="math display">\[    \begin{aligned}    \int_a^b f(x) \mathrm{d} x &amp;= \int_a^\alpha f(x) \mathrm{d} x +\int_{\alpha}^{\beta} f(x) \mathrm{d} x + \int_{\beta}^b f(x)\mathrm{d}x \\    &amp;\ge \int_{\alpha}^{\beta} f(x) \mathrm{d} x \ge\int_{\alpha}^{\beta} \frac{f(x_0)}{2} \mathrm{d} x = \frac{f(x_0)}{2}(\beta - \alpha) &gt; 0    \end{aligned}\]</span></p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，那么<spanclass="math inline">\(|f|\)</span>也在<spanclass="math inline">\([a,b]\)</span>上可积，且<br /><span class="math display">\[    \left| \int_a^b f(x) \mathrm{d} x\right| \le \int_a^b |f(x)|\mathrm{d}x\]</span></p></blockquote><p>证：由于<span class="math inline">\(D(|f|) \subsetD(f)\)</span>，所以<span class="math inline">\(|f|\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，而<br /><span class="math display">\[    - |f(x)| \le f(x) \le |f(x)|\]</span><br />所以<br /><span class="math display">\[    - \int_a^b |f(x)| \mathrm{d}x \le \int_a^b f(x) \mathrm{d}x \le\int_a^b |f(x)| \mathrm{d}x\]</span></p><p>Q.E.D.</p><h4 id="定理4积分平均值定理">定理4：积分平均值定理</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\([a,b]\)</span>上不改变符号，则存在<spanclass="math inline">\(\xi \in (a,b)\)</span>，使得<br /><span class="math display">\[    \int_a^b f(x)g(x) \mathrm{d} x = f(\xi) \int_a^b g(x) \mathrm{d} x\]</span></p></blockquote><p>证：不妨设当<span class="math inline">\(x \in [a,b]\)</span>时，<spanclass="math inline">\(g(x) \le 0\)</span>但不恒等于0，从而<spanclass="math inline">\(\displaystyle \int_a^b g(x) \mathrm{d} x &gt;0\)</span>。设<span class="math inline">\(m,M\)</span>分别是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的最小值和最大值，则<br /><span class="math display">\[    m \le f(x) \le M \quad (a \le x \le b)\]</span><br />从而<br /><span class="math display">\[    mg(x) \le f(x)g(x) \le M g(x)\]</span><br />求积分可得<br /><span class="math display">\[    m\int_a^b g(x) \mathrm{d} x \le \int_a^b f(x)g(x) \mathrm{d} x \leM\int_a^b g(x) \mathrm{d}x\]</span><br />所以<br /><span class="math display">\[    m \le \int_a^b f(x)g(x) \mathrm{d} x (\int_a^b g(x) \mathrm{d}x)^{-1} \le M\]</span><br />由连续函数的介值定理可知，存在一点<span class="math inline">\(\xi \in(a,b)\)</span>，使得<br /><span class="math display">\[    f(\xi) = \int_a^b f(x)g(x) \mathrm{d} x (\int_a^b g(x) \mathrm{d}x)^{-1}\]</span></p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，则存在一点<spanclass="math inline">\(\xi \in [a,b]\)</span>，使得<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = f(\xi)(b - a)\]</span></p></blockquote><p>证：令<ahref="https://gamersover.github.io/2021/05/28/函数积分5/#定理4：积分平均值定理">定理4</a>中的<spanclass="math inline">\(g = 1\)</span>，即可得。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> Riemann积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分四：Lebesgue定理</title>
      <link href="/2021/05/25/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%864/"/>
      <url>/2021/05/25/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%864/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1零测度集">定义1：零测度集</h4><blockquote><p>设<spanclass="math inline">\(A\)</span>为实数的集合，如果对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在至多可数个开区间<span class="math inline">\(\{I_n: n \in\mathbb{N}^*\}\)</span>组成<spanclass="math inline">\(A\)</span>的一个开覆盖，并且<spanclass="math inline">\(\displaystyle \sum_{n=1}^{\infty} |I_n| \le\varepsilon\)</span>(<spanclass="math inline">\(|I_n|\)</span>表示开区间<spanclass="math inline">\(I_n\)</span>的长度)，那么称<spanclass="math inline">\(A\)</span>是零测度集，简称零测集。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>至多可数个零测集的并集是零测集。</p></blockquote><p>证：设有可数个零测集<br /><span class="math display">\[    A_1,A_2,\cdots, A_n,\cdots\]</span><br />对任意给定的<span class="math inline">\(\varepsilon &gt;0\)</span>和<span class="math inline">\(n \inN^*\)</span>，存在开区间族<span class="math inline">\(\{I_{ni}: n,i \in\mathbb{N^+}\}\)</span>使得<span class="math inline">\(\displaystyle A_n\subset \bigcup \limits_{i=1}^\infty I_{ni}\)</span>，且<spanclass="math inline">\(\displaystyle \sum_{i=1}^\infty |I_{ni}| \le\frac{\varepsilon}{2^n}\)</span>，此时有<br /><span class="math display">\[    \bigcup \limits_{i=1}^\infty A_n \subset \bigcup\limits_{i=1}^\infty (\bigcup \limits_{i=1}^\infty I_{ni})\]</span><br />而<br /><span class="math display">\[    \sum_{i=1}^\infty \sum_{i=1}^\infty |I_{ni}| \le \sum_{i=1}^\infty\frac{\varepsilon}{2^n} = \varepsilon\]</span><br />这就证明了<span class="math inline">\(\displaystyle \bigcup\limits_{i=1}^\infty A_i\)</span>是零测集。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\omega\)</span>是有界函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的振幅，那么<br /><span class="math display">\[    \omega = \sup \{ |f(y_1) - f(y_2)|: y_1,y_2 \in [a,b] \}\]</span></p></blockquote><p>证：用<span class="math inline">\(M\)</span>和<spanclass="math inline">\(m\)</span>分别表示<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的上、下确界，那么由定义可知，<spanclass="math inline">\(\omega = M - m\)</span>，又由于对于任意的$y_1,y_2$，有<br /><span class="math display">\[    m \le f(y_1) \le M, \quad m \le f(y_2) \le M\]</span><br />从而<br /><span class="math display">\[    \omega = M - m \ge |f(y_1) - f(y_2)|\]</span><br />另一方面，由于<span class="math inline">\(M = \sup\{ f(y): y\in [a,b]\}\)</span>，<span class="math inline">\(m = \inf\{ f(y): y \in [a,b]\}\)</span>，所以对任意的<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(y_1,y_2 \in[a,b]\)</span>，使得<br /><span class="math display">\[    f(y_1) \ge M - \frac{\varepsilon}{2}, \quad f(y_2) \le m +\frac{\varepsilon}{2}\]</span><br />从而<br /><span class="math display">\[    |f(y_1) - f(y_2)| \ge f(y_1) - f(y_2) \ge M - m - \varepsilon =\omega - \varepsilon\]</span><br />所以<span class="math inline">\(\omega\)</span>是<spanclass="math inline">\(\{ |f(y_1) - f(y_2)|: y_1,y_2 \in [a,b]\}\)</span>的上确界。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(\omega_f(x, r)\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B_r(x)\)</span>区间的振幅，则<spanclass="math inline">\(\lim \limits_{r \to 0^+} \omega_f(x,r)\)</span>极限存在，并记<br /><span class="math display">\[    \omega_f(x) = \lim \limits_{r \to 0^+} \omega_f(x, r)\]</span><br />称<span class="math inline">\(\omega_f(x)\)</span>为<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x\)</span>处的振幅。</p></blockquote><p>证：由于<span class="math inline">\(\omega_f(x, r) \ge0\)</span>，有下界，且当<spanclass="math inline">\(r\)</span>减少时，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B_r(x)\)</span>区间的上确界<spanclass="math inline">\(M\)</span>递减，下确界<spanclass="math inline">\(m\)</span>递增，所以<spanclass="math inline">\(\omega_f(x, r)\)</span>递减，从而<spanclass="math inline">\(\displaystyle \lim \limits_{r \to 0^+} \omega_f(x,r)\)</span>存在。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x \in I\)</span>处连续的充分必要条件是<spanclass="math inline">\(\omega_f(x) = 0\)</span>。</p></blockquote><p>证：必要性。设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x \in I\)</span>处连续，则对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，当<spanclass="math inline">\(r &gt; 0\)</span>充分小时，存在<spanclass="math inline">\(y \in B_r(x)\)</span>时，有<br /><span class="math display">\[    |f(y) - f(x)| &lt; \frac{\varepsilon}{2}\]</span><br />从而当<span class="math inline">\(y_1,y_2 \inB_r(x)\)</span>时，有<br /><span class="math display">\[    |f(y_1) - f(y_2)| \le |f(y_1) - f(x)| + |f(x) - f(y_2)| &lt;\varepsilon\]</span><br />所以<span class="math inline">\(\omega_f(x, r) \le\varepsilon\)</span>，令<span class="math inline">\(r \to0^+\)</span>，此时有<span class="math inline">\(0 &lt; \omega_f(x) \le\varepsilon\)</span>，由于<spanclass="math inline">\(\varepsilon\)</span>是任取的，所以<spanclass="math inline">\(\omega_f(x) = 0\)</span>。<br />充分性。设<span class="math inline">\(\omega_f(x) =0\)</span>，则对任意的<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(r &gt;0\)</span>，使得<br /><span class="math display">\[    \omega_f(x, r) &lt; \varepsilon\]</span><br />从而对任何的<span class="math inline">\(y \in B_r(x)\)</span>，有<br /><span class="math display">\[    |f(x) - f(y)| \le \omega_f(x, r) &lt; \varepsilon\]</span><br />即表明<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x\)</span>处连续。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>对<span class="math inline">\(\delta &gt; 0\)</span>，记<br /><span class="math display">\[    D_\delta = \{ x \in [a, b]: \omega_f(x) \ge \delta\}\]</span><br />记<span class="math inline">\(D(f)\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上不连续点的全体。则有<br /><span class="math display">\[    D(f) = \bigcup \limits_{n=1}^\infty D_{1/n}\]</span></p></blockquote><p>证：任取<span class="math inline">\(x \in \bigcup\limits_{n=1}^\infty D_{1/n}\)</span>，知<spanclass="math inline">\(\omega_f(x) &gt; 0\)</span>，从而由<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理4">定理4</a>可知<spanclass="math inline">\(x\)</span>是<spanclass="math inline">\(f\)</span>的不连续点，从而<br /><span class="math display">\[    \bigcup \limits_{n=1}^\infty D_{1/n} \subset D(f) \tag{1}\]</span><br />反之，任取<span class="math inline">\(x \in D(f)\)</span>，可知<spanclass="math inline">\(\omega_f(x) &gt; 0\)</span>，从而存在充分大的<spanclass="math inline">\(m \in \mathbb{N^+}\)</span>，使得<spanclass="math inline">\(\displaystyle \omega_f(x) \ge\frac{1}{m}\)</span>，从而有<span class="math inline">\(x \inD_{1/m}\)</span>，所以<br /><span class="math display">\[    D(f) \subset \bigcup \limits_{i=1}^\infty D_{1/n} \tag{2}\]</span><br />从而由(1)和(2)可知<br /><span class="math display">\[    D(f) = \bigcup \limits_{i=1}^\infty D_{1/n}\]</span></p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(f:[a,b] \to\mathbb{R}\)</span>。如果存在一列区间<spanclass="math inline">\((\alpha_j,\beta_j)(j=1,2,\cdots,)\)</span>，使得<span class="math inline">\(D(f)\subset \bigcup \limits_{i=1}^\infty (\alpha_j,\beta_j)\)</span>，记<span class="math inline">\(K = [a,b] \backslash\bigcup \limits_{i=1}^\infty (\alpha_j,\beta_j)\)</span>，那么对任意的<span class="math inline">\(\varepsilon&gt; 0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，当<span class="math inline">\(x \in K, y \in[a,b]\)</span>，且<span class="math inline">\(|x - y| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x) - f(y)| &lt;\varepsilon\)</span>。</p></blockquote><p>证：反证法。如果结论不成立，则必存在<spanclass="math inline">\(\varepsilon_0 &gt; 0\)</span>以及<spanclass="math inline">\(s_n \in K, t_n \in [a,b]\)</span>，使得当<spanclass="math inline">\(|s_n - t_n| &lt; 1 / n\)</span>时，有<br /><span class="math display">\[    |f(s_n) - f(t_n)| \ge \varepsilon_0\]</span><br />由于<span class="math inline">\(\{s_n\} \subset K \subset[a,b]\)</span>，存在必有<spanclass="math inline">\(\{s_n\}\)</span>的子列<spanclass="math inline">\(\{s_{k_n}\}\)</span>，使得<br /><span class="math display">\[    \lim \limits_{n \to \infty} s_{k_n} = s^*\]</span><br />又由于<span class="math inline">\(K\)</span>是闭集，从而<spanclass="math inline">\(s^* \in K\)</span>。而<br /><span class="math display">\[    \begin{aligned}    |t_{k_n} - s^*| &amp;\le |t_{k_n} - s_{k_n}| + |s_{k_n} - s^*| \\    &amp; \le \frac{1}{k_n} + |s_{k_n} - s^*| \le \frac{1}{n} + |s_{k_n}- s^*|    \end{aligned}\]</span><br />令<span class="math inline">\(n \to \infty\)</span>，得<spanclass="math inline">\(t_{k_n} \to s^*\)</span>，由于<spanclass="math inline">\(s^* \in K\)</span>，所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(s^*\)</span>处连续，且<br /><span class="math display">\[    |f(s_{k_n}) - f(t_{k_n})| \ge \varepsilon_0\]</span><br />令上式左边<span class="math inline">\(n \to \infty\)</span>，得<br /><span class="math display">\[    \varepsilon_0 \le |f(s^*) - f(s^*)| = 0\]</span><br />显然与<span class="math inline">\(\varepsilon_0 &gt;0\)</span>矛盾。</p><p>Q.E.D.</p><h4 id="定理7lebesgue">定理7：Lebesgue</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在有限区间<spanclass="math inline">\([a,b]\)</span>上有界，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a.b]\)</span>上Riemann可积的充分必要条件是<spanclass="math inline">\(D(f)\)</span>是一个零测集。</p></blockquote><p>证：必要性。只需要证明对任意的<span class="math inline">\(\delta &gt;0\)</span>，<spanclass="math inline">\(D_{\delta}\)</span>是零测集，从而<spanclass="math inline">\(D_1,D_{1/2},\cdots\)</span>都是零测集，再由<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理5">定理5</a>可知<spanclass="math inline">\(D(f)\)</span>是零测集。由于<spanclass="math inline">\(f\)</span>可积，从而由<ahref="https://gamersover.github.io/2021/05/14/函数积分3/#定理5">函数积分三的定理5</a>可知对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\([a,b]\)</span>上的一个分割<br /><span class="math display">\[    \pi: a = x_0 &lt; x_1 &lt; \cdots &lt; x_m = b\]</span><br />使得<br /><span class="math display">\[    \sum_{i=1}^m \omega_i \Delta x_i &lt; \frac{\delta \epsilon}{2}\]</span><br />设<span class="math inline">\(x \in D_{\delta}\)</span>，可知如果<spanclass="math inline">\(x\)</span>不是<spanclass="math inline">\(x_0,x_1,\cdots,x_m\)</span>中的任一个，则存在<span class="math inline">\(i \in{1,2,\cdots,m}\)</span>，使得<span class="math inline">\(x \in (x_{i-1},x_i)\)</span>，因此存在充分小的<spanclass="math inline">\(r&gt;0\)</span>，使得<spanclass="math inline">\((x-r, x+r) \subset (x_{i-1},x_i)\)</span>，于是<span class="math inline">\(f\)</span>在<spanclass="math inline">\((x_{i-1}, x_i)\)</span>上的振幅<br /><span class="math display">\[    \omega_i \ge w_f(x, r) \ge w_f(x) \ge \delta\]</span><br />如果用<span class="math inline">\(\sum^\prime\)</span>和<spanclass="math inline">\(\bigcup^\prime\)</span>分别表示对满足<spanclass="math inline">\(D_{\delta} \cap (x_{i-1}, x_i) \ne\varnothing\)</span>的<spanclass="math inline">\(i\)</span>的求和与求并，则<br /><span class="math display">\[    \frac{\delta \epsilon}{2} &gt; \sum \limits_{i=1}^m \omega_i \Deltax_i \ge \sum \nolimits^\prime \omega_i \Delta x_i \ge \delta \sum\nolimits^\prime \Delta x_i\]</span><br />所以<br /><span class="math display">\[    \sum \nolimits^\prime \Delta x_i \le \frac{\varepsilon}{2}\]</span><br />而<br /><span class="math display">\[    D_\delta \subset (\bigcup \nolimits^\prime (x_{i-1}, x_i)) \bigcup\{ x_0, x_1, \cdots,x_m \}\]</span><br />自然有<br /><span class="math display">\[    D_\delta \subset (\bigcup \nolimits^\prime (x_{i-1}, x_i)) \bigcup(\bigcup_{j=0}^m (x_j - \frac{\varepsilon}{4(m+1)}, x_j +\frac{\varepsilon}{4(m+1)}))\]</span><br />而<br /><span class="math display">\[    \sum \nolimits^\prime \Delta x_i + (m+1) \frac{2\varepsilon}{4(m+1)}&lt; \frac{\varepsilon}{2} + \frac{\varepsilon}{2} = \varepsilon\]</span><br />所以<span class="math inline">\(D_\delta\)</span>是零测集。</p><p>充分性。设<spanclass="math inline">\(D(f)\)</span>是一个零测集，并且对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在一列开区间<spanclass="math inline">\((\alpha_i,\beta_i)(i=1,2,\cdots)\)</span>，使得<br /><span class="math display">\[    D(f) \subset \bigcup \limits_{i=1}^\infty (\alpha_i, \beta_i), \quad且 \quad \sum_{i=1}^\infty (\beta_i - \alpha_i) &lt;\frac{\varepsilon}{2\omega}\]</span><br />这里<span class="math inline">\(\omega\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的振幅。令<br /><span class="math display">\[    K = [a, b] \backslash \bigcup \limits_{i=1}^\infty (\alpha_i,\beta_i)\]</span><br />由<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理6">定理6</a>可知，对上述的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>， 使得当<spanclass="math inline">\(x \in K, y \in [a, b]\)</span>且<spanclass="math inline">\(|x - y| &lt; \delta\)</span>时，有<br /><span class="math display">\[    |f(x) - f(y)| &lt; \frac{\varepsilon}{4(b - a)}\]</span><br />现取分割<br /><span class="math display">\[    \pi : a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b\]</span><br />且<span class="math inline">\(\Vert \pi \Vert &lt;\delta\)</span>，记<br /><span class="math display">\[    \sum_{i=1}^\infty \omega_i \Delta x_i = \sum \nolimits_1 \omega_i\Delta x_i + \sum \nolimits_2 \omega_i \Delta x_i\]</span><br />其中<span class="math inline">\(\sum_1\)</span>表示对满足<spanclass="math inline">\(K \cap (x_{i-1}, x_i) \ne\varnothing\)</span>的<spanclass="math inline">\(i\)</span>的求和，<spanclass="math inline">\(\sum_2\)</span>表示对满足<spanclass="math inline">\(K \cap (x_{i-1}, x_i) =\varnothing\)</span>的<spanclass="math inline">\(i\)</span>的求和。对<spanclass="math inline">\(\sum_1\)</span>中的项，任取<spanclass="math inline">\(y_i \in K \cap (x_{i-1}, x_i)\)</span>，由<ahref="https://gamersover.github.io/2021/05/25/函数积分4/#定理6">定理6</a>得<br /><span class="math display">\[    \begin{aligned}    \omega_i &amp;= sup\{ |f(z_1) - f(z_2)|: z_1, z_2 \in [x_{i-1}, x_i]\} &amp; \\    &amp;\le sup\{ |f(z_1) - f(y_i)| + |f(z_2) - f(y_i)|: z_1,z_2 \in[x_{i-1}, x_i], y_i \in K \cap (x_{i-1}, x_i)\} \\    &amp; \le \frac{\varepsilon}{2(b-a)}    \end{aligned}\]</span><br />所以<br /><span class="math display">\[    \sum \nolimits_1 \omega_i \Delta x_i &lt; \frac{\varepsilon}{2(b-a)}(b-a) = \frac{\varepsilon}{2}\]</span><br />对于<span class="math inline">\(\sum_2\)</span>中的项，当<spanclass="math inline">\(x \in (x_{i-1}, x_i)\)</span>时，必有<spanclass="math inline">\(x \notin K\)</span>，所以<spanclass="math inline">\(\displaystyle x \in \bigcup_{i=1}^\infty(\alpha_i, \beta_i)\)</span>，即<spanclass="math inline">\(\displaystyle (x_{i-1}, x_i) \subset\bigcup_{i=1}^\infty (\alpha_i, \beta_i)\)</span>，所以<br /><span class="math display">\[    \sum \nolimits_2 \omega_i \Delta x_i \le \omega \sum \nolimits_2\Delta x_i &lt; \omega \frac{\varepsilon}{2\omega} =\frac{\varepsilon}{2}\]</span><br />所以<br /><span class="math display">\[    \sum_{i=1}^\infty \omega_i \Delta x_i &lt; \varepsilon\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> Riemann积分 </tag>
            
            <tag> 零测集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分三：可积性理论</title>
      <link href="/2021/05/14/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%863/"/>
      <url>/2021/05/14/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%863/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1">定理1</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上Riemann可积，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上有界。</p></blockquote><span id="more"></span><p>证：设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的积分为<spanclass="math inline">\(I\)</span>，则由<ahref="https://gamersover.github.io/2021/04/28/函数积分2/#定义2：Riemann积分">函数积分二的定义2</a>可知，对<spanclass="math inline">\(\varepsilon = 1\)</span>，必存在一个分割<spanclass="math inline">\(\pi\)</span>，使得<br /><span class="math display">\[    \left| \sum_{i=1}^nf(\xi_i) \Delta x_i - I \right| &lt; I\]</span><br />这里值点<span class="math inline">\(\xi_i \in [x_{i-1}, x_i] (1 \le i\le n)\)</span>可以任取，由上式可得<br /><span class="math display">\[    \left| \sum_{i=1}^n f(\xi_i) \Delta x_i \right| &lt; |I| + 1\]</span><br />从而有<br /><span class="math display">\[    |f(\xi_1)| \Delta x_1 &lt; |I| + 1 + \left| \sum_{i=2}^n f(\xi_i)\Delta x_i \right|\]</span><br />即<br /><span class="math display">\[    |f(\xi_1)| &lt; \frac{1}{\Delta x_1} \left( |I| + 1 + \left|\sum_{i=2}^n f(\xi_i) \Delta x_i \right| \right)\]</span><br />此时，把在<span class="math inline">\([x_{i-1}, x_i]\)</span>中的<spanclass="math inline">\(\xi_i\)</span>固定下来<spanclass="math inline">\((i=2,3,\cdots,n)\)</span>，则上式右边是一个确定的正数，而<spanclass="math inline">\(\xi_i\)</span>可以在<spanclass="math inline">\([x_0,x_1]\)</span>上任取，这就证明了<spanclass="math inline">\(f\)</span>在区间<spanclass="math inline">\([x_0,x_1]\)</span>上有界。同理<spanclass="math inline">\(f\)</span>在子区间<spanclass="math inline">\([x_{i-1},x_i](i=2,3,\cdots,n)\)</span>上都是有界的，所以<spanclass="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有界。</p><p>Q.E.D.</p><h4 id="定义1振幅">定义1：振幅</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有界，用<spanclass="math inline">\(M\)</span>与<spanclass="math inline">\(m\)</span>分别表示<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的上确界和下确界，令<spanclass="math inline">\(\omega = M - m\)</span>，称<spanclass="math inline">\(\omega\)</span>为函数<spanclass="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上的振幅。</p></blockquote><h4 id="定义2上和与下和">定义2：上和与下和</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有界，对<spanclass="math inline">\([a,b]\)</span>上的任何分割<br /><span class="math display">\[    \pi : a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b\]</span><br />在<span class="math inline">\(\pi\)</span>的第<spanclass="math inline">\(i\)</span>个子区间<spanclass="math inline">\([x_i-1, x_i]\)</span>上<spanclass="math inline">\(f\)</span>的上确界与下确界分别记为<spanclass="math inline">\(M_i\)</span>与<spanclass="math inline">\(m_i\)</span>，并令<spanclass="math inline">\(\omega_i = M_i - m_i\)</span>，称<spanclass="math inline">\(\omega_i\)</span>为<spanclass="math inline">\(f\)</span>在<span class="math inline">\([x_{i-1},x_i]\)</span>上的振幅，这里<spanclass="math inline">\(i=1,2,\cdots,n\)</span>。定义<br /><span class="math display">\[    \overline S (f, \pi) = \sum_{i=1}^n M_i \Delta x_i, \quad \underlineS(f, \pi) = \sum_{i=1}^n m_i \Delta x_i\]</span><br />并分别称它们是<span class="math inline">\(f\)</span>关于分割<spanclass="math inline">\(\pi\)</span>的上和与下和。</p></blockquote><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\pi\)</span>与<spanclass="math inline">\(\pi^\prime\)</span>是<spanclass="math inline">\([a,b]\)</span>上的两个分割，其中<spanclass="math inline">\(\pi^\prime\)</span>是在<spanclass="math inline">\(\pi\)</span>的分点上多加了<spanclass="math inline">\(k\)</span>个新的分点而成的，则<br /><span class="math display">\[    \begin{aligned}    \underline S(f, \pi) \le \underline S(f, \pi^\prime) \le \underlineS(f, \pi) + k\omega \Vert \pi \Vert \\    \overline S (f, \pi) \ge \overline S(f, \pi^\prime) \ge \overlineS(f, \pi) - k \omega \Vert \pi \Vert    \end{aligned}\]</span></p></blockquote><p>证：首先考虑<span class="math inline">\(k=1\)</span>的情况，即<spanclass="math inline">\(\pi^\prime\)</span>是在<spanclass="math inline">\(\pi\)</span>的分点上添加了1个新的分点，不失一般性，可设在第<spanclass="math inline">\(i\)</span>个区间<spanclass="math inline">\([x_{i-1}, x_i]\)</span>内再加上一个分点<spanclass="math inline">\(x^*\)</span>。即<br /><span class="math display">\[    \pi^\prime : a = x_0 &lt; x_1 &lt; \cdots x_{i-1} &lt; x^* &lt;  x_i&lt; \cdots &lt; a_n = b\]</span><br />这时有<br /><span class="math display">\[    \begin{aligned}    \underline S(f, \pi) - \underline S(f, \pi^\prime) &amp;= m_i \Deltax_i - ((x^* - x_{i-1}) \inf f([x_{i-1}, x^*]) + (x_i - x^*) \inf f([x^*,x_i])) \\    &amp; \le m_i \Delta x_i - ((x^* - x_{i-1}) m_i + (x_i - x^*)m_i)  \\    &amp;= 0    \end{aligned}\]</span><br />即$ (f, ) (f, ^) $，另一方面，显然有<br /><span class="math display">\[    \begin{aligned}    \underline S(f, \pi) - \underline S(f, \pi^\prime) &amp;= m_i \Deltax_i - ((x^* - x_{i-1}) \inf f([x_{i-1}, x^*]) + (x_i - x^*) \inf f([x^*,x_i])) \\    &amp; \ge m_i \Delta x_i - ((x^* - x_{i-1}) M_i + (x_i - x^*)M_i)  \\    &amp; = -\omega_i \Delta x_i \ge -\omega_i \Vert \pi \Vert \ge\omega \Vert \pi \Vert    \end{aligned}\]</span><br />即$ (f, ^) (f, ) + $。<br />从而得到<br /><span class="math display">\[    \underline S(f, \pi) \le \underline S(f, \pi^\prime) \le \underlineS(f, \pi) + \omega \Vert \pi \Vert\]</span><br />类似地，可以得到<br /><span class="math display">\[    \overline S (f, \pi) \ge \overline S(f, \pi^\prime) \ge \overlineS(f, \pi) - \omega \Vert \pi \Vert\]</span></p><p>从而，易知当<spanclass="math inline">\(k\)</span>为愿意正整数时，结论成立。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>对于任意两个分割，一个分割的下和总是不超过另一个分割的上和。</p></blockquote><p>证：设<span class="math inline">\(\pi_1\)</span>与<spanclass="math inline">\(\pi_2\)</span>是<spanclass="math inline">\([a,b]\)</span>上的两个分割，如果<spanclass="math inline">\(\pi_1\)</span>的所有分点都是<spanclass="math inline">\(\pi_2\)</span>的分点，则称分割<spanclass="math inline">\(\pi_2\)</span>比<spanclass="math inline">\(\pi_1\)</span>更细或者分割<spanclass="math inline">\(\pi_1\)</span>比<spanclass="math inline">\(\pi_2\)</span>更粗，记为<spanclass="math inline">\(\pi_1 \le \pi_2\)</span>；将<spanclass="math inline">\(\pi_1\)</span>的分点与<spanclass="math inline">\(\pi_2\)</span>的分点合并组成新的分割记为<spanclass="math inline">\(\pi = \pi_1 + \pi_2\)</span>，则显然有<spanclass="math inline">\(\pi_1 + \pi_2 \le \pi_i (i=1,2)\)</span>，则由<ahref="https://gamersover.github.io/2021/05/14/函数积分3/#定理2">定理2</a>可知<br /><span class="math display">\[    \underline S(f, \pi_1) \le \underline S(f, \pi) \le \overline S(f,\pi) \le \overline S(f, \pi_2)\]</span></p><p>Q.E.D.</p><h4 id="定义3上积分和下积分">定义3：上积分和下积分</h4><blockquote><p>所有上和组成的集合有下界，从而有下确界，用<spanclass="math inline">\(\overlineI\)</span>表示上和的下确界，并称之为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的上积分；所有下和组成的集合有上界，从而有上确界，用<spanclass="math inline">\(\underlineI\)</span>表示下和的上确界，并称之为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的下积分；并有<br /><span class="math display">\[    \underline f(f, \pi_1) \le \underline I \le \overline I \le\overline S(f, \pi_2)\]</span><br />这里<span class="math inline">\(\pi_1\)</span>与<spanclass="math inline">\(\pi_2\)</span>是<spanclass="math inline">\([a,b]\)</span>上的任意两个分割。</p></blockquote><h4 id="定理4darboux">定理4：Darboux</h4><blockquote><p>对<spanclass="math inline">\([a,b]\)</span>上的任意有界函数，有<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \overline S(f, \pi) = \overlineI, \quad  \lim \limits_{\Vert \pi \Vert \to 0} \underline S(f, \pi) =\underline I\]</span></p></blockquote><p>证：这里证明第二个等式，第一个等式的证明方法类似。按照定义，有<br /><span class="math display">\[    \underline I = \sup_m  \underline S(f, \pi)\]</span><br />从而对任意的<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<spanclass="math inline">\([a,b]\)</span>上的一个分割<spanclass="math inline">\(\pi_0\)</span>，使得<br /><span class="math display">\[    \underline S (f, \pi_0) &gt; \underline I - \frac{\varepsilon}{2}\]</span><br />设<span class="math inline">\(\pi_0\)</span>有<spanclass="math inline">\(l\)</span>个内分点，将<spanclass="math inline">\(\pi_0\)</span>和<spanclass="math inline">\(\pi\)</span>的分点组合称新的分割<spanclass="math inline">\(\pi^\prime\)</span>，则<spanclass="math inline">\(\pi^\prime\)</span>是在<spanclass="math inline">\(\pi\)</span>的分点基础上至多添加了<spanclass="math inline">\(l\)</span>个分点的分割，从而由<ahref="https://gamersover.github.io/2021/05/14/函数积分3/#定理2">定理2</a>可知，<br /><span class="math display">\[    \underline S(f, \pi^\prime) \le \underline S(f, \pi) + l\omega \Vert\pi \Vert\]</span><br />则<br /><span class="math display">\[    \underline S(f, \pi) \ge \underline S(f, \pi^\prime) - l\omega \Vert\pi \Vert \ge \underline S(f, \pi_0) - l\omega \Vert \pi \Vert &gt;\underline I - \frac{\varepsilon}{2} - l\omega \Vert \pi \Vert\]</span><br />即<br /><span class="math display">\[    \underline I - \underline S(f, \pi) &lt; \frac{\varepsilon}{2} + l\omega \Vert \pi \Vert\]</span><br />所以对任意<span class="math inline">\(\varepsilon &gt;0\)</span>，只要有<br /><span class="math display">\[    \Vert \pi \Vert &lt; \frac{\varepsilon}{2l\omega + 1}\]</span><br />则<br /><span class="math display">\[    0 &lt; \underline I - \underline S(f, \pi) &lt;\frac{\varepsilon}{2} + \frac{\varepsilon}{2} = \varepsilon\]</span><br />即<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \underline S(f, \pi) =\underline I\]</span></p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f:[a,b] \to\mathbb{R}\)</span>有界，则以下三个条件互相等价：<br />（1）<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积；<br />（2）<span class="math inline">\(\displaystyle \lim \limits_{\Vert \pi\Vert \to 0} \sum_{i=1}^n \omega_i \Delta x_i = 0\)</span>，其中<spanclass="math inline">\(\omega_i = M_i - m_i\)</span>是<spanclass="math inline">\(f\)</span>在<span class="math inline">\([x_{i-1},x_i] (i=1,2,\cdots,n)\)</span>上的振幅；<br />（3）<span class="math inline">\(\underline I = \overlineI\)</span>。</p></blockquote><p>证：<span class="math inline">\((1)\Rightarrow (2)\)</span><br />设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的积分值为<spanclass="math inline">\(I\)</span>，则对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得对任意满足<spanclass="math inline">\(\Vert \pi \Vert &lt; \delta\)</span>的分割<spanclass="math inline">\(\pi\)</span>，有<br /><span class="math display">\[    I - \frac{\varepsilon}{3} &lt; \sum_{i=1}^n f(\xi_i) \Delta x_i &lt;I + \frac{\varepsilon}{3}\]</span><br />对一切值点<span class="math inline">\(\xi_i \in [x_{i-1}, x_i](i=1,2,\cdots,n)\)</span>成立，从而有<br /><span class="math display">\[    I - \frac{\varepsilon}{3} \le \underline S(f, \pi) \le \overlineS(f, \pi) \le I - \frac{\varepsilon}{3}\]</span><br />从而有<br /><span class="math display">\[    0 &lt; \sum_{i=1}^n \omega_i \Delta x_i \le I -\frac{2}{3}\varepsilon &lt; \varepsilon\]</span><br /><span class="math inline">\((2)\Rightarrow (3)\)</span><br />若（2）成立，则有<br /><span class="math display">\[    0 \le \overline I - \underline I \le \overline S(f, \pi) -\underline S(f, \pi) = \sum \limits_{i=1}^n \omega_i \Delta x_i &lt;\varepsilon\]</span><br />由于<spanclass="math inline">\(\varepsilon\)</span>是任何的正数，所以<spanclass="math inline">\(\overline I = \underline I\)</span>。<br /><span class="math inline">\((3) \Rightarrow (1)\)</span><br />设<span class="math inline">\(\overline I = \underline I =I\)</span>，则对任意的分割<spanclass="math inline">\(\pi\)</span>，有<br /><span class="math display">\[    \underline S(f, \pi) \le \sum_{i=1}^n f(\xi_i) \Delta x_i \le\overline S(f, \pi)\]</span><br />两边同时取极限<span class="math inline">\(\Vert \pi \Vert \to0\)</span>，得到<br /><span class="math display">\[    \underline I \le \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^nf(\xi_i) \Delta x_i \le \overline I\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{\Vert \pi \Vert \to 0} \sum_{i=1}^n f(\xi_i) \Deltax_i = I\]</span><br />即<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(f\)</span>是定义在<spanclass="math inline">\([a,b]\)</span>上的单调函数，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积。</p></blockquote><p>证：不失一般性，不妨设<spanclass="math inline">\(f\)</span>是递增函数，若<spanclass="math inline">\(f(a)=f(b)\)</span>，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上是常数，显然可积。下面设<spanclass="math inline">\(f(b) &gt; f(a)\)</span>，对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，有<br /><span class="math display">\[    \begin{aligned}        0 &amp; \le \sum_{i=1}^n \omega_i \Delta x_i = \sum\limits_{i=1}^n (M_i - m_i) \Delta x_i \\        &amp; \le \sum_{i=1}^n (f(x_i) - f(x_{i-1})) \Delta x_i \\        &amp; \le \Vert \pi \Vert (f(b) - f(a))    \end{aligned}\]</span><br />所以取<span class="math inline">\(\displaystyle \delta =\frac{\varepsilon}{f(b) - f(a)}\)</span>，只要分割<spanclass="math inline">\(\pi\)</span>满足<span class="math inline">\(\Vert\pi \Vert &lt; \delta\)</span>，就有<br /><span class="math display">\[    0 &lt; \sum \limits_{i=1}^n \omega_i \Delta x_i &lt; \varepsilon\]</span><br />所以<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积。</p><p>Q.E.D.</p><h4 id="定理7">定理7</h4><blockquote><p>设<span class="math inline">\(f: [a,b] \to\mathbb{R}\)</span>是连续函数，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积。</p></blockquote><p>证：由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上一致连续，所以对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，必有<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(s, t \in [a,b]\)</span>且<spanclass="math inline">\(|s - t| &lt; \delta\)</span>时，有<br /><span class="math display">\[    |f(s) - f(t)| &lt; \frac{\varepsilon}{b - a}\]</span><br />对<span class="math inline">\([a,b]\)</span>上的一个分割<br /><span class="math display">\[    \pi: a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b\]</span><br />设<br /><span class="math display">\[    M_i = f(s_i), \quad m_i = f(t_i)\]</span><br />其中<span class="math inline">\(s_i, t_i \in [x_{i-1}, x_i](i=1,2,\cdots,n)\)</span>，只要<span class="math inline">\(\Vert \pi\Vert &lt; \delta\)</span>，就有<br /><span class="math display">\[    |s_i - t_i| \le \Delta x_i \le \Vert \pi \Vert &lt; \delta\]</span><br />从而有<br /><span class="math display">\[    \begin{aligned}    \sum_{i=1}^n \omega_i \Delta x_i = \sum \limits_{i=1}^n (M_i - m_i)\Delta x_i &amp;= \sum \limits_{i=1}^n (f(s_i) - f(t_i)) \Delta x_i \\    &amp; &lt; \frac{\varepsilon}{b - a} \sum_{i=1}^n \Delta x_i =\varepsilon    \end{aligned}\]</span><br />所以<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> Riemann积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI开发之pyQt5-3：按钮类控件</title>
      <link href="/2021/05/14/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-3/"/>
      <url>/2021/05/14/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-3/</url>
      
        <content type="html"><![CDATA[<p>按钮类控件主要包含：</p><ul><li>QPushButton：普通按钮</li><li>QRadioButton：单选框按钮</li><li>QCheckBox：多选框按钮</li></ul><span id="more"></span><h3 id="qpushbutton-普通按钮">QPushButton （普通按钮）</h3><p>展示：</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI开发 </tag>
            
            <tag> Qt </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解23：合并K个升序链表</title>
      <link href="/2021/05/05/leetcode%E9%A2%98%E8%A7%A323/"/>
      <url>/2021/05/05/leetcode%E9%A2%98%E8%A7%A323/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/merge-k-sorted-lists">力扣第23题</a></p><p>给你一个链表数组，每个链表都已经按升序排列。<br />请你将所有链表合并到一个升序链表中，返回合并后的链表。<br /><span id="more"></span><br /> <br />示例 1：</p><blockquote><p>输入：lists = [[1,4,5],[1,3,4],[2,6]]<br />输出：[1,1,2,3,4,4,5,6]<br />解释：链表数组如下：<br />[<br />1-&gt;4-&gt;5,<br />1-&gt;3-&gt;4,<br />2-&gt;6]<br />将它们合并到一个有序链表中得到。<br />1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p></blockquote><p>示例 2：</p><blockquote><p>输入：lists = []<br />输出：[]</p></blockquote><p>示例 3：</p><blockquote><p>输入：lists = [[]]<br />输出：[]</p></blockquote><p>提示：</p><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i]</code> 按 升序 排列</li><li><code>lists[i].length</code> 的总和不超过 <code>10^4</code></li></ul><h2 id="分析">分析</h2><p>该题的想法应该很简单：利用归并排序的思想，利用<code>k</code>个指针分别指向<code>k</code>个链表的头，然后比较<code>k</code>个指针指向的数的大小，将最小的那个添加到结果链表中，然后将取得最小值的那个链表的指针指向下个结点，接着继续比较<code>k</code>个指针指向的数的大小，重复上述步骤。</p><p>该题关键在于是不是每次都需要重新比较<code>k</code>个数的大小，这样比较每次都要<code>o(klogk)</code>的时间复杂度。显然不是，对于一个已经排好序的数列，每次只需要进出一个数，这时可以考虑用最小堆实现的优先队列，该数据结构可以在排好序的数组中插入一个新的数，且时间复杂度降到<code>o(logk)</code>。关于最大堆最小堆的原理可以查看这篇博客<ahref="https://blog.csdn.net/cetrol_chen/article/details/80377552">java数据结构：基于树的堆</a>。</p><h2 id="算法">算法</h2><ol type="1"><li>使用最小堆维护一个优先队列<code>pqueue</code></li><li>遍历所有链表的头指针，并添加到<code>pqueue</code></li><li>初始化结果伪链表头<code>fhead</code>和当前结点<code>curr=fhead</code>，进入循环体，直到<code>pqueue</code>为空</li><li>令<code>node=pqueue.pop()</code>，并将<code>node</code>添加到结果链表中<code>curr-&gt;next = node</code>，更新<code>curr=curr-&gt;next</code></li><li>如果<code>node.next</code>不为空指针，则将<code>node.next</code>添加到<code>pqueue</code>中，回到第4步，并直到循环结束</li><li>返回<code>fhead-&gt;next</code></li></ol><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, val=<span class="number">0</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="built_in">next</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeKLists</span>(<span class="params">self, lists</span>):</span><br><span class="line">        plist = []</span><br><span class="line">        <span class="comment"># 由于headq不能自定义比较器，所以需要一个序号i，在结点的val相同时，比较序号来排序</span></span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> lists:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(plist, (node.val, i, node))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        fhead = ListNode()</span><br><span class="line">        curr = fhead</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(plist) &gt; <span class="number">0</span>:</span><br><span class="line">            node = heapq.heappop(plist)[<span class="number">2</span>]</span><br><span class="line">            curr.<span class="built_in">next</span> = node</span><br><span class="line">            curr = curr.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> node.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                heapq.heappush(plist, (node.<span class="built_in">next</span>.val, i, node.<span class="built_in">next</span>))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fhead.<span class="built_in">next</span></span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">        ListNode *node;</span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Item &amp;item) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> node-&gt;val &gt; item.node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;Item&gt; plist;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) plist.<span class="built_in">push</span>(&#123; node &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fhead, *curr = &amp;fhead;</span><br><span class="line">        <span class="keyword">while</span> (!plist.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> item = plist.<span class="built_in">top</span>();</span><br><span class="line">            plist.<span class="built_in">pop</span>();</span><br><span class="line">            curr-&gt;next = item.node;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (item.node-&gt;next) plist.<span class="built_in">push</span>(&#123; item.node-&gt;next &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Item</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Item&gt;&#123;</span><br><span class="line">        ListNode node;</span><br><span class="line"></span><br><span class="line">        Item(ListNode node)&#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Item item2)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.node.val - item2.node.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Item&gt; pqueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Item&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ListNode node : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) pqueue.offer(<span class="keyword">new</span> <span class="title class_">Item</span>(node));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fhead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> fhead;</span><br><span class="line">        <span class="keyword">while</span> (!pqueue.isEmpty())&#123;</span><br><span class="line">            <span class="type">Item</span> <span class="variable">item</span> <span class="operator">=</span> pqueue.poll();</span><br><span class="line">            curr.next = item.node;</span><br><span class="line">            curr = curr.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(item.node.next != <span class="literal">null</span>) pqueue.offer(<span class="keyword">new</span> <span class="title class_">Item</span>(item.node.next));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fhead.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 链表 </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 最小堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI开发之PyQt5二：文本类控件</title>
      <link href="/2021/05/02/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-2/"/>
      <url>/2021/05/02/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-2/</url>
      
        <content type="html"><![CDATA[<p>文本类控件主要包含：</p><ul><li>QLineEdit：单行文本编辑框</li><li>QTextEdit：多行文本编辑框</li></ul><span id="more"></span><h3 id="qlineedit单行文本编辑框">QLineEdit（单行文本编辑框）</h3><p>展示<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/pyqt%E6%95%99%E7%A8%8B/No4.gif" width="25%"></p><p>该控件一般用来输入用户名或密码等简要内容，其写法如下：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">line_edit = QLineEdit()</span><br><span class="line">line_edit.setPlaceholderText(<span class="string">&quot;密码&quot;</span>)</span><br><span class="line">line_edit.setClearButtonEnabled(<span class="literal">True</span>)</span><br><span class="line">line_edit.setEchoMode(QLineEdit.EchoMode.Password)</span><br></pre></td></tr></table></figure><br />其基本属性包含：</p><table><colgroup><col style="width: 5%" /><col style="width: 36%" /><col style="width: 58%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">API</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">设置文本属性</td><td style="text-align: left;">setText(text: str)</td><td style="text-align: left;">设置显示的文本</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setMaxLength(a0: int)</td><td style="text-align: left;">设置文本最大长度</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setEchoMode(a0: 'QLineEdit.EchoMode')</td><tdstyle="text-align: left;">输入文本不可见，一般用在输入密码时保护隐私，以小圆点替代输入的文本来显示</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setAlignment(flag:typing.Union[QtCore.Qt.Alignment, QtCore.Qt.AlignmentFlag])</td><tdstyle="text-align: left;">文本的显示对齐方式，有居中对齐，左对齐，右对齐等</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setReadOnly(a0: bool)</td><td style="text-align: left;">可知设置为只读模式，这时不能编辑</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setPlaceholderText(a0: str)</td><td style="text-align: left;">设置占位提示文本</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setCompleter(completer: QCompleter)</td><td style="text-align: left;">设置文本自动补全</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setFont(a0: QtGui.QFont)</td><td style="text-align: left;">设置文本字体</td></tr><tr class="odd"><td style="text-align: left;">获取文本状态</td><td style="text-align: left;">text()-&gt;str</td><td style="text-align: left;">获取文本</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">displayText()-&gt;str</td><tdstyle="text-align: left;">获取显示的文本，和显示的内容保持一致。如果是普通文本，则和<code>text()</code>返回的值一样；如果设置了<code>EchoMode</code>为密码类型，则返回小圆点。</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">placeholderText()-&gt;str</td><td style="text-align: left;">获取占位提示文本</td></tr><tr class="even"><td style="text-align: left;">操作文本内容</td><td style="text-align: left;">insert(a0: str)</td><td style="text-align: left;">在当前光标后插入文本</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">clear()</td><td style="text-align: left;">删除所有内容</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setClearButtonEnabled(enable: bool)</td><td style="text-align: left;">添加文本清除按钮</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">selectAll()</td><td style="text-align: left;">选中所有内容</td></tr><tr class="even"><td style="text-align: left;">其他</td><td style="text-align: left;">setFocus()</td><td style="text-align: left;">设置为焦点（即当前操作对象）</td></tr></tbody></table><h3 id="qtextedit多行文本编辑框">QTextEdit（多行文本编辑框）</h3><p>展示<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/pyqt%E6%95%99%E7%A8%8B/No5.gif" width="25%"></p><p>该控件用来实现大量文本的输入与显示，写法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text_edit = QTextEdit()</span><br><span class="line">text_edit.setPlaceholderText(<span class="string">&quot;请输入&quot;</span>)</span><br></pre></td></tr></table></figure><p>基本属性有：</p><table><colgroup><col style="width: 6%" /><col style="width: 43%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">API</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">设置文本属性</td><td style="text-align: left;">setPlainText(text: str)</td><td style="text-align: left;">设置普通文本</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setHtml(text: str)</td><td style="text-align: left;">设置html文本</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setText(text: str)</td><tdstyle="text-align: left;">设置文本，根据text参数判断为普通文本还是html文本，不建议使用，而是直接使用<code>setPlainText</code>或<code>setHtml</code></td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setMarkdown(markdown: str)</td><td style="text-align: left;">设置markdown文本</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setAlignment(self, flag:typing.Union[QtCore.Qt.Alignment, QtCore.Qt.AlignmentFlag])</td><tdstyle="text-align: left;">文本的显示对齐方式，有居中对齐，左对齐，右对齐等</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setReadOnly(self, a0: bool)</td><td style="text-align: left;">可知设置为只读模式，这时不能编辑</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setPlaceholderText(placeholderText:str)</td><td style="text-align: left;">设置占位提示文本</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setLineWrapMode(mode:'QTextEdit.LineWrapMode')</td><tdstyle="text-align: left;">当参数为<code>NoWrap</code>时，文本长度宽度后不自动换行显示，这时通过拖动水平滚动条查看超出的内容</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setFont(a0: QtGui.QFont)</td><td style="text-align: left;">设置文本字体</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setTextColor(c: typing.Union[QtGui.QColor,QtCore.Qt.GlobalColor, QtGui.QGradient])</td><td style="text-align: left;">设置字体颜色</td></tr><tr class="odd"><td style="text-align: left;">获取文本状态</td><td style="text-align: left;">toPlainText()-&gt;str</td><td style="text-align: left;">将显示文本转换为普通文本并返回</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">toHtml()-&gt;str</td><td style="text-align: left;">将显示文本转换为html文本并返回</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">toMarkdown()-&gt;str</td><td style="text-align: left;">将显示文本转换为markdown文本并返回</td></tr><tr class="even"><td style="text-align: left;">操作文本内容</td><td style="text-align: left;">insertHtml(text: str)</td><td style="text-align: left;">在当前光标后插入html文本</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">insertPlainText(text: str)</td><td style="text-align: left;">在当前光标后插入普通文本</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">clear()</td><td style="text-align: left;">清除所有内容</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">selectAll()</td><td style="text-align: left;">选中所有内容</td></tr><tr class="even"><td style="text-align: left;">其他</td><td style="text-align: left;">setFocus()</td><td style="text-align: left;">设置为焦点（即当前操作对象）</td></tr></tbody></table><h3 id="字体和字体颜色">字体和字体颜色</h3><p>文本类肯定离不开字体以及字体颜色，而Qt5的字体类型与字体颜色是分开的，都是在<code>QtGui</code>类中</p><h4 id="字体">字体</h4><p>字体在<code>QtGui.QFont</code>类中，初始化方法<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">font = QFont(family: <span class="built_in">str</span>, pointSize: <span class="built_in">int</span>, weight: <span class="built_in">int</span>, italic: <span class="built_in">bool</span>)</span><br></pre></td></tr></table></figure></p><ul><li>family：字体风格</li><li>pointSize：字体大小，可选参数</li><li>weight：字体粗细，可选参数</li><li>italic：是否斜体，可选参数</li></ul><p>基本属性有：</p><table><colgroup><col style="width: 11%" /><col style="width: 55%" /><col style="width: 33%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">API</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">设置文本属性</td><td style="text-align: left;">setWordSpacing(spacing: float)</td><td style="text-align: left;">设置文本间距</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setBold(enable: bool)</td><td style="text-align: left;">设置文本加粗</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setFamily(a0: str)</td><td style="text-align: left;">设置字体风格</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setPointSize(a0: int)</td><td style="text-align: left;">设置文本大小（字号单位）</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setPixelSize(a0: int)</td><td style="text-align: left;">设置文本大小（像素单位）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setWeight(a0: int)</td><tdstyle="text-align: left;">设置文本粗细，比<code>setBold</code>细粒度设置</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setItalic(b: bool)</td><td style="text-align: left;">设置斜体</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setOverline(a0: bool)</td><td style="text-align: left;">设置字体上划线</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setunderline(a0: bool)</td><td style="text-align: left;">设置字体下划线</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setLetterSpacing(type:'QFont.SpacingType', spacing: float)</td><td style="text-align: left;">设置字间距</td></tr><tr class="odd"><td style="text-align: left;">获取文本属性</td><td style="text-align: left;">family() -&gt; str</td><td style="text-align: left;">获取字体风格</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">pointSize() -&gt; int</td><td style="text-align: left;">获取字体大小（字号单位）</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">pixelSize() -&gt; int</td><td style="text-align: left;">获取文本大小（像素单位）</td></tr></tbody></table><p>比如对<code>QLineEdit</code>设置字体：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">line_edit = QLineEdit()</span><br><span class="line">font = QFont(<span class="string">&quot;Arial&quot;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 设置字间距</span></span><br><span class="line">font.setLetterSpacing(QFont.SpacingType.AbsoluteSpacing, <span class="number">10</span>)</span><br><span class="line">line_edit.setFont(font)</span><br></pre></td></tr></table></figure></p><h4 id="颜色">颜色</h4><p>字体在<code>QtGui.QColor</code>类中，初始化方法有<br />1. <code>QColor(rgb: int)</code><br />2.<code>QColor(r: int, g: int, b: int, alpha: int)</code>：alpha表示透明度，可选参数，取值0-255，0表示完全透明，255表示无透明<br />3. <code>QColor(self, aname: str)</code></p><p>比如初始化一个红色<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">color = QColor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">color = QColor(<span class="number">0xff00ff</span>)</span><br><span class="line">color = QColor(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>基本属性有：</p><table><colgroup><col style="width: 8%" /><col style="width: 56%" /><col style="width: 35%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">API</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">设置颜色</td><td style="text-align: left;">setCmyk(c: int, m: int, y: int, k: int,alpha: int)</td><td style="text-align: left;">设置颜色（cmyk格式）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setHsl(h: int, s: int, l: int, alpha:int)</td><td style="text-align: left;">设置颜色（hsl格式）</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setHsv(h: int, s: int, v: int, alpha:int)</td><td style="text-align: left;">设置颜色（hsv格式）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setAlpha(alpha: int)</td><td style="text-align: left;">设置颜色透明度</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">darker(factor: int)</td><td style="text-align: left;">根据factor参数返回一个更深的颜色</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">lighter(factor: int)</td><td style="text-align: left;">根据factor参数返回一个更浅的颜色</td></tr><tr class="odd"><td style="text-align: left;">获取颜色</td><td style="text-align: left;">getCmyk() -&gt; Tuple[int, int, int, int,int]</td><td style="text-align: left;">获取颜色（cmyk格式）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">getHsl() -&gt; Tuple[int, int, int,int]</td><td style="text-align: left;">获取颜色（hsl格式）</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">getHsv() -&gt; Tuple[int, int, int,int]</td><td style="text-align: left;">获取颜色（hsv格式）</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">getRgb() -&gt; Tuple[int, int, int,int]</td><td style="text-align: left;">获取颜色（rgb格式）</td></tr></tbody></table><p>比如对<code>QTextEdit</code>设置字体：<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">text_edit = QTextEdit()</span><br><span class="line">color = QColor(<span class="string">&quot;red&quot;</span>)</span><br><span class="line">text_edit.setTextColor(color)</span><br></pre></td></tr></table></figure></p><p>！注意:<code>QLineEdit</code>并没有<code>setTextColor</code>方法，所以不能直接设置颜色，这时需要使用更加强大的<code>QSS</code>来配置，类似于网页设计中的<code>CSS</code>。后续章节会详细介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI开发 </tag>
            
            <tag> Qt </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分二：Riemann积分</title>
      <link href="/2021/04/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%862/"/>
      <url>/2021/04/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%862/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1分割">定义1：分割</h4><blockquote><p>在区间<span class="math inline">\([a,b]\)</span>上，记分割<br /><span class="math display">\[    \pi : a = x_0 &lt; x_1 &lt; \cdots &lt; x_n = b\]</span><br />把<span class="math inline">\([a,b]\)</span>分成<spanclass="math inline">\(n\)</span>个小区间<spanclass="math inline">\([x_{i-1},x_i]\)</span>，其长度为<spanclass="math inline">\(\Delta x_i = x_i - x_{i-1}(i=-1,2,\cdots,n)\)</span>。并称<span class="math inline">\(\{x_0, x_1,\cdots,x_n\}\)</span>为<spanclass="math inline">\(\pi\)</span>的分点序列。令<br /><span class="math display">\[    \Vert \pi \Vert = \max \limits_{1 \le i \le n} \{ \Delta x_i \}\]</span><br />称<span class="math inline">\(\Vert \pi \Vert\)</span>为分割<spanclass="math inline">\(\pi\)</span>的宽度。</p></blockquote><span id="more"></span><h4 id="定义2riemann积分">定义2：Riemann积分</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上有定义，如果实数<spanclass="math inline">\(I\)</span>使得对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，只要<spanclass="math inline">\([a,b]\)</span>的分割<spanclass="math inline">\(\pi\)</span>满足<span class="math inline">\(\Vert\pi \Vert &lt; \delta\)</span>，而不管<span class="math inline">\(\xi_i\in [x_{i-1}, x_i] (1 \le i \le n)\)</span>如何选择，都有<br /><span class="math display">\[    |I - \sum_{i=1}^n f(\xi_i) \Delta x_i| &lt; \varepsilon\]</span><br />成立，则称<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上Riemann可积，称<spanclass="math inline">\(I\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的Riemann积分，通常用<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x\]</span><br />来表示。其中<span class="math inline">\(b\)</span>与<spanclass="math inline">\(a\)</span>分别称为积分的上限与下限，<spanclass="math inline">\(f\)</span>称为被积函数。和式<br /><span class="math display">\[    \sum_{i=1}^n f(\xi_i) \Delta x_i\]</span><br />称为<spanclass="math inline">\(f\)</span>的Riemann和（也称积分和），<spanclass="math inline">\(\{\xi_1, \xi_2, \cdots,\xi_n\}\)</span>称为此积分和的值点序列。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>如果函数<span class="math inline">\(f,g\)</span>在<spanclass="math inline">\([a,b]\)</span>可积且非负，那么<br />（1）<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x \ge 0\]</span><br />（2）如果<span class="math inline">\(f \ge g\)</span>在<spanclass="math inline">\([a,b]\)</span>上成立，则<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x \ge \int_a^b g(x) \mathrm{d} x\]</span><br />（3）<span class="math inline">\(f \pm g\)</span>在<spanclass="math inline">\([a,b]\)</span>上也可积，且<br /><span class="math display">\[    \int_a^b (f(x) \pm g(x)) \mathrm{d} x = \int_a^b f(x) \mathrm{d} x\pm \int_a^b g(x) \mathrm{d} x\]</span><br />（4）对任意的常数<span class="math inline">\(c\)</span>，函数<spanclass="math inline">\(cf\)</span>也在<spanclass="math inline">\([a,b]\)</span>上可积，且<br /><span class="math display">\[    \int_a^b cf(x) \mathrm{d} x = c \int_a^b f(x) \mathrm{d} x\]</span></p></blockquote><p>证：由积分的定义容易推出。</p><p>Q.E.D.</p><h4 id="定理2newton-leibiniz">定理2：Newton-Leibiniz</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，且在<spanclass="math inline">\((a,b)\)</span>上有原函数<spanclass="math inline">\(F\)</span>，如果<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，那么必有<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = F(b) - F(a)\]</span><br />为了方便，引入记号<br /><span class="math display">\[    F(x) \Big|_a^b = F(b) - F(a)\]</span><br />从而<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = F(x) \Big|_a^b\]</span></p></blockquote><p>证：用分点<span class="math inline">\(a = x_0 &lt; x_1 &lt; \cdots&lt; x_n=b\)</span>把区间<spanclass="math inline">\([a,b]\)</span>作<spanclass="math inline">\(n\)</span>等分，即<span class="math inline">\(x_i- x_{i-1} = (b-a) / n (i=1,2,\cdots,n)\)</span>，于是<br /><span class="math display">\[    F(b) - F(a) = \sum_{i=1}^n (F(x_i) - F(x_{i-1}))\]</span><br />对<span class="math inline">\(F\)</span>使用微分中值定理，有<br /><span class="math display">\[    F(b) - F(a) = \sum_{i=1}^n F^\prime(\xi_i) \Delta x_i = \sum_{i=1}^nf(\xi_i) \Delta x_i \tag{1}\]</span><br />这里<span class="math inline">\(\xi_i \in (x_{i-1},x_i)(i=1,2,\cdots,n)\)</span>，由于<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可积，所以当<spanclass="math inline">\(n \to \infty\)</span>时，式(1)的右边以<spanclass="math inline">\(\displaystyle \int_a^b f(x) \mathrm{d}x\)</span>为极限，从而在式(1)两边令<span class="math inline">\(n \to\infty\)</span>，可得<br /><span class="math display">\[    F(b) - F(a) = \int_a^b f(x) \mathrm{d} x\]</span></p><p>Q.E.D.</p><h4 id="定理3分部积分公式">定理3：分部积分公式</h4><blockquote><p>设<spanclass="math inline">\(u,v\)</span>是两个可导的函数，且公式中存在的函数积分在<spanclass="math inline">\([a,b]\)</span>上都存在，则<br /><span class="math display">\[    \int_a^b u(x)v^\prime(x) \mathrm{d} x = u(x)v(x)\Big|_a^b - \int_a^bu^\prime(x)v(x) \mathrm{d} x\]</span><br />或写成微分形式<br /><span class="math display">\[    \int_a^b u \mathrm{d} v = u v\Big|_a^b  - \int_a^b v \mathrm{d} u\]</span></p></blockquote><p>证：由求导法则可知<br /><span class="math display">\[    (uv)^\prime = uv^\prime + vu^\prime\]</span><br />对上式两边求不定积分得<br /><span class="math display">\[    \int_a^b (uv)^\prime \mathrm{d} x = \int_a^b uv^\prime \mathrm{d}x +\int_a^b vu^\prime \mathrm{d}x\]</span><br />从而有<ahref="https://gamersover.github.io/2021/04/28/函数积分2/#定理2：Newton-Leibiniz公式">Newton-Leibniz公式</a>可得<br /><span class="math display">\[    \int_a^b u \mathrm{d} v = u v \Big|_a^b - \int_a^b v \mathrm{d} u\]</span></p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上连续，<span class="math inline">\(a,b\in I\)</span>，函数<spanclass="math inline">\(\varphi\)</span>在区间<spanclass="math inline">\([\alpha, \beta]\)</span>上有连续的导函数，<spanclass="math inline">\(\varphi([\alpha, \beta]) \subsetI\)</span>，且<span class="math inline">\(\varphi(\alpha) = a,\varphi(\beta) = b\)</span>，若公式中存在的函数积分在<spanclass="math inline">\([a,b]\)</span>上都存在，那么<br /><span class="math display">\[    \int_a^b f(x) \mathrm{d} x = \int_{\alpha}^{\beta} f \circ\varphi(t) \varphi^\prime(t) \mathrm{d} x\]</span></p></blockquote><p>证：设<span class="math inline">\(F\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的一个原函数，则<br /><span class="math display">\[    (F \circ \varphi(t))^\prime = F^\prime \circ \varphi(t)\varphi^\prime(t) = f \circ \varphi(t) \varphi^\prime(t)\]</span><br />从而<span class="math inline">\(f \circ \varphi(t)\varphi^\prime(t)\)</span>的一个原函数为<spanclass="math inline">\(F\circ \varphi(t)\)</span>，从而由<ahref="https://gamersover.github.io/2021/04/28/函数积分2/#定理2：Newton-Leibiniz公式">Newton-Leibniz公式</a>可知<br /><span class="math display">\[    \int_{\alpha}^{\beta} f \circ \varphi(t) \varphi^\prime(t)\mathrm{d} x = F\circ \varphi(t) \Big|_{\alpha}^{\beta} = F(b) - F(a) =\int_a^b f(x) \mathrm{d} x\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> Riemann积分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数积分一：原函数</title>
      <link href="/2021/04/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%861/"/>
      <url>/2021/04/28/%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%861/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1原函数">定义1：原函数</h4><blockquote><p>已知区间<span class="math inline">\(D\)</span>和函数<spanclass="math inline">\(f: D \to \mathbb{R}, F: D \to\mathbb{R}\)</span>，如果两个函数满足关系<br /><span class="math display">\[    F^\prime(x) = f(x)\]</span><br />则称<span class="math inline">\(F\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上的一个原函数。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>如果<span class="math inline">\(F\)</span>为<spanclass="math inline">\(f\)</span>的一个原函数，那么函数族<spanclass="math inline">\(\{ F + c: c \in \mathbb{R} \}\)</span>是由<spanclass="math inline">\(f\)</span>的全体原函数构成的，且将该集合记为<br /><span class="math display">\[    \int f(x) \mathrm{d} x\]</span><br />该式子又称为函数<spanclass="math inline">\(f\)</span>的不定积分。其中<spanclass="math inline">\(f\)</span>称为被积函数。</p></blockquote><p>证：如果<span class="math inline">\(F\)</span>是<spanclass="math inline">\(f\)</span>的一个原函数，那么对任何常数<spanclass="math inline">\(c\)</span>，有<br /><span class="math display">\[    (F(x) + c)^\prime = F^\prime(x) + c^\prime = f(x)\]</span><br />所以<span class="math inline">\(F(x) + c\)</span>也是<spanclass="math inline">\(f\)</span>的一个原函数。又假设<spanclass="math inline">\(F\)</span>和<spanclass="math inline">\(G\)</span>都是<spanclass="math inline">\(f\)</span>的原函数，则有<br /><span class="math display">\[    (F(x) - G(x))^\prime = F^\prime(x) - G^\prime(x) = f(x) - f(x) = 0\]</span><br />即<span class="math inline">\(F - G\)</span>是个常数，所以<spanclass="math inline">\(G(x) = F(x) + c\)</span>，从而<spanclass="math inline">\(f\)</span>全体原函数<br /><span class="math display">\[    \int f(x) \mathrm{d} x = F(x) + c\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>（1）<span class="math inline">\(\displaystyle \left(\int f(x)\mathrm{d} x\right)^\prime = f(x)\)</span><br />（2）<span class="math inline">\(\displaystyle \int F^\prime(x)\mathrm{d} x = F(x) + c\)</span><br />（3）<span class="math inline">\(\displaystyle \int (f(x) + g(x))\mathrm{d} x = \int f(x) \mathrm{d} x + \int g(x) \mathrm{d}x\)</span><br />（4）如果<span class="math inline">\(c\)</span>是不为<spanclass="math inline">\(0\)</span>的常数，则有<br /><span class="math display">\[    \int cf(x) \mathrm{d} x = c \int f(x) \mathrm{d} x\]</span></p></blockquote><p>证：利用原函数的性质易证。</p><h4 id="定理3分部积分公式">定理3：分部积分公式</h4><blockquote><p>设<span class="math inline">\(u,v\)</span>是两个可导的函数，则<br /><span class="math display">\[    \int u(x)v^\prime(x) \mathrm{d} x = u(x)v(x) - \int u^\prime(x)v(x)\mathrm{d} x\]</span><br />利用微分的记号，也可以表示为<br /><span class="math display">\[    \int u \mathrm{d} v = uv - \int v \mathrm{d} u\]</span></p></blockquote><p>证：由求导法则可知<br /><span class="math display">\[    (uv)^\prime = uv^\prime + vu^\prime\]</span><br />对上式两边求不定积分得<br /><span class="math display">\[    uv + c_1= \int uv^\prime \mathrm{d}x + \int vu^\prime \mathrm{d}x\]</span><br />从而<br /><span class="math display">\[    \int uv^\prime \mathrm{d}x = uv - \int u^\prime v \mathrm{d}x\]</span></p><p>Q.E.D.</p><h4 id="定理4换元法">定理4：换元法</h4><blockquote><p>设可导函数<spanclass="math inline">\(\varphi(x)\)</span>有复合函数<spanclass="math inline">\(f(\varphi(x))\)</span>，则<br /><span class="math display">\[    \int f(\varphi(x)) \varphi^\prime(x) \mathrm{d} x = \int f(u)\mathrm{d} u \tag{1}\]</span><br />其中<span class="math inline">\(u = \varphi(x)\)</span>。</p></blockquote><p>证：式(1)两边分别<span class="math inline">\(x\)</span>求导，得<br /><span class="math display">\[    f(\varphi(x))\varphi^\prime(x) = f(u) \frac{\mathrm{d}u}{\mathrm{d}x}\]</span><br />而右边将<span class="math inline">\(u =\varphi(x)\)</span>代入，正是<br /><span class="math display">\[    f(u) \frac{\mathrm{d} u}{\mathrm{d}x} = f(\varphi(x))\varphi^\prime(x)\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数积分 </tag>
            
            <tag> 原函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数十三：极值</title>
      <link href="/2021/04/25/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B013/"/>
      <url>/2021/04/25/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B013/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，函数<span class="math inline">\(f: D \to\mathbb{R}\)</span>，点<span class="math inline">\(\boldsymbol{x}_0 \inD\)</span>，如果存在一个去心球<spanclass="math inline">\(B_r(\boldsymbol{\check x}_0) \subsetD\)</span>，使得对任意的<span class="math inline">\(\boldsymbol{x} \inB_r(\boldsymbol{\check x}_0)\)</span>，都有<spanclass="math inline">\(f(\boldsymbol{x}) \gef(\boldsymbol{x}_0)(f(\boldsymbol{x}) &gt;f(\boldsymbol{x}_0))\)</span>，那么<spanclass="math inline">\(\boldsymbol{x}_0\)</span>称为<spanclass="math inline">\(f\)</span>的一个(严格)极小值点，<spanclass="math inline">\(f(\boldsymbol{x}_0)\)</span>称为函数<spanclass="math inline">\(f\)</span>的一个(严格)极小值。同样可以定义(严格)极大值点与(严格)极大值。极小值与极大值统称为极值。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，函数<span class="math inline">\(f: D \to\mathbb{R}\)</span>，点<span class="math inline">\(\boldsymbol{x}_0 \inD\)</span>，如果<span class="math inline">\(\displaystyle \frac{\partialf}{\partial x_i}(\boldsymbol{a})(i=1,2,\cdots,n)\)</span>都存在等于<spanclass="math inline">\(0\)</span>，则称点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>为函数<spanclass="math inline">\(f\)</span>的驻点。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(n\)</span>元函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{a} =(a_1,\cdots,a_n)\)</span>处取得极值，且<spanclass="math inline">\(\displaystyle \frac{\partial f}{\partialx_i}(\boldsymbol{a})(i=1,2,\cdots,n)\)</span>都存在，那么<spanclass="math inline">\(\boldsymbol{a}\)</span>必定是<spanclass="math inline">\(f\)</span>的驻点。</p></blockquote><p>证：不妨设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处取得极小值，那么存在球<spanclass="math inline">\(B_{r}(\boldsymbol{a})\)</span>，使得对任意的<spanclass="math inline">\(\boldsymbol{x} \inB_{\boldsymbol{r}}(\boldsymbol{a})\)</span>，有<br /><span class="math display">\[    f(\boldsymbol{x}) \ge f(\boldsymbol{a})\]</span><br />考虑单变量<span class="math inline">\(t\)</span>的函数<br /><span class="math display">\[    \varphi(t) = f(a_1,\cdots,a_{t-1},t,a_{t+1},\cdots,a_n)\]</span><br />让<span class="math inline">\(t\)</span>满足<spanclass="math inline">\(|t - a_i| &lt; r\)</span>，取<spanclass="math inline">\(\boldsymbol{x} =(a_1,\cdots,a_{t-1},t,a_{t+1},\cdots,a_n)\)</span>，可知<spanclass="math inline">\(\Vert \boldsymbol{x} - \boldsymbol{a}\Vert = |t -a_i| &lt; r\)</span>，即<span class="math inline">\(\boldsymbol{x} \inB_{\boldsymbol{r}}(\boldsymbol{a})\)</span>，所以有<spanclass="math inline">\(f(\boldsymbol{x}) \gef(\boldsymbol{a})\)</span>，即<span class="math inline">\(\varphi(t) \ge\varphi(a_i)\)</span>，从而<spanclass="math inline">\(\varphi\)</span>在<spanclass="math inline">\(a_i\)</span>处取得极小值，所以有<spanclass="math inline">\(\varphi^\prime(a_i) = 0\)</span>，即<spanclass="math inline">\(\displaystyle \frac{\partial f}{\partial x_i}(\boldsymbol{a}) = 0\)</span>。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\boldsymbol{x}_0\)</span>是<spanclass="math inline">\(n\)</span>元函数<spanclass="math inline">\(f\)</span>的一个驻点，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的某一邻域内有连续的二阶偏导数，<br />（1）如果Hesse方阵<spanclass="math inline">\(Hf(\boldsymbol{x}_0)\)</span>是严格正(负)定方阵，那么<spanclass="math inline">\(\boldsymbol{x}_0\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极小(大)值点。<br />（2）如果Hesse方阵<spanclass="math inline">\(Hf(\boldsymbol{x}_0)\)</span>是不定方阵，那么<spanclass="math inline">\(\boldsymbol{x}_0\)</span>不是<spanclass="math inline">\(f\)</span>的极值点。</p></blockquote><p>证：（1）设<spanclass="math inline">\(Hf(\boldsymbol{x}_0)\)</span>是严格正定方阵，由于<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的某一邻域内有连续的二阶偏导数，从而由<ahref="https://gamersover.github.io/2021/04/21/函数导数12/#定理5：Taylor公式">函数导数十二的定理5</a>可知<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) = f(\boldsymbol{x}_0) +Jf(\boldsymbol{x}_0)\boldsymbol{h} + \frac{1}{2}\boldsymbol{h}^THf(\boldsymbol{x}_0) \boldsymbol{h} + o(\Vert \boldsymbol{h} \Vert^2)\quad (\boldsymbol{h} \to \boldsymbol{0})\]</span><br />又因为<span class="math inline">\(\boldsymbol{x}_0\)</span>是<spanclass="math inline">\(f\)</span>的驻点，从而上式可写为<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) =\frac{1}{2} \boldsymbol{h}^T Hf(\boldsymbol{x}_0) \boldsymbol{h} +o(\Vert \boldsymbol{h} \Vert^2) \tag {1}\]</span><br />设<span class="math inline">\(\Vert \boldsymbol{y} \Vert =1\)</span>，它的全体是单位球的球面<span class="math inline">\(\partialB_1(\boldsymbol{0})\)</span>，因为<spanclass="math inline">\(Hf(\boldsymbol{x}_0)\)</span>是严格正定的，所以<br /><span class="math display">\[    (y_1,\cdots,y_n) Hf(\boldsymbol{x}_0) \begin{bmatrix} y_1 \\ \vdots\\ y_m \end{bmatrix} = \sum_{i,j=1}^n \frac{\partial^2 f}{\partial x_i\partial x_j}(\boldsymbol{x}_0) y_iy_j &gt; 0\]</span><br />这时单位球面上的连续函数，而单位球面是一个有界闭集，从而它在单位球面上某点取得最小值，设此最小值为<spanclass="math inline">\(m&gt;0\)</span>，从而有<br /><span class="math display">\[    \boldsymbol{y}^t Hf(\boldsymbol{x}_0) \boldsymbol{y} \ge m &gt; 0\]</span><br />而<br /><span class="math display">\[    \frac{1}{2} \boldsymbol{h}^T Hf(\boldsymbol{x}_0) \boldsymbol{h} =\frac{1}{2} \Vert \boldsymbol{h} \Vert^2 \left(\frac{\boldsymbol{h}^T}{\Vert \boldsymbol{h}\Vert} Hf(\boldsymbol{x}_0)\frac{\boldsymbol{h}}{\Vert \boldsymbol{h} \Vert}\right) \ge \frac{m}{2}\Vert \boldsymbol{h} \Vert^2\]</span><br />将其代入(1)式中，得<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) = \Vert\boldsymbol{h} \Vert^2 \left(\frac{m}{2} + o(1) \right) &gt; 0\]</span><br />即当<span class="math inline">\(\Vert \boldsymbol{h}\Vert\)</span>充分小时，有<span class="math inline">\(f(\boldsymbol{x}_0+ \boldsymbol{h}) &gt; f(\boldsymbol{x}_0)\)</span>。<br />（2）因为<spanclass="math inline">\(Hf(\boldsymbol{x}_0)\)</span>是不定方阵，故存在<spanclass="math inline">\(\boldsymbol{p},\boldsymbol{q} \in\mathbb{R}^n\)</span>，使得<br /><span class="math display">\[    \boldsymbol{p}^T Hf(\boldsymbol{x}_0) \boldsymbol{p} &lt; 0 &lt;\boldsymbol{q}^T Hf(\boldsymbol{x}_0) \boldsymbol{q}\]</span><br />在式(1)中分别取<spanclass="math inline">\(\boldsymbol{h}\)</span>为<spanclass="math inline">\(\varepsilon \boldsymbol{p}\)</span>和<spanclass="math inline">\(\varepsilon \boldsymbol{q}\)</span>，得<br /><span class="math display">\[    \begin{aligned}        f(\boldsymbol{x}_0 + \varepsilon \boldsymbol{p}) -f(\boldsymbol{x}_0) &amp; = \frac{1}{2} (\boldsymbol{p}^THf(\boldsymbol{x}_0) \boldsymbol{p}) \varepsilon^2 + o(\varepsilon^2) \\        &amp;= \left( \frac{1}{2} \boldsymbol{p}^T Hf(\boldsymbol{x}_0)\boldsymbol{p} + o(1) \right) \varepsilon^2 \\        f(\boldsymbol{x}_0 + \varepsilon \boldsymbol{q}) -f(\boldsymbol{x}_0) &amp;= \left( \frac{1}{2} \boldsymbol{q}^THf(\boldsymbol{x}_0) \boldsymbol{q} + o(1) \right) \varepsilon^2    \end{aligned}\]</span><br />从而只要<spanclass="math inline">\(\varepsilon\)</span>取得充分小，就有<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \varepsilon \boldsymbol{p}) &lt;f(\boldsymbol{x}_0) &lt; f(\boldsymbol{x}_0 + \varepsilon\boldsymbol{q})\]</span><br />也就表明<span class="math inline">\(\boldsymbol{x}_0\)</span>不是<spanclass="math inline">\(f\)</span>的极值点。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\((x_0,y_0)\)</span>是二元函数<spanclass="math inline">\(f\)</span>的驻点，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>的某个邻域内有连续的二阶偏导数，记<br /><span class="math display">\[    a = \frac{\partial^2 f}{\partial x^2}(x_0, y_0) \quadb=\frac{\partial^2 f}{\partial x \partial y}(x_0, y_0) \quadc=\frac{\partial^2 f}{\partial y^2}(x_0, y_0)\]</span><br />那么：<br />（1）当<span class="math inline">\(ac-b^2 &gt; 0\)</span>且<spanclass="math inline">\(a &gt; 0\)</span>时，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>处有严格极小值；<br />（2）当<span class="math inline">\(ac-b^2 &gt; 0\)</span>且<spanclass="math inline">\(a &lt; 0\)</span>时，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>处有严格极大值；<br />（3）当<span class="math inline">\(ac-b^2 &lt; 0\)</span>时，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>处没有极值。</p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/04/25/函数导数13/#定理2">定理2</a>易证。</p><p>Q.E.D.</p><h4 id="定义3条件极值">定义3：条件极值</h4><blockquote><p>设<span class="math inline">\(D\)</span>是<spanclass="math inline">\(\mathbb{R}^{n+m}\)</span>中的开集，<br /><span class="math display">\[    f(x_1,\cdots,x_n,y_1,\cdots,y_m) \tag{2}\]</span><br />是定义在<spanclass="math inline">\(D\)</span>上的一个函数，先设变量<spanclass="math inline">\(x_1,\cdots,x_n,y_1,\cdots,y_m\)</span>满足以下<spanclass="math inline">\(m\)</span>个条件约束：<br /><span class="math display">\[    \left\{ \begin{aligned}        &amp; \Phi_1(x_1,\cdots,x_n,y_1,\cdots,y_m) = 0 \\        &amp; \cdots \\        &amp; \Phi_m(x_1, \cdots,x_n,y_1,\cdots,y_m) = 0    \end{aligned}    \right. \tag{3}\]</span><br />那么函数(2)在条件(3)下的极值称为条件极值。</p></blockquote><h4 id="定理4">定理4</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^{n+m}\)</span>，函数<span class="math inline">\(f: D \to\mathbb{R}\)</span>，映射<span class="math inline">\(\boldsymbol{\Phi}:D \to \mathbb{R}^m\)</span>，函数<spanclass="math inline">\(f\)</span>映射<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>满足以下条件：<br />（a）<span class="math inline">\(f,\boldsymbol{\Phi} \inC^1(D)\)</span><br />（b）存在<span class="math inline">\(\boldsymbol{z}_0 =(\boldsymbol{x}_0, \boldsymbol{y}_0) \in D\)</span>，满足<spanclass="math inline">\(\boldsymbol{\Phi}(\boldsymbol{z}_0) =0\)</span>，其中<span class="math inline">\(\boldsymbol{x}_0 =(a_1,\cdots,a_n)\)</span>，<spanclass="math inline">\(\boldsymbol{y}_n=(b_1,\cdots,b_m)\)</span>；<br />（c）<span class="math inline">\(\detJ_{\boldsymbol{y}}\boldsymbol{\Phi}(\boldsymbol{z}_0) \ne0\)</span><br />如果<span class="math inline">\(f\)</span>在等式(3)的约束下，在<spanclass="math inline">\(\boldsymbol{z}_0\)</span>处取得极值，那么存在<spanclass="math inline">\(\boldsymbol{\lambda} \in\mathbb{R}^m\)</span>，使得<br /><span class="math display">\[    Jf(\boldsymbol{z}_0) + \boldsymbol{\lambda}J\boldsymbol{\Phi}(\boldsymbol{z}_0) = \boldsymbol{0}\]</span></p></blockquote><p>证：由于<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>满足（a）,（b）,（c）三个条件，根据隐映射定理可知存在<spanclass="math inline">\(\boldsymbol{z}_0=(\boldsymbol{x}_0,\boldsymbol{y}_0)\)</span>的邻域<span class="math inline">\(U = G \timesH\)</span>，其中<span class="math inline">\(G\)</span>和<spanclass="math inline">\(H\)</span>分别是<spanclass="math inline">\(\boldsymbol{x_0}\)</span>和<spanclass="math inline">\(\boldsymbol{y}_0\)</span>的邻域，使得方程<br /><span class="math display">\[    \boldsymbol{\Phi}(\boldsymbol{x}, \boldsymbol{y}) = \boldsymbol{0}\]</span><br />对任意的<span class="math inline">\(\boldsymbol{x} \inG\)</span>，在<span class="math inline">\(H\)</span>中有唯一的解<spanclass="math inline">\(\boldsymbol{\varphi}(\boldsymbol{x})\)</span>，并且满足<spanclass="math inline">\(\boldsymbol{y}_0 =\boldsymbol{\varphi}(\boldsymbol{x}_0)\)</span>且<br /><span class="math display">\[    J\boldsymbol{\varphi}(\boldsymbol{x}_0) =-(J_y\boldsymbol{\Phi}(\boldsymbol{z}_0))^{-1}J_x\boldsymbol{\Phi}(\boldsymbol{z}_0)\tag{4}\]</span><br />由于<span class="math inline">\(\boldsymbol{z}_0\)</span>是函数<spanclass="math inline">\(f\)</span>在条件式(2)下的极值点，从而<spanclass="math inline">\(\boldsymbol{x}_0\)</span>便是函数<spanclass="math inline">\(f(\boldsymbol{x},\boldsymbol{\varphi}(\boldsymbol{x}))\)</span>在<spanclass="math inline">\(G\)</span>中的一个极值点，所以<spanclass="math inline">\(\boldsymbol{x}_0\)</span>必是<spanclass="math inline">\(f(\boldsymbol{x},\boldsymbol{\varphi}(\boldsymbol{x}))\)</span>的一个驻点，从而有<br /><span class="math display">\[    J_xf(\boldsymbol{z}_0) +J_yf(\boldsymbol{z}_0)J\boldsymbol{\varphi}(\boldsymbol{x}_0) =\boldsymbol{0}\]</span><br />将(4)式代入上式可得<br /><span class="math display">\[    J_xf(\boldsymbol{z}_0) -J_yf(\boldsymbol{z}_0)(J_y\boldsymbol{\Phi}(\boldsymbol{z}_0))^{-1}J_x\boldsymbol{\Phi}(\boldsymbol{z}_0)= \boldsymbol{0} \tag{5}\]</span><br />记<br /><span class="math display">\[    \boldsymbol{\lambda} =-J_yf(\boldsymbol{z}_0)(J_y\boldsymbol{\Phi}(\boldsymbol{z}_0))^{-1}\tag{6}\]</span><br />它是一个<spanclass="math inline">\(m\)</span>维的向量，从而式(5)变成<br /><span class="math display">\[    J_xf(\boldsymbol{z}_0) +\boldsymbol{\lambda}J_x\boldsymbol{\Phi}(\boldsymbol{z}_0) =\boldsymbol{0} \tag{7}\]</span><br />将式(6)改写为<br /><span class="math display">\[    J_yf(\boldsymbol{z}_0) +\boldsymbol{\lambda}J_y\boldsymbol{\Phi}(\boldsymbol{z}_0) =\boldsymbol{0} \tag{8}\]</span><br />结合式(7)和式(8)可得<br /><span class="math display">\[    Jf(\boldsymbol{z}_0) +\boldsymbol{\lambda}J\boldsymbol{\Phi}(\boldsymbol{z}_0) =\boldsymbol{0}\]</span></p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设<spanclass="math inline">\(\boldsymbol{z}_0\)</span>是辅助函数<br /><span class="math display">\[    F(\boldsymbol{z}) = f(\boldsymbol{z}) + \sum_{i=1}^m \lambda_i\Phi_i(\boldsymbol{z})\]</span><br />的一个驻点，其中<span class="math inline">\(\boldsymbol{z} =(z_1,\cdots,z_{n+m}) =(x_1,\cdots,x_n,y_1,\cdots,y_m)\)</span>，记<br /><span class="math display">\[    HF(\boldsymbol{z}_0) = \left( \frac{\partial^2 f}{\partial z_j\partial z_k}(\boldsymbol{z}_0) \right)_{i\le j,k \le m+n}\]</span><br />（1）如果<spanclass="math inline">\(HF(\boldsymbol{z}_0)\)</span>严格正定，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{z}_0\)</span>处取得严格的极小值；<br />（2）如果<spanclass="math inline">\(HF(\boldsymbol{z}_0)\)</span>严格负定，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{z}_0\)</span>处取得严格的极大值。</p></blockquote><p>证：记<spanclass="math inline">\(E\)</span>是满足条件式(2)的点的全体，即<br /><span class="math display">\[    E = \left\{ \boldsymbol{z} \in \mathbb{R}^{m+n}:\boldsymbol{\Phi}(\boldsymbol{z}) = \boldsymbol{0} \right\}\]</span><br />已知<span class="math inline">\(\boldsymbol{z}_0 \inE\)</span>，再在<spanclass="math inline">\(\boldsymbol{z}_0\)</span>的附近取点<spanclass="math inline">\(\boldsymbol{z}_0 + \boldsymbol{h} \inE\)</span>，由于<br /><span class="math display">\[    \boldsymbol{\Phi}(\boldsymbol{z}_0) = 0, \quad\boldsymbol{\Phi}(\boldsymbol{z}_0 + \boldsymbol{h}) = 0\]</span><br />所以<br /><span class="math display">\[    F(\boldsymbol{z}_0) = f(\boldsymbol{z}_0), \quad F(\boldsymbol{z}_0+ \boldsymbol{h}) = f(\boldsymbol{z}_0 + \boldsymbol{h})\]</span><br />于是对<span class="math inline">\(F\)</span>利用Taylor公式得<br /><span class="math display">\[    \begin{aligned}    f(\boldsymbol{z}_0 + \boldsymbol{h}) - f(\boldsymbol{z}_0) &amp;=F(\boldsymbol{z}_0 + \boldsymbol{h}) - F(\boldsymbol{z}_0)  \\    &amp;= \sum_{i=j}^{m+n} \frac{\partial F}{\partialz_j}(\boldsymbol{z}_0)h_i + \frac{1}{2}\sum_{j,k=1}^{m+n}\frac{\partial^2 f}{\partial z_j \partial z_k}(\boldsymbol{z}_0)h_jh_k +o(\Vert \boldsymbol{h} \Vert^2) \\    &amp;= \frac{1}{2} \boldsymbol{h}^T HF(\boldsymbol{z}_0)\boldsymbol{h} + o(\Vert \boldsymbol{h} \Vert^2)    \end{aligned}\]</span><br />接下来的证明方式与<ahref="https://gamersover.github.io/2021/04/25/函数导数13/#定理2">定理2</a>完全一样，不再赘述。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 极值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数十二：高阶偏导数和Taylor公式</title>
      <link href="/2021/04/21/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B012/"/>
      <url>/2021/04/21/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B012/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在开集<spanclass="math inline">\(D\)</span>上的每一点处存在偏导数：<br /><span class="math display">\[    D_if(\boldsymbol{x}) = \frac{\partial f}{\partialx_i}(\boldsymbol{x}) \quad (i=1,2,\cdots,n)\]</span><br />称它们为<spanclass="math inline">\(f\)</span>的一阶偏导函数，如果对这些偏导函数又可以取偏导数，得出的就是<spanclass="math inline">\(f\)</span>的二阶偏导函数，依次可以定义三阶偏导数以及更高阶的偏导数。对于二阶偏导数，将一阶偏导函数<spanclass="math inline">\(\displaystyle \frac{\partial f}{\partialx_j}\)</span>再对<spanclass="math inline">\(x_i\)</span>求偏导数，即<spanclass="math inline">\(\displaystyle \frac{\partial f}{\partialx_i}\left(\frac{\partial f}{\partial x_j}\right)\)</span>记作<spanclass="math inline">\(\displaystyle \frac{\partial^2 f}{\partial x_i\partial x_j}\)</span>，这里<spanclass="math inline">\(i,j\)</span>独立地从<spanclass="math inline">\(1\)</span>变到<spanclass="math inline">\(n\)</span>，如果<spanclass="math inline">\(i=j\)</span>，那么把<spanclass="math inline">\(\displaystyle \frac{\partial^2 f}{\partial x_i\partial x_i}\)</span>记作<span class="math inline">\(\displaystyle\frac{\partial^2 f}{\partial x_i^2}(i=1,2,\cdots,n)\)</span>；如果<spanclass="math inline">\(i\nej\)</span>，这类二阶偏导数称为混合偏导数。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^2\)</span>，<span class="math inline">\(f: D \to\mathbb{R}\)</span>，如果<span class="math inline">\(\displaystyle\frac{\partial f}{\partial x},\frac{\partial f}{\partialy},\frac{\partial^2 f}{\partial y \partial x}\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>的某个邻域上存在，且<spanclass="math inline">\(\displaystyle \frac{\partial^2 f}{\partialy\partial x}\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>处连续，那么<spanclass="math inline">\(\displaystyle \frac{\partial^2 f}{\partial x\partial y}\)</span>在<spanclass="math inline">\((x_0,y_0)\)</span>处存在，而且<br /><span class="math display">\[    \frac{\partial^2 f}{\partial x \partial y} = \frac{\partial^2f}{\partial y \partial x}\]</span></p></blockquote><p>证：记<br /><span class="math display">\[    \varphi(h, k) = f(x_0 + h, y_0 + k) - f(x_0+h, y_0) - f(x_0, y_0+k)+ f(x_0, y_0)\]</span><br />令<br /><span class="math display">\[    g(x) = f(x, y_0+k) - f(x, y_0)\]</span><br />从而由微分中值定理可知<br /><span class="math display">\[    \begin{aligned}    \varphi(h, k) &amp; = g(x_0 + h) - g(x_0) \\    &amp; = g^\prime(x_0 + \theta_1 h)h \\    &amp; = \left(\frac{\partial f}{\partial x}(x_0 + \theta_1 h, y_0 +k) - \frac{\partial f}{\partial x}(x_0 + \theta_1 h, y_0) \right)h \\    &amp; = \frac{\partial^2 f}{\partial y \partial x}(x_0 + \theta_1h,y_0 + \theta_2k)hk    \end{aligned}\]</span><br />由于<span class="math inline">\(\displaystyle \frac{\partial^2f}{\partial y \partial x}\)</span>在<span class="math inline">\((x_0,y_0)\)</span>处连续，从而有<br /><span class="math display">\[    \lim \limits_{h\to 0, k \to 0} \frac{\varphi(h ,k)}{hk} =\frac{\partial^2 f}{\partial y \partial x}(x_0, y_0)\]</span><br />而又有<br /><span class="math display">\[    \lim \limits_{k \to 0} \frac{\varphi(h ,k)}{hk} = \lim \limits_{k\to 0} \frac{1}{h} \left( \frac{f(x_0+h, y_0+k) - f(x_0+h, y_0)}{k} -\frac{f(x_0, y_0+k) - f(x_0, y_0)}{k}\right) = \frac{1}{h}\left(\frac{\partial f}{\partial y}(x_0 +h, y_0) - \frac{\partial f}{\partialy}(x_0, y_0)\right)\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{h \to 0, k \to 0} \frac{\varphi(h ,k)}{hk} = \lim\limits_{h \to 0} \frac{1}{h}\left( \frac{\partial f}{\partial y}(x_0+h, y_0) - \frac{\partial f}{\partial y}(x_0, y_0)\right) =\frac{\partial^2 f}{\partial x \partial y}(x_0, y_0)\]</span><br />所以<span class="math inline">\(\displaystyle \frac{\partial^2f}{\partial x \partial y}(x_0, y_0)\)</span>存在，而且<br /><span class="math display">\[    \frac{\partial^2 f}{\partial x \partial y}(x_0, y_0) =\frac{\partial^2 f}{\partial y \partial x}(x_0, y_0)\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设定义在凸区域<span class="math inline">\(D \subset\mathbb{R}^n\)</span>上的函数<spanclass="math inline">\(f\)</span>可微，则对任何两点<spanclass="math inline">\(\boldsymbol{a}, \boldsymbol{b} \inD\)</span>，在由<spanclass="math inline">\(\boldsymbol{a},\boldsymbol{b}\)</span>确定的线段上存在一点<spanclass="math inline">\(\boldsymbol{\xi}\)</span>，使得<br /><span class="math display">\[    f(\boldsymbol{b}) - f(\boldsymbol{a}) =Jf(\boldsymbol{\xi})(\boldsymbol{b} - \boldsymbol{a})\]</span></p></blockquote><p>证：由<span class="math inline">\(\boldsymbol{a}\)</span>与<spanclass="math inline">\(\boldsymbol{b}\)</span>确定的线段上的点可表示为<spanclass="math inline">\(\boldsymbol{a} + t(\boldsymbol{b} -\boldsymbol{a})\)</span>，这里<span class="math inline">\(t \in [0,1]\)</span>，令<br /><span class="math display">\[      \varphi(t) = f(\boldsymbol{a} + t(\boldsymbol{b} - \boldsymbol{a}))\]</span><br />那么<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\([0,1]\)</span>上的可微函数，由单变量的微分中值定理可知，存在<spanclass="math inline">\(\theta \in (0,1)\)</span>，使得<br /><span class="math display">\[    \varphi(1) - \varphi(0) = \varphi^\prime(\theta)\]</span><br />即<br /><span class="math display">\[    f(\boldsymbol{b}) - f(\boldsymbol{a}) =\boldsymbol{J}f(\boldsymbol{a} + \theta (\boldsymbol{b} -\boldsymbol{a}))(\boldsymbol{b} - \boldsymbol{a})\]</span><br />再令<span class="math inline">\(\boldsymbol{\xi} = \boldsymbol{a} +\theta(\boldsymbol{b} - \boldsymbol{a})\)</span>即证得结论。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(D\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的区域，如果对任意的<spanclass="math inline">\(\boldsymbol{x} \in D\)</span>，有<br /><span class="math display">\[    \frac{\partial f}{\partial x_1}(\boldsymbol{x}) = \cdots =\frac{\partial f}{\partial x_n}(\boldsymbol{x}) = 0\]</span><br />那么<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上为一个常数。</p></blockquote><p>证：如果<span class="math inline">\(D\)</span>是凸区域，则由<ahref="https://gamersover.github.io/2021/04/21/函数导数12/#定理1">定理1</a>立即得出结论。如果<spanclass="math inline">\(D\)</span>不是凸区域，任取<spanclass="math inline">\(\boldsymbol{x}_0 \in D\)</span>，令<br /><span class="math display">\[    \begin{aligned}    A = \{ \boldsymbol{x} \in D: f(\boldsymbol{x}) =f(\boldsymbol{x_0})\} \\    B = \{ \boldsymbol{x} \in D: f(\boldsymbol{x}) \nef(\boldsymbol{x_0}) \}    \end{aligned}\]</span><br />显然<span class="math inline">\(A\)</span>非空，而<spanclass="math inline">\(D=A \cup B\)</span>，由于<spanclass="math inline">\(D\)</span>是连通开集，若能证明<spanclass="math inline">\(A,B\)</span>是开集，则由<ahref="https://gamersover.github.io/2020/11/10/点列极限6/#定理3">点列极限六的定理3</a>可知，<spanclass="math inline">\(B =\varnothing\)</span>，从而证得结论。为了证明<spanclass="math inline">\(A\)</span>是开集，任取<spanclass="math inline">\(\boldsymbol{a} \in A \subset D\)</span>，存在<spanclass="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{a}) \inD\)</span>，由于<spanclass="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{a})\)</span>是凸区域，从而<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{a})\)</span>上是常数，且对任意的<spanclass="math inline">\(\boldsymbol{x} \inB_{\boldsymbol{r}}(\boldsymbol{a})\)</span>，有<br /><span class="math display">\[    f(\boldsymbol{x}) = f(\boldsymbol{a}) = f(\boldsymbol{x}_0)\]</span><br />从而<span class="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{a})\subset A\)</span>，也就说明<spanclass="math inline">\(A\)</span>是开集。同样的方法也可以证明<spanclass="math inline">\(B\)</span>是开集。再由上面分析可知命题成立。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设<span class="math inline">\(k,n\)</span>是两个正整数，那么<br /><span class="math display">\[    (x_1 + \cdots + x_n)^k = \sum_{\alpha_1 + \cdots + \alpha_n = k}\frac{k!}{\alpha_1!\cdots\alpha_n!}x_1^{\alpha_1} \cdots x_n^{\alpha_n}\]</span><br />这里<spanclass="math inline">\(\alpha_1,\cdots,\alpha_n\)</span>是非负整数。如果记<spanclass="math inline">\(\boldsymbol{\alpha} = (\alpha_1, \cdots,\alpha_n)\)</span>，<spanclass="math inline">\(\boldsymbol{x}=(x_1,\cdots,x_n)\)</span>，且<br /><span class="math display">\[\begin{aligned}|\boldsymbol{\alpha}| &amp;= \alpha_1 + \cdots + \alpha_n \\\boldsymbol{\alpha}! &amp;= \alpha_1!\cdots\alpha_n! \\\boldsymbol{x}^{\boldsymbol{\alpha}} &amp;= x_1^{\alpha_1} \cdotsx_n^{\alpha_n}\end{aligned}\]</span><br />则上式可简写为<br /><span class="math display">\[    (x_1 + \cdots + x_n)^k =\sum_{|\boldsymbol{\alpha}|=k}\frac{k!}{\boldsymbol{\alpha}!}\boldsymbol{x}^{\boldsymbol{\alpha}}\]</span></p></blockquote><p>证：对加项的个数<span class="math inline">\(n\)</span>作归纳。当<spanclass="math inline">\(n=2\)</span>时，该定理就是二项式定理，固然成立。先设<spanclass="math inline">\(n-1\)</span>时命题成立，那么当加项的个数为<spanclass="math inline">\(n\)</span>时，有<br /><span class="math display">\[    \begin{aligned}    (x_1 + \cdots + x_n)^k &amp;= ((x_1 + \cdots + x_{n-1}) + x_n)^k \\    &amp;= \sum_{\alpha_n=0}^k\frac{k!}{\alpha_n!(k-\alpha_n)!}(x_1+\cdots+x_{n-1})^{k-\alpha_n}x_n^{\alpha_n}\\    &amp;= \sum_{\alpha_n=0}^k \frac{k!}{\alpha_n!(k-\alpha_n)!}\sum_{\alpha_1 +\alpha_{n-1}=k-\alpha_n}\frac{(k-\alpha_n)!}{\alpha_1!\cdots\alpha_{n-1}!}x_1^{\alpha_1} \cdots x_{n-1}^{\alpha_{n-1}} x_n^{\alpha_n} \\    &amp; = \sum_{\alpha_1 + \cdots + \alpha_n = k}\frac{k!}{\alpha_1!\cdots\alpha_n!}x_1^{\alpha_1} \cdots x_n^{\alpha_n}    \end{aligned}\]</span></p><p>Q.E.D.</p><h4 id="定理5taylor公式">定理5：Taylor公式</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^n\)</span>是一个凸区域，<span class="math inline">\(f \inC^{m+1}(D)\)</span>，<spanclass="math inline">\(\boldsymbol{a}=(a_1,\cdots,a_n)\)</span>，<spanclass="math inline">\(\boldsymbol{a}+\boldsymbol{h} =(a_1+h_1,\cdots,a_n+h_n)\)</span>是<spanclass="math inline">\(D\)</span>中的两个点，则必存在<spanclass="math inline">\(\theta \in (0, 1)\)</span>，使得<br /><span class="math display">\[    f(\boldsymbol{a} + \boldsymbol{h}) = \sum_{k=0}^m\sum_{|\boldsymbol{a}|=k}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} + \boldsymbol{R}_m\]</span><br />其中<br /><span class="math display">\[    D^{\boldsymbol{\alpha}}f(\boldsymbol{a}) =\frac{\partial^{\alpha_1+\cdots+\alpha_n}f}{\partial x_1^{\alpha_1}\cdots \partial x_n^{\alpha_n}}(\boldsymbol{a})\]</span><br />且<br /><span class="math display">\[    \boldsymbol{R}_m = \sum_{|\boldsymbol{\alpha}|=m+1}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a} + \theta\boldsymbol{h})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}}\]</span><br />称为Lagrange余项。</p></blockquote><p>证：固定<spanclass="math inline">\(\boldsymbol{a},\boldsymbol{h}\)</span>，设<spanclass="math inline">\(t \in [0,1]\)</span>，考虑<spanclass="math inline">\([0,1]\)</span>上的函数<spanclass="math inline">\(\varphi(t) = f(\boldsymbol{a} + t\boldsymbol{h})\)</span>，显然<spanclass="math inline">\(\varphi\)</span>在<spanclass="math inline">\([0,1]\)</span>上有<spanclass="math inline">\(m+1\)</span>阶的连续导数，对<spanclass="math inline">\(\varphi\)</span>用单变量函数的Taylor公式，得<br /><span class="math display">\[    \varphi(1) = \varphi(0) + \varphi^\prime(0) +\frac{1}{2!}\varphi^{\prime\prime}(0) + \cdots +\frac{1}{m!}\varphi^{(m)}(0) + \frac{1}{(m+1)!}\varphi^{(m+1)}(\theta)\tag{1}\]</span><br />其中<span class="math inline">\(\theta \in (0, 1)\)</span>。显然<spanclass="math inline">\(\varphi(1) = f(\boldsymbol{a} +\boldsymbol{h})\)</span>，<span class="math inline">\(\varphi(0) =f(\boldsymbol{a})\)</span>，根据复合函数的求导公式得<br /><span class="math display">\[    \varphi^\prime(t) = \frac{\partial f}{\partial x_1}(\boldsymbol{a} +t \boldsymbol{h})h_1 + \cdots + \frac{\partial f}{\partialx_n}(\boldsymbol{a} + t \boldsymbol{h})h_n =\left(h_1\frac{\partial}{\partial x_1} + \cdots +h_n\frac{\partial}{\partial x_n}\right)f(\boldsymbol{a} + t\boldsymbol{h})\]</span><br />从而可得<br /><span class="math display">\[    \begin{aligned}        \varphi^{\prime\prime}(t) &amp;=\left(h_1\frac{\partial}{\partial x_1} + \cdots +h_n\frac{\partial}{\partial x_n}\right)^2f(\boldsymbol{a} +t\boldsymbol{h}) \\        \cdots, \\        \varphi^{(m)}(t) &amp;= \left(h_1\frac{\partial}{\partial x_1} +\cdots + h_n\frac{\partial}{\partial x_n}\right)^mf(\boldsymbol{a} +t\boldsymbol{h})    \end{aligned}\]</span><br />根据<ahref="https://gamersover.github.io/2021/04/21/函数导数12/#定理4">定理4</a>可知，<br /><span class="math display">\[    \varphi^{(k)}(t) =\sum_{|\boldsymbol{\alpha}|=k}\frac{k!}{\boldsymbol{\alpha}!}\frac{\partial^{\alpha_1}}{\partialx_1^{\alpha_1}}\cdots \frac{\partial ^{\alpha_n}}{\partialx_n^{\alpha_n}}f(\boldsymbol{a} +t\boldsymbol{h})\boldsymbol{h}^{\boldsymbol{\alpha}} =\sum_{|\boldsymbol{\alpha}|=k}\frac{k!}{\boldsymbol{\alpha}!}D^{\boldsymbol{\alpha}}f(\boldsymbol{a} +t\boldsymbol{h}) \boldsymbol{h}^{\boldsymbol{\alpha}}\]</span><br />所以<br /><span class="math display">\[    \varphi^{(k)}(0) = \sum_{|\boldsymbol{\alpha}|=k}\frac{k!}{\boldsymbol{\alpha}!}D^{\boldsymbol{\alpha}}f(\boldsymbol{a})\boldsymbol{h}^{\boldsymbol{\alpha}}\]</span><br />将其代入(1)式，即得证明的结论。</p><p>Q.E.D.</p><h5 id="特别地">特别地</h5><p>Taylor公式的前三项写出来就是<br /><span class="math display">\[    f(\boldsymbol{a} + \boldsymbol{h}) = f(\boldsymbol{a}) +\frac{\partial f}{\partial x_1}(\boldsymbol{a})h_1 + \cdots +\frac{\partial f}{\partial x_n}(\boldsymbol{a})h_n + \frac{1}{2}\sum_{i,j=1}^n\frac{\partial^2 f}{\partial x_i \partialx_j}(\boldsymbol{a})h_ih_j + \cdots\]</span><br />如果记<br /><span class="math display">\[    Hf(\boldsymbol{a}) = \begin{bmatrix}            \frac{\partial^2 f}{\partial x_1^2}(\boldsymbol{a}) &amp;\cdots &amp; \frac{\partial^2 f}{\partial x_1 \partialx_n}(\boldsymbol{a}) \\            \vdots &amp; &amp; \vdots \\            \frac{\partial^2 f}{\partial x_n \partialx_1}(\boldsymbol{a}) &amp; \cdots &amp; \frac{\partial^2 f}{\partialx_n^2}(\boldsymbol{a})    \end{bmatrix}\]</span><br />那么上式可写成<br /><span class="math display">\[    f(\boldsymbol{a} + \boldsymbol{h}) = f(\boldsymbol{a}) +Jf(\boldsymbol{a})\boldsymbol{h} + \frac{1}{2}\boldsymbol{h}^THf(\boldsymbol{a}) \boldsymbol{h} + \cdots\]</span><br />这里<span class="math inline">\(Hf\)</span>称为<spanclass="math inline">\(f\)</span>的Hesse方阵，它是一个<spanclass="math inline">\(n\)</span>阶对称方阵。</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^n\)</span>是一个凸区域，<span class="math inline">\(f \inC^m(D)\)</span>，<spanclass="math inline">\(\boldsymbol{a}\)</span>和<spanclass="math inline">\(\boldsymbol{a}+\boldsymbol{h}\)</span>是<spanclass="math inline">\(D\)</span>中的两个点，那么<br /><span class="math display">\[    f(\boldsymbol{a} + \boldsymbol{h}) = \sum_{k=0}^m\sum_{|\boldsymbol{\alpha}|=k}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} + o(\Vert \boldsymbol{h} \Vert^m)\quad (\boldsymbol{h} \to \boldsymbol{0})\]</span></p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/04/21/函数导数12/#定理5：Taylor公式">定理5</a>可知<br /><span class="math display">\[    f(\boldsymbol{a} + \boldsymbol{h}) = \sum_{k=0}^{m-1}\sum_{|\boldsymbol{\alpha}|=k}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} +\sum_{|\boldsymbol{\alpha}|=m}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a}+ \theta \boldsymbol{h})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} \tag{2}\]</span><br />其中<span class="math inline">\(\theta \in (0, 1)\)</span>，因为<spanclass="math inline">\(f\)</span>的<spanclass="math inline">\(m\)</span>阶偏导数连续，所以<br /><span class="math display">\[    \lim \limits_{\boldsymbol{h} \to \boldsymbol{0}}D^{\boldsymbol{\alpha}}f(\boldsymbol{a} + \theta \boldsymbol{h}) =D^{\boldsymbol{\alpha}}f(\boldsymbol{a}) \quad (|\boldsymbol{\alpha}|=m)\]</span><br />从而有<br /><span class="math display">\[    D^{\boldsymbol{\alpha}}f(\boldsymbol{a} + \theta \boldsymbol{h}) =D^{\boldsymbol{\alpha}}f(\boldsymbol{a}) + o(1)  \quad (\boldsymbol{h}\to 0)\]</span><br />所以<br /><span class="math display">\[    \frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a} + \theta\boldsymbol{h})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} =\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} +o(\boldsymbol{h}^{\boldsymbol{\alpha}}) \quad (\boldsymbol{h} \to\boldsymbol{0})\]</span><br />当<spanclass="math inline">\(|\boldsymbol{\alpha}|=m\)</span>时，有<br /><span class="math display">\[    |\boldsymbol{h}^{\boldsymbol{\alpha}}| = |h_1^{\alpha_1} \cdotsh_n^{\alpha_n}| = |h_1|^{\alpha_1} \cdots |h_n|^{\alpha_n} \le \Vert\boldsymbol{h} \Vert^{m}\]</span><br />从而<br /><span class="math display">\[    \sum_{|\boldsymbol{\alpha}| =m}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a} + \theta\boldsymbol{h})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} = \sum_{|\boldsymbol{\alpha}| =m}\frac{D^{\boldsymbol{\alpha}}f(\boldsymbol{a})}{\boldsymbol{\alpha}!}\boldsymbol{h}^{\boldsymbol{\alpha}} + o(\Vert \boldsymbol{h} \Vert^{m})\quad (\boldsymbol{h} \to \boldsymbol{0})\]</span><br />将上式代入(2)式中，即证得命题成立。</p><p>Q.E.D.</p><h4 id="定理7拟微分平均值定理">定理7：拟微分平均值定理</h4><blockquote><p>设<span class="math inline">\(\boldsymbol{f}: [a,b] \to\mathbb{R}^m\)</span>是<spanclass="math inline">\([a,b]\)</span>上的连续映射，在开区间<spanclass="math inline">\((a,b)\)</span>上可微，那么存在一点<spanclass="math inline">\(\xi \in (a,b)\)</span>使得<br /><span class="math display">\[    \Vert \boldsymbol{f}(b) - \boldsymbol{f}(a) \Vert \le \VertJ\boldsymbol{f}(\xi) \Vert (b-a)\]</span></p></blockquote><p>证：设<span class="math inline">\(\boldsymbol{u} = \boldsymbol{f}(b)- \boldsymbol{f}(a)\)</span>，利用<spanclass="math inline">\(\mathbb{R}^m\)</span>中的内积来定义函数<br /><span class="math display">\[    \varphi(t) = \left&lt;\boldsymbol{u}, \boldsymbol{f}(t)\right&gt;\quad (a \le t \le b)\]</span><br />易知<span class="math inline">\(\varphi\)</span>是<spanclass="math inline">\([a,b]\)</span>上的连续函数，并在开区间<spanclass="math inline">\((a,b)\)</span>上可微，对<spanclass="math inline">\(\varphi\)</span>使用微分中值定理，可知存在一点<spanclass="math inline">\(\xi \in (a,b)\)</span>使得<br /><span class="math display">\[    \varphi(b) - \varphi(a) = (b-a)\varphi^\prime(\xi) =(b-a)\left&lt;\boldsymbol{u}, J\boldsymbol{f}(\xi) \right&gt;\]</span><br />而<br /><span class="math display">\[    \varphi(b) - \varphi(a) = \left&lt; \boldsymbol{u},\boldsymbol{f}(b) \right&gt; - \left&lt; \boldsymbol{u},\boldsymbol{f}(a) \right&gt; = \left&lt; \boldsymbol{u},\boldsymbol{f}(b) - \boldsymbol{f}(a)\right&gt; = \left&lt;\boldsymbol{u}, \boldsymbol{u} \right&gt; = \Vert \boldsymbol{u} \Vert^2\]</span><br />由Cauchy-Schwarz不等式，可得<br /><span class="math display">\[    \Vert \boldsymbol{u} \Vert^2 = (b-a)\left&lt; \boldsymbol{u},J\boldsymbol{f}(\xi) \right&gt; \le (b-a)\Vert \boldsymbol{u} \Vert\Vert J\boldsymbol{f}(\xi) \Vert\]</span><br />当<span class="math inline">\(\boldsymbol{u} \ne\boldsymbol{0}\)</span>时，式子两边消去<span class="math inline">\(\Vert\boldsymbol{u} \Vert\)</span>即得证原命题；若<spanclass="math inline">\(\boldsymbol{u} =\boldsymbol{0}\)</span>，命题自然成立。</p><p>Q.E.D.</p><h4 id="定理8">定理8</h4><blockquote><p>设凸区域<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，且映射<span class="math inline">\(\boldsymbol{f}:D \to \mathbb{R}^m\)</span>在<spanclass="math inline">\(D\)</span>上可微，则对任何<spanclass="math inline">\(\boldsymbol{a},\boldsymbol{b} \inD\)</span>，在由<span class="math inline">\(\boldsymbol{a},\boldsymbol{b}\)</span>所决定的线段上必有一点<spanclass="math inline">\(\boldsymbol{\xi}\)</span>，使得<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{b}) - \boldsymbol{f}(\boldsymbol{a}) \le\Vert J\boldsymbol{f}(\boldsymbol{\xi}) \Vert \Vert \boldsymbol{b} -\boldsymbol{a}\Vert\]</span></p></blockquote><p>证：由<span class="math inline">\(\boldsymbol{a}\)</span>与<spanclass="math inline">\(\boldsymbol{b}\)</span>所决定的线段可表示为<br /><span class="math display">\[    \boldsymbol{r}(t) = \boldsymbol{a} + t (\boldsymbol{b} -\boldsymbol{a}) \quad (0 \le t \le 1)\]</span><br />令<br /><span class="math display">\[    \boldsymbol{g}(t) = \boldsymbol{f} \circ \boldsymbol{r}(t)\]</span><br />映射<span class="math inline">\(g\)</span>在<spanclass="math inline">\([0,1]\)</span>上连续，在<spanclass="math inline">\((0,1)\)</span>内可微，从而<br /><span class="math display">\[    J\boldsymbol{g}(t) =J\boldsymbol{f}(\boldsymbol{r}(t))(\boldsymbol{b} - \boldsymbol{a})\]</span><br />由<ahref="https://gamersover.github.io/2021/04/21/函数导数12/#定理7：拟微分平均值定理">定理7</a>可知存在<spanclass="math inline">\(\tau \in (0, 1)\)</span>，使得<br /><span class="math display">\[    \Vert \boldsymbol{g}(1) - \boldsymbol{g}(0)\Vert = \VertJ\boldsymbol{g}(\tau)\Vert\]</span><br />即<br /><span class="math display">\[    \Vert \boldsymbol{f}(\boldsymbol{b}) -\boldsymbol{f}(\boldsymbol{a}) \Vert \le \VertJ\boldsymbol{f}(\boldsymbol{r}(\tau))(\boldsymbol{b} - \boldsymbol{a})\Vert\]</span><br />令<span class="math inline">\(\boldsymbol{\xi} =\boldsymbol{r}(\tau)\)</span>，可得<br /><span class="math display">\[    \Vert \boldsymbol{f}(\boldsymbol{b}) -\boldsymbol{f}(\boldsymbol{a}) \Vert \le \VertJ\boldsymbol{f}(\boldsymbol{\xi})(\boldsymbol{b} - \boldsymbol{a}) \Vert\le \Vert J\boldsymbol{f}(\boldsymbol{\xi}) \Vert \Vert \boldsymbol{b} -\boldsymbol{a} \Vert\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分 </tag>
            
            <tag> Taylor定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数十一：逆映射定理</title>
      <link href="/2021/04/19/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B011/"/>
      <url>/2021/04/19/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B011/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1-局部逆映射定理">定理1: 局部逆映射定理</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^n\)</span>，满足：<br />（a）<span class="math inline">\(\boldsymbol{f} \inC^1(D)\)</span>；<br />（b）有<span class="math inline">\(\boldsymbol{x}_0 \inD\)</span>，使得<br /><span class="math display">\[    \det J\boldsymbol{f}(\boldsymbol{x}_0) \ne 0\]</span><br />记<span class="math inline">\(\boldsymbol{y}_0 =\boldsymbol{f}(\boldsymbol{x}_0)\)</span>，那么存在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的一个邻域<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(\boldsymbol{y}_0\)</span>的一个邻域<spanclass="math inline">\(V\)</span>，使得<br />（1）<span class="math inline">\(\boldsymbol{f}(U) = V\)</span>，且<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(U\)</span>上是单射；<br />（2）记<span class="math inline">\(\boldsymbol{g}\)</span>是<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(U\)</span>上的逆映射，<spanclass="math inline">\(\boldsymbol{g} \in C^1(V)\)</span>；<br />（3）当<span class="math inline">\(\boldsymbol{y} \inV\)</span>时，<br /><span class="math display">\[    J\boldsymbol{g}(\boldsymbol{y}) =(J\boldsymbol{f}(\boldsymbol{x}))^{-1}\]</span><br />其中<span class="math inline">\(\boldsymbol{x} =\boldsymbol{g}(\boldsymbol{y})\)</span>。</p></blockquote><span id="more"></span><p>证：令<br /><span class="math display">\[    \boldsymbol{F}(\boldsymbol{x}, \boldsymbol{y}) =\boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{y}\]</span><br />这个映射定义在<span class="math inline">\(D \times\mathbb{R}^n\)</span>上，显然有<spanclass="math inline">\(\boldsymbol{F} \in C^1(D \times\mathbb{R}^n)\)</span>，并且、<br /><span class="math display">\[    \boldsymbol{F}(\boldsymbol{x}_0, \boldsymbol{y}_0) =\boldsymbol{f}(\boldsymbol{x}_0) - \boldsymbol{y}_0 = \boldsymbol{0}\]</span><br />再由条件（b）可知，<br /><span class="math display">\[    \det J_{\boldsymbol{x}} \boldsymbol{F} (\boldsymbol{x}_0,\boldsymbol{y}_0) = \det J\boldsymbol{f}(\boldsymbol{x}_0) \ne 0\]</span><br />从而由<ahref="https://gamersover.github.io/2021/04/13/函数导数10/#定理3：隐映射定理">函数导数十的定理3</a>可知，存在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的邻域<spanclass="math inline">\(H\)</span>和<spanclass="math inline">\(\boldsymbol{y}_0\)</span>的邻域<spanclass="math inline">\(V\)</span>，其中<span class="math inline">\(H\subset D\)</span>，使得对每一点<spanclass="math inline">\(\boldsymbol{y} \in V\)</span>，方程<spanclass="math inline">\(\boldsymbol{F}(\boldsymbol{x}, \boldsymbol{y}) =\boldsymbol{0}\)</span>即<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x}) =\boldsymbol{y}\)</span>在<spanclass="math inline">\(H\)</span>中有唯一解，记作<spanclass="math inline">\(\boldsymbol{g}(\boldsymbol{y})\)</span>，其中<spanclass="math inline">\(\boldsymbol{g} \in C^1(V)\)</span>，并且当<spanclass="math inline">\(\boldsymbol{y} \in V\)</span>时，<br /><span class="math display">\[    \begin{aligned}    J\boldsymbol{g}(\boldsymbol{y}) &amp;=-(J_{\boldsymbol{x}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{y}))^{-1}J_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{y}) \\    &amp;= -(J\boldsymbol{f}(\boldsymbol{x}))^{-1}(-\boldsymbol{I}_n) \\    &amp;= (J\boldsymbol{f}(\boldsymbol{x}))^{-1}    \end{aligned}\]</span><br />其中<span class="math inline">\(\boldsymbol{x} =\boldsymbol{g}(\boldsymbol{y})\)</span>。令<span class="math inline">\(U= \boldsymbol{g}(V)\)</span>，可见<span class="math inline">\(V =\boldsymbol{f}(U)\)</span>，<spanclass="math inline">\(\boldsymbol{f}\)</span>与<spanclass="math inline">\(\boldsymbol{U}\)</span>互为逆映射，最后证明<spanclass="math inline">\(U\)</span>是开集，事实上有<spanclass="math inline">\(U = H \cap\boldsymbol{f}^{-1}(V)\)</span>，由于<spanclass="math inline">\(V\)</span>是开集且<spanclass="math inline">\(\boldsymbol{f}\)</span>是连续映射，从而根据<ahref="https://gamersover.github.io/2021/01/21/函数极限7/#定理3">函数极限七的定理3</a>知<spanclass="math inline">\(\boldsymbol{f}^{-1}(V)\)</span>是开集，又英文<spanclass="math inline">\(H\)</span>是开集，所以<spanclass="math inline">\(U\)</span>也是开集。</p><h4 id="定理2逆映射定理">定理2：逆映射定理</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^n\)</span>，满足：<br />（a）<span class="math inline">\(\boldsymbol{f} \inC^1(D)\)</span>；<br />（b）对每一个<span class="math inline">\(\boldsymbol{x} \inD\)</span>，有<span class="math inline">\(\detJ\boldsymbol{f}(\boldsymbol{x}) \ne 0\)</span><br />那么<span class="math inline">\(G =\boldsymbol{f}(D)\)</span>是一开集，又如果：<br />（c）<span class="math inline">\(\boldsymbol{f}\)</span>是<spanclass="math inline">\(D\)</span>上的单射，<br />那么：<br />（1）存在从<span class="math inline">\(G\)</span>到<spanclass="math inline">\(D\)</span>上的映射<spanclass="math inline">\(\boldsymbol{f}^{-1}\)</span>，满足：对一切<spanclass="math inline">\(\boldsymbol{y} \in G\)</span>，有<br /><span class="math display">\[    \boldsymbol{f} \circ \boldsymbol{f}^{-1}(\boldsymbol{y}) =\boldsymbol{y}\]</span><br />（2）<span class="math inline">\(\boldsymbol{f}^{-1} \inC^1(G)\)</span>；<br />（3）<br /><span class="math display">\[    J\boldsymbol{f}^{-1}(\boldsymbol{y}) =(J\boldsymbol{f}(\boldsymbol{x}))^{-1} \quad (\boldsymbol{x} =J\boldsymbol{f}^{-1}(\boldsymbol{y}))\]</span></p></blockquote><p>证：由于<spanclass="math inline">\(\boldsymbol{f}\)</span>是单射，所以逆映射<spanclass="math inline">\(\boldsymbol{f}^{-1}\)</span>必然存在，所以（1）成立；再由<ahref="https://gamersover.github.io/2021/04/19/函数导数11/#定理1-局部逆映射定理">定理1</a>可知，（2）（3）自然也成立。接下来只需证明<spanclass="math inline">\(\boldsymbol{f}(D)\)</span>是开集，任取<spanclass="math inline">\(\boldsymbol{y} \in G\)</span>，由<ahref="https://gamersover.github.io/2021/04/19/函数导数11/#定理1-局部逆映射定理">定理1</a>可知，存在<spanclass="math inline">\(\boldsymbol{x}\)</span>的一个邻域<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(\boldsymbol{y}\)</span>的一个邻域<spanclass="math inline">\(V\)</span>，使得<span class="math inline">\(V =\boldsymbol{f}(U) \subset \boldsymbol{f}(D) = G\)</span>，即<spanclass="math inline">\(\boldsymbol{y}\)</span>是<spanclass="math inline">\(G\)</span>的内点，从而<spanclass="math inline">\(G\)</span>是开集。</p><h4 id="定义2正则映射">定义2：正则映射</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^n\)</span>，满足以下三个条件：<br />（1）<span class="math inline">\(\boldsymbol{f} \inC^1(D)\)</span>；<br />（2）<span class="math inline">\(\boldsymbol{f}\)</span>是<spanclass="math inline">\(D\)</span>上的单射；<br />（3）<span class="math inline">\(\det J\boldsymbol{f}(\boldsymbol{x})\ne 0\)</span>对一切<span class="math inline">\(\boldsymbol{x} \inD\)</span>成立。<br />则称<span class="math inline">\(\boldsymbol{f}\)</span>是<spanclass="math inline">\(D\)</span>上的一个正则映射。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 逆映射 </tag>
            
            <tag> 微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UI开发之PyQt5一：控件和布局的关系</title>
      <link href="/2021/04/16/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-1/"/>
      <url>/2021/04/16/UI%E5%BC%80%E5%8F%91%E4%B9%8BpyQt5-1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>PyQt5是一个用来开发UI的python第三方库，UI不外乎显示控件，布局与交互，简单说就是确定UI需要展示哪些东西，这些东西如何排布在界面上以及操作这些东西的逻辑是什么。而PyQt5的控件与布局几乎都在QtWidgets这个类里面，至于交互就是后面所要讲的信号与槽。</p><span id="more"></span><h3 id="显示控件">显示控件</h3><p>PyQt5要显示控件，需要依附在顶层类中，这些顶层类作为主入口来显示其他控件，而顶层显示类大概有三种：<br />1. <strong>QMainWindow</strong><br />最常用的顶层显示类，具有菜单栏、工具栏、状态栏、标题栏等<br />2. <strong>QDialog</strong><br />一般用在对话窗口，属于非长时间展示的窗口，没有菜单栏，工具栏等<br />3. <strong>Qwidget</strong><br />所有显示控件的父类，可以作为UI显示的主窗口，也可以作为子窗口嵌入到其他控件，比较灵活</p><p>以上三个类都在<code>PyQt5.QtWidgets</code>类下面。</p><p>常用显示控件有：</p><ul><li><code>QMenu</code>：菜单栏</li><li><code>QLineEdit</code>：单行文本编辑框</li><li><code>QTextEdit</code>：多行文本编辑框</li><li><code>QProgressBar</code>：进度条</li><li><code>QPushButton</code>：按钮</li><li><code>QRadioButton</code>：单选按钮</li><li><code>QCheckBox</code>：复选按钮</li><li><code>QLable</code>：标签类，用来显示文本或图片</li></ul><p>以上控件也在<code>PyQt5.QtWidgets</code>类下面。</p><h3 id="布局">布局</h3><p>一个父控件下面可以包含许多子控件，而子控件的显示方式就依赖于布局，PyQt5中的布局方式有很多，这里先简单介绍几种：<br />1. <strong>QHBoxLayout</strong><br />水平显示布局，所有的控件水平排列<br />2. <strong>QVBoxLayout</strong><br />垂直显示布局，所有的控件垂直排列<br />3. <strong>QGridLayout</strong><br />网格布局，可以指定控件的具体位置（哪行哪列）</p><p>以上布局在<code>PyQt5.QtWidgets</code>类下面。</p><p>PyQt5控件布局的基本逻辑是：<br />1. 父控件假设为<code>pWidget</code>，<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pWidget = QWidget()</span><br></pre></td></tr></table></figure><br />2. 给该控件添加一种布局<code>layout</code><br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pWidget.setLayout(layout)</span><br></pre></td></tr></table></figure><br />3. 在layout里面添加子控件<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout.addWidget(widget1)</span><br><span class="line">layout.addWidget(widget2)</span><br></pre></td></tr></table></figure></p><h2 id="例子">例子</h2><h3 id="主窗口写法">主窗口写法</h3><p>界面展示：<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/pyqt%E6%95%99%E7%A8%8B/No1.jpg" width="25%"><br />代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow, QApplication</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QMainWindow</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MainWindow, self).__init__(parent)</span><br><span class="line">        self.init_ui()</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_ui</span>(<span class="params">self</span>):</span><br><span class="line">        self.setGeometry(<span class="number">200</span>, <span class="number">200</span>, <span class="number">1600</span>, <span class="number">800</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;主窗口&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    window = MainWindow()</span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p>可以看到初始化了一个主窗口<code>QMainWindow</code>，其中Qt程序的入口使用<code>QApplication</code>类实现，主窗口的属性如下：</p><table><colgroup><col style="width: 11%" /><col style="width: 38%" /><col style="width: 49%" /></colgroup><thead><tr class="header"><th style="text-align: left;"></th><th style="text-align: left;">API</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">窗口大小与位置</td><td style="text-align: left;">setGeometry(ax: int, ay: int, aw: int, ah:int)</td><tdstyle="text-align: left;">统一设置窗口的显示位置和大小，ax,ay表示窗口左上角坐标，aw,ah表示窗口的宽和高，都是以像素为单位</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">move(ax: int, ay: int)</td><td style="text-align: left;">单独设置窗口的显示位置即左上角坐标</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setFixedSize(w: int, h: int)</td><td style="text-align: left;">单独设置窗口的大小即宽和高</td></tr><tr class="even"><td style="text-align: left;"></td><td style="text-align: left;">setFixedWidth(w: int)</td><td style="text-align: left;">单独设置窗口的宽</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setFixedHeight(h: int)</td><td style="text-align: left;">单独设置窗口的高</td></tr><tr class="even"><td style="text-align: left;">窗口标题与图标</td><td style="text-align: left;">setWindowTitle(a0: str)</td><td style="text-align: left;">设置窗口标题</td></tr><tr class="odd"><td style="text-align: left;"></td><td style="text-align: left;">setWindowIcon(icon: QIcon)</td><td style="text-align: left;">设置窗口图标</td></tr><tr class="even"><td style="text-align: left;">控件显示</td><td style="text-align: left;">show()</td><td style="text-align: left;">显示控件与其子控件</td></tr></tbody></table><h3 id="设置布局和添加控件">设置布局和添加控件</h3><p>有了主窗口后，就可以添加想要添加的控件了，如下面代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">init_ui</span>(<span class="params">self</span>):</span><br><span class="line">    self.setGeometry(<span class="number">200</span>, <span class="number">200</span>, <span class="number">1600</span>, <span class="number">800</span>)</span><br><span class="line">    self.setWindowTitle(<span class="string">&quot;主窗口&quot;</span>)</span><br><span class="line"></span><br><span class="line">    main_widget = QWidget()</span><br><span class="line">    main_layout = QVBoxLayout()</span><br><span class="line">    main_widget.setLayout(main_layout)</span><br><span class="line">    line_edit1 = QLineEdit()</span><br><span class="line">    line_edit1.setPlaceholderText(<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">    line_edit2 = QLineEdit()</span><br><span class="line">    line_edit2.setPlaceholderText(<span class="string">&quot;密码&quot;</span>)</span><br><span class="line">    main_layout.addWidget(line_edit1)</span><br><span class="line">    main_layout.addWidget(line_edit2)</span><br><span class="line"></span><br><span class="line">    self.setCentralWidget(main_widget)</span><br></pre></td></tr></table></figure><p>其中创建了一个主控件<code>main_widget</code>用来显示其他控件，使用<code>setCentralWidget(main_widget)</code>可以将<code>main_widget</code>设置为主窗口<code>QMainWindow</code>的中央控件，该控件使用了垂直布局方式<code>QVBoxlayout</code>，其中包含两个文本编辑子控件<code>QLineEdit</code>。从这里也可以看出widget和layout的关系：</p><blockquote><p>widget.setLayout(layout)<br />layout.addWidget(widget)</p></blockquote><p><code>widget</code>通过<code>setLayout</code>方法添加布局，而<code>layout</code>通过<code>addWidget</code>方法添加子控件。</p><h3 id="控件的嵌套">控件的嵌套</h3><p>当需要实现复杂的UI界面时，控件之间嵌套必不可少，比如要实现下图中的界面：<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/pyqt%E6%95%99%E7%A8%8B/No3.jpg" width="25%"><br />可以先整理下该界面中的有哪些控件以及包含关系：<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/pyqt%E6%95%99%E7%A8%8B/No2.jpg" width="60%"><br />其中主控件(<code>main_widget</code>)包含左右两个控件，而右边控件(<code>right_widget</code>)又包含两个控件，所以代码实现为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow, QApplication, QVBoxLayout, QWidget, QHBoxLayout</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span>(<span class="title class_ inherited__">QMainWindow</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(MainWindow, self).__init__(parent)</span><br><span class="line">        self.init_ui()</span><br><span class="line">        self.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">init_ui</span>(<span class="params">self</span>):</span><br><span class="line">        self.setStyleSheet(<span class="string">&quot;border:2px solid black&quot;</span>)</span><br><span class="line">        self.setGeometry(<span class="number">1000</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">300</span>)</span><br><span class="line">        self.setWindowTitle(<span class="string">&quot;主窗口&quot;</span>)</span><br><span class="line"></span><br><span class="line">        main_widget = QWidget()</span><br><span class="line">        self.setCentralWidget(main_widget)</span><br><span class="line"></span><br><span class="line">        main_layout = QHBoxLayout()</span><br><span class="line">        main_widget.setLayout(main_layout)</span><br><span class="line"></span><br><span class="line">        left_widget = QWidget()</span><br><span class="line">        right_widget = QWidget()</span><br><span class="line">        main_layout.addWidget(left_widget)</span><br><span class="line">        main_layout.addWidget(right_widget)</span><br><span class="line"></span><br><span class="line">        right_layout = QVBoxLayout()</span><br><span class="line">        right_widget.setLayout(right_layout)</span><br><span class="line"></span><br><span class="line">        top_widget = QWidget()</span><br><span class="line">        buttom_widget = QWidget()</span><br><span class="line">        right_layout.addWidget(top_widget)</span><br><span class="line">        right_layout.addWidget(buttom_widget)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app = QApplication(sys.argv[<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">    window = MainWindow()</span><br><span class="line">    window.show()</span><br><span class="line"></span><br><span class="line">    sys.exit(app.exec_())</span><br></pre></td></tr></table></figure><p><code>main_widget</code>使用了<code>QHBoxLayout</code>布局方式，包含<code>left_widget</code>和<code>right_widget</code>两个子控件；而<code>right_widget</code>使用了<code>QVBoxLayout</code>布局方式，包含了<code>top_widget</code>和<code>buttom_widget</code>两个子控件。</p>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UI开发 </tag>
            
            <tag> Qt </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库之sql实践</title>
      <link href="/2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8Bsql%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B9%8Bsql%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<!--    view视图的概念？    开始声明多种sql数据库的存在，然后这里使用hivesql2.x版本作为演示等等等    1. 可首先用脑图作为辅助介绍数据库->表->字段->数据的概念    2. 接着介绍sql关键词的书写顺序和执行顺序    3. 再介绍一些实践操作和join等等操作--><h1 id="概述">1. 概述</h1><p>数据库，顾名思义用来存放数据的地方，可以把数据库比作图书馆，图书馆里面有不同区域相当于不同的数据库（database），而每个区域又存放着不同的书籍，相当于每个database含有很多表（table），图中表现了这种关系。<br /><span id="more"></span></p><p><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/%E6%95%B0%E6%8D%AE%E5%BA%93/No1.jpg" width="25%"></p><p>而表中有包含数据，数据是由记录（行）和字段（列）构成的，每条记录的字段的数据就是存储的数据。表即普通的表格，下表中有两条记录（两行），三个字段（三列）为<code>id</code>，<code>name</code>，<code>age</code>。</p><table><thead><tr class="header"><th style="text-align: center;">id</th><th style="text-align: center;">name</th><th style="text-align: center;">age</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">0</td><td style="text-align: center;">superman</td><td style="text-align: center;">32</td></tr><tr class="even"><td style="text-align: center;">1</td><td style="text-align: center;">wonderwoman</td><td style="text-align: center;">102</td></tr></tbody></table><p>对于数据库，表，记录，字段都有增、删、改、查的操作，而sql（StructuredQueryLanguage）即结构化查询语言就是用来完成这些操作的，对于不同的对象有着不同的sql语句。大致包含对数据库的操作，对表的操作，对字段的操作，对记录的操作。在执行单条sql语句时可以不以<code>;</code>结束，但是执行多条语句时需要以<code>;</code>结束。而且sql语句大小写不敏感，即不区分大小写。</p><h1 id="数据库操作sql">2. 数据库操作sql</h1><h2 id="查">2.1 查</h2><ul><li><p><strong>show databases</strong>：查询当前所有数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">SHOW DATABASES;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p><strong>use 数据库名</strong>：连接到指定的数据库<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">use mysql;</span></span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure></p></li><li><p><strong>show tables</strong>：查看该数据库中的所有表<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show tables;</span></span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">| Tables_in_mysql                                      |</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">| columns_priv                                         |</span><br><span class="line">| component                                            |</span><br><span class="line">| db                                                   |</span><br><span class="line">| default_roles                                        |</span><br><span class="line">...</span><br><span class="line">| engine_cost                                          |</span><br><span class="line">| func                                                 |</span><br><span class="line">| time_zone_name                                       |</span><br><span class="line">+------------------------------------------------------+</span><br><span class="line">35 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p></li></ul><h2 id="增">2.2 增</h2><ul><li><strong>create database 数据库名</strong>：创建数据库<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create database mydatabase;</span></span><br><span class="line">Query OK, 1 row affected (1.93 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydatabase         |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="删">2.3 删</h2><ul><li><strong>drop database 数据库名</strong>：删除数据库<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">drop database mydatabase;</span></span><br><span class="line">Query OK, 0 rows affected (2.01 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="改">2.4 改</h2><p>数据库名称没有直接修改命令，只能重新创建新库然后导入旧库</p><h1 id="表操作sql">3. 表操作sql</h1><h2 id="增-1">3.1 增</h2><ul><li><strong>create table</strong>： 创建表<br />语法：<br /><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名</span><br><span class="line">(</span><br><span class="line">字段名1 数据类型,</span><br><span class="line">字段名2 数据类型,</span><br><span class="line">字段名3 数据类型,</span><br><span class="line"><span class="meta prompt_">...</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><br />数据库的基本数据类型可以分为三种：数字型，字符串型，日期型，而数字型又有整型和小数。由于每一种数据库的数据类型不太一样，以mysql为例<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create table dc_character(</span></span><br><span class="line">       id int,</span><br><span class="line">       name varchar(255),</span><br><span class="line">       age int)</span><br><span class="line">Query OK, 0 rows affected (2.60 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="查-1">3.2 查</h2><ul><li><strong>desc 表名</strong>：查看表详情<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc_character;</span></span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| id    | int          | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| age   | int          | YES  |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="改-1">3.3 改</h2><ul><li><strong>alter table 旧表名 rename to 新表名</strong>：修改表名<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">alter table dc_character rename to dc;</span></span><br><span class="line">Query OK, 0 rows affected (2.17 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show tables;</span></span><br><span class="line">+----------------------+</span><br><span class="line">| Tables_in_mydatabase |</span><br><span class="line">+----------------------+</span><br><span class="line">| dc                   |</span><br><span class="line">+----------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="删-1">3.4 删</h2><ul><li><strong>drop table 表名</strong>：删除表<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">drop table dc;</span></span><br><span class="line">Query OK, 0 rows affected (2.14 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">show databases;</span></span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mydatabase         |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="字段操作sql">3.5 字段操作sql</h2><p>字段即表的列属性，而表字段本身包含5个属性：<br />1. <strong>Field</strong>：字段的名称<br />2. <strong>Type</strong>：字段数据类型<br />3.<strong>Null</strong>：字段的数据是否可以为<code>Null</code>，取值可以是<code>null</code>或者<code>not null</code>，后者就表示字段取值不可以是空<br />4.<strong>KEY</strong>：字段是否是主键或外来键，取值有<code>primary key</code>，<code>unique Key</code>,<code>key</code> 和 <code>foreign Key</code><br />5. <strong>Default</strong>：字段的默认值<br />6. <strong>Extra</strong>：字段的一些额外信息</p><h3 id="增-2">3.5.1 增</h3><p>创建字段时可以加入属性，基本语法为<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="selector-attr">[Null取值]</span> <span class="selector-attr">[KEY取值]</span> <span class="selector-attr">[Default 默认值]</span> <span class="selector-attr">[Extra信息]</span></span><br></pre></td></tr></table></figure></p><p>比如<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">create table dc(</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash"><span class="built_in">id</span> int primary key auto_increment,</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">name varchar(255) not null,</span></span><br><span class="line"><span class="meta prompt_">  -&gt; </span><span class="language-bash">age int default 30);</span></span><br><span class="line">Query OK, 0 rows affected (1.35 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+-------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+-------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id    | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |                |</span><br><span class="line">| age   | int          | YES  |     | 30      |                |</span><br><span class="line">+-------+--------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure></p><p>创建了表，其中<code>id</code>字段设置为主键，并设置为自增；<code>name</code>字段设置数据不能为<code>Null</code>；<code>age</code>字段设置默认值为30。</p><h3 id="查-2">3.5.2 查</h3><p>查询表的字段信息与前面的<ahref="https://gamersover.github.io/2021/04/16/数据库之sql实践/#3-2-查">表操作查询</a>一样</p><h3 id="改-2">3.5.3 改</h3><ul><li><p><strong>alter table 表名 add 新字段名数据类型</strong>：增加字段<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">alter table dc add power bigint;</span></span><br><span class="line">Query OK, 0 rows affected (2.14 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| id    | int          | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| age   | int          | YES  |     | NULL    |       |</span><br><span class="line">| power | bigint       | YES  |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>alter table 表名称 change 旧字段名 新字段名新字段类型</strong>：修改字段<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">alter table dc change power power_level int;</span></span><br><span class="line">Query OK, 2 rows affected (2.36 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| id          | int          | YES  |     | NULL    |       |</span><br><span class="line">| name        | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| age         | int          | YES  |     | NULL    |       |</span><br><span class="line">| power_level | int          | YES  |     | NULL    |       |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p></li><li><p><strong>alter table 表名称 modify 字段名称新字段类型</strong>：只修改字段类型<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">alter table dc modify power_level bigint;</span></span><br><span class="line">Query OK, 2 rows affected (2.56 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field       | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">| id          | int          | YES  |     | NULL    |       |</span><br><span class="line">| name        | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| age         | int          | YES  |     | NULL    |       |</span><br><span class="line">| power_level | bigint       | YES  |     | NULL    |       |</span><br><span class="line">+-------------+--------------+------+-----+---------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="删-2">3.5.4 删</h3><ul><li><strong>alter table 表名 drop 字段名</strong>：删除字段<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">ysql&gt; </span><span class="language-bash">alter table dc drop power_level;</span></span><br><span class="line">Query OK, 0 rows affected (1.14 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| Field | Type         | Null | Key | Default | Extra |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">| id    | int          | YES  |     | NULL    |       |</span><br><span class="line">| name  | varchar(255) | YES  |     | NULL    |       |</span><br><span class="line">| age   | int          | YES  |     | NULL    |       |</span><br><span class="line">+-------+--------------+------+-----+---------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul><h2 id="数据操作sql">3.6 数据操作sql</h2><p>假设表<code>dc</code>的结构为<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">desc dc;</span></span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field      | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id         | int          | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name       | varchar(255) | NO   |     | NULL    |                |</span><br><span class="line">| age        | int          | YES  |     | 30      |                |</span><br><span class="line">| powerlevel | int          | YES  |     | NULL    |                |</span><br><span class="line">+------------+--------------+------+-----+---------+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h3 id="查-3">3.6.1 查</h3><p>查询表数据是最重要，也是最常用的sql语句。</p><h4 id="基本语法">3.6.1.1 基本语法</h4><ul><li><strong>select 字段1 [as 别名1], 字段2 [as 别名2], ... from 表名[where 条件] [order by 字段名 [desc|asc]] [limit条数]</strong>：从表中选择满足条件的数据的指定字段，再按照某个字段排序后并限制前面多少条输出<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc; <span class="comment">-- 最简单的查询语句，查询所有记录，* 表示所有字段</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman      <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> flash       <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> lantern     <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">6</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> supergirl   <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> cyborg      <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">5</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">35</span>; <span class="comment">-- 加入条件查询年龄age大于等于25的记录</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman   <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> name, age, powerlevel <span class="keyword">from</span> dc <span class="keyword">where</span> age<span class="operator">&gt;=</span> <span class="number">35</span> <span class="keyword">order</span> <span class="keyword">by</span> powerlevel; <span class="comment">-- 在上一个查询基础上加入对结果按powerlevel排序，默认按升序（asc），加入关键词desc，可以使结果按降序</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name     <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman   <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+----------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc limit <span class="number">3</span>; <span class="comment">-- 查询记录只显示前面3条</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman      <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h4 id="聚合语法">3.6.1.2 聚合语法</h4><ul><li><strong>select [字段1, 字段2, ...] 聚合函数3(字段3) [ [as] 别名3],聚合函数4(字段4) [ [as] 别名4], ... from 表名 [group by 字段1, 字段2,...]</strong>：对某几个字段聚合，即相同的归一类，然后对其他字段求聚合函数，比如最大最小值等<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="built_in">max</span>(powerlevel) <span class="keyword">from</span> dc <span class="keyword">where</span> age<span class="operator">&lt;</span><span class="number">35</span>; <span class="comment">-- 不加group by 对所有记录取聚合函数</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">max</span>(powerlevel) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span>               <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> age, <span class="built_in">max</span>(powerlevel) <span class="keyword">as</span> mp <span class="keyword">from</span> dc <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> mp <span class="keyword">desc</span>; <span class="comment">-- 查看年龄相同的数据中分别最大的powerlevel，并按照最大值降序排序，取别名 as 可以省略，直接 max(powerlevel) mp</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> age  <span class="operator">|</span> mp   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span>    <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h4 id="多表联合查询">3.6.1.3 多表联合查询</h4><p>有时候需要联合多个表的数据来统计结果，这时需要用到<code>join</code>语句，与前面两种语法相比，只需要改变<code>from</code>后面的语法即可。</p><ul><li><strong>select ... from 表1 [ [as] 别名1 ] [left|right|outer|inner]join 表2 [ [as] 别名2 ] on ([表1|别名1].字段1=[表2|别名2].字段1 [and表1.字段1=表2.字段1]...)</strong>：基于相同字段的值联合多个表查询</li></ul><p>假设新增一个表<code>dc_name</code>，其数据为<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc_name;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name       <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> lex luthor <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> batman     <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p><h5 id="inner-join">inner join</h5><blockquote><p>表示两个表取交集，即两个表都存在的数据取出</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc t1 <span class="keyword">inner</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name); <span class="comment">-- 默认会输出两个表的所有字段，若只写join，则默认是inner join</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+--------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span> id   <span class="operator">|</span> name   <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+--------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> batman <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+--------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.<span class="operator">*</span>, t2.iq <span class="keyword">from</span> dc t1 <span class="keyword">inner</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name); <span class="comment">-- 只要t1的所有字段，t2的iq字段</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------+------+------------+------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="outer-join">outer join</h5><blockquote><p>表示两个表取并集，即两个表存在的数据都会取出，全称<code>full outer join</code>，不过有些mysql版本不支持，具体可以使用下面介绍到的<code>union</code>语法替代</p></blockquote><h5 id="left-join">left join</h5><blockquote><p>左表的数据不会丢失，将右表的数据添加到左表中；即左表有而右边没有的数据填null，而左表没有右表有的数据丢弃，左右表都有的数据直接添加</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.<span class="operator">*</span>, t2.iq <span class="keyword">from</span> dc t1 <span class="keyword">left</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name); <span class="comment">-- 一般left join 或者 right join 会加入where条件过滤，比如where iq is not null，则效果相当于inner join的效果</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> batman      <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> flash       <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">7</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> lantern     <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">6</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> supergirl   <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7</span> <span class="operator">|</span> cyborg      <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">5</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+------+</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h5 id="right-join">right join</h5><blockquote><p>与left join正好相反，右表的数据不会丢失</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> t1.<span class="operator">*</span>, t2.iq <span class="keyword">from</span> dc t1 <span class="keyword">right</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name);</span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name   <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>   <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> batman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+--------+------+------------+------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>注意：2个以上表的join语法<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a</span><br><span class="line"><span class="keyword">join</span> b <span class="keyword">on</span> (a.a1<span class="operator">=</span>b.b1)</span><br><span class="line"><span class="keyword">join</span> c <span class="keyword">on</span> (a.a1<span class="operator">=</span>c.c1)</span><br></pre></td></tr></table></figure></p><h4 id="子查询">3.6.1.4 子查询</h4><p>以上语法中<code>from</code>语法后的表名都可以替换为<code>select</code>查询语句得到的中间结果，相当于从中间查询结果中再次查询，具体语法是</p><ul><li><strong>select ... from (select ... from ...)...</strong>：嵌套查询，从中间查询结果中再次查询，一般会将中间查询结果与原表<code>join</code>后再查询<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> dc.<span class="operator">*</span> <span class="keyword">from</span> dc <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> age, <span class="built_in">max</span>(powerlevel) <span class="keyword">as</span> mp <span class="keyword">from</span> dc <span class="keyword">group</span> <span class="keyword">by</span> age) t1 <span class="keyword">on</span> (dc.age<span class="operator">=</span>t1.age <span class="keyword">and</span> dc.powerlevel<span class="operator">=</span>t1.mp); <span class="comment">-- 查询年龄age相同的数据中，powerlevel最大的记录并包含名字name等所有原始信息的数据</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> flash       <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">7</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> supergirl   <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul><h4 id="查询结果合并">3.6.1.5 查询结果合并</h4><p>union语法，可以合并多个<code>select</code>语句的查询结果，具体语法：</p><ul><li><strong>select ... from ... [distinct] union select ... from...</strong></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc t1 <span class="keyword">left</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name)</span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">union</span></span><br><span class="line">    <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc t1 <span class="keyword">right</span> <span class="keyword">join</span> dc_name t2 <span class="keyword">on</span> (t1.name<span class="operator">=</span>t2.name);  <span class="comment">-- 使用union语句合并left join与right join的结果，相当于full outer join</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+------+------------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span> id   <span class="operator">|</span> name       <span class="operator">|</span> iq   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+------+------------+------+------------+------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">3</span> <span class="operator">|</span> batman      <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">4</span> <span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> batman     <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">4</span> <span class="operator">|</span> flash       <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">7</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">5</span> <span class="operator">|</span> lantern     <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">6</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">6</span> <span class="operator">|</span> supergirl   <span class="operator">|</span>   <span class="number">33</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> cyborg      <span class="operator">|</span>   <span class="number">32</span> <span class="operator">|</span>          <span class="number">5</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>        <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> lex luthor <span class="operator">|</span>  <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+------+------------+------+------------+------+</span></span><br><span class="line"><span class="number">8</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="增-3">3.6.2 增</h3><ul><li><p><strong>insert into 表名 (字段1, 字段2, ...) values (字段1数据,字段2数据, ...)</strong>：向表中添加一行数据<br /><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into dc values (0, <span class="string">&#x27;superman&#x27;</span>, 35, 10);</span></span><br><span class="line">Query OK, 1 row affected (0.08 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from dc;</span></span><br><span class="line">+----+----------+------+------------+</span><br><span class="line">| id | name     | age  | powerlevel |</span><br><span class="line">+----+----------+------+------------+</span><br><span class="line">|  1 | superman |   35 |         10 |</span><br><span class="line">+----+----------+------+------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><br />注意到:</p><ul><li>如果不填字段名称，默认所有字段按顺序匹配</li><li>由于<code>id</code>是自增的，所以<code>id</code>默认从1开始，添加数据的时候也可以指定字段，这样<code>id</code>会自动加1。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">insert into dc (name, age) values (<span class="string">&#x27;wonderwoman&#x27;</span>, 34);</span></span><br><span class="line">Query OK, 1 row affected (0.12 sec)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">mysql&gt; </span><span class="language-bash">select * from mydatabase.dc;</span></span><br><span class="line">+----+-------------+------+------------+</span><br><span class="line">| id | name        | age  | powerlevel |</span><br><span class="line">+----+-------------+------+------------+</span><br><span class="line">|  1 | superman    |   35 |         10 |</span><br><span class="line">|  2 | wonderwoman |   34 |       NULL |</span><br><span class="line">+----+-------------+------+------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>注意到<code>id</code>自增1，<code>powerlevel</code>会取默认值<code>NULL</code>。</p></li><li><p><strong>insert (into|overwrite) 表名select查询语句</strong>：从另一表中中导入数据</p><ul><li>into是追加方式</li><li>overwirte是重写方式</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> dc_name (id <span class="type">int</span>, name <span class="type">varchar</span>(<span class="number">255</span>)); <span class="comment">-- 创建新表dc_name</span></span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">2.56</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> tables;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> Tables_in_mydatabase <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="operator">|</span> dc                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> dc_name              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> dc_name <span class="keyword">select</span> id, name <span class="keyword">from</span> dc; <span class="comment">-- 从dc表中导入数据给新表dc_name</span></span><br><span class="line">Query OK, <span class="number">2</span> <span class="keyword">rows</span> affected (<span class="number">0.92</span> sec)</span><br><span class="line">Records: <span class="number">2</span>  Duplicates: <span class="number">0</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc_name;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><h3 id="删-3">3.6.3 删</h3></li><li><p><strong>delete from 表名 [where条件]</strong>：根据条件从表中删除数据<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> dc_name <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 删除id=1的记录</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.10</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc_name;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id   <span class="operator">|</span> name        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="operator">|</span>    <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">delete</span> <span class="keyword">from</span> dc_name; <span class="comment">-- 不加条件，默认删除所有记录</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc_name;</span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p></li></ul><h3 id="改-3">3.6.4 改</h3><ul><li><strong>update 表名 set 字段1=值1 [, 字段2=值2, ...] where条件</strong>：修改某个数据<br /><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">34</span> <span class="operator">|</span>       <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> dc <span class="keyword">set</span> age<span class="operator">=</span><span class="number">30</span>, powerlevel<span class="operator">=</span><span class="number">8</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">2</span>; <span class="comment">-- 修改id=2的age字段与powerlevel字段</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">0.08</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">2</span>  Changed: <span class="number">2</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">30</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">update</span> dc <span class="keyword">set</span> age<span class="operator">=</span><span class="number">35</span>; <span class="comment">-- 不加where条件，默认修改所有行的age字段值</span></span><br><span class="line">Query OK, <span class="number">1</span> <span class="type">row</span> affected (<span class="number">1.94</span> sec)</span><br><span class="line"><span class="keyword">Rows</span> matched: <span class="number">2</span>  Changed: <span class="number">1</span>  Warnings: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dc;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> name        <span class="operator">|</span> age  <span class="operator">|</span> powerlevel <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> superman    <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>         <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> wonderwoman <span class="operator">|</span>   <span class="number">35</span> <span class="operator">|</span>          <span class="number">8</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+------+------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数十：隐函数、隐映射定理</title>
      <link href="/2021/04/13/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B010/"/>
      <url>/2021/04/13/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B010/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1隐式方程">定义1：隐式方程</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^2\)</span>是一开集，<span class="math inline">\(F: D \to\mathbb{R}\)</span>是一个含有两个自变量<spanclass="math inline">\(x,y\)</span>的函数，对于<spanclass="math inline">\(D\)</span>中的点<spanclass="math inline">\((x,y)\)</span>满足方程<br /><span class="math display">\[    F(x,y) = 0\]</span><br />的点的全体组成<spanclass="math inline">\(D\)</span>内的一条曲线，而方程就称为该曲线的隐式方程。</p></blockquote><span id="more"></span><h4 id="定理1隐函数定理">定理1：隐函数定理</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^2\)</span>，函数<span class="math inline">\(F: D \to\mathbb{R}\)</span>满足条件：<br />（a）<span class="math inline">\(F \in C^1(D)\)</span>；<br />（b）点<span class="math inline">\((x_0,y_0) \in D\)</span>使得<spanclass="math inline">\(F(x_0,y_0) = 0\)</span>；<br />（c）<span class="math inline">\(\frac{\partial F(x_0,y_0)}{\partial y}\ne 0\)</span><br />那么存在一个包含<spanclass="math inline">\((x_0,y_0)\)</span>的开矩形<spanclass="math inline">\(I \times J \subset D\)</span>，使得：<br />（1）对每一个<span class="math inline">\(x \in I\)</span>，方程<spanclass="math inline">\(F(x,y)=0\)</span>在<spanclass="math inline">\(J\)</span>中有唯一的解<spanclass="math inline">\(f(x)\)</span>；<br />（2）<span class="math inline">\(y_0 = f(x_0)\)</span>；<br />（3）<span class="math inline">\(f \in C^1(I)\)</span>；<br />（4）当<span class="math inline">\(x \in I\)</span>时，有<br /><span class="math display">\[    f^\prime(x) = -\frac{\frac{\partial F}{\partialx}(x,y)}{\frac{\partial F}{\partial y}(x,y)}\]</span><br />其中<span class="math inline">\(y = f(x)\)</span>。</p></blockquote><p>证：不妨设<span class="math inline">\(\displaystyle \frac{\partialF(x_0,y_0)}{\partial y} &gt; 0\)</span>，由条件<spanclass="math inline">\((a)\)</span>可知，存在一个包含<spanclass="math inline">\((x_0,y_0)\)</span>的开矩形<spanclass="math inline">\(I^\prime \times J\)</span>，满足<spanclass="math inline">\(I^\prime \times \bar J \subsetD\)</span>，且在<span class="math inline">\(I^\prime \times \barJ\)</span>上有<span class="math inline">\(\displaystyle \frac{\partialF}{\partial y} &gt; 0\)</span>。从而对任意给定的<spanclass="math inline">\(x \in I^\prime\)</span>，<spanclass="math inline">\(F(x,y)\)</span>在闭区间<spanclass="math inline">\(\bar J\)</span>上是严格递增的连续函数。设<spanclass="math inline">\(J = (c,d)\)</span>，由条件<spanclass="math inline">\((b)\)</span>可知必有<br /><span class="math display">\[    F(x_0, c) &lt; 0, \quad F(x_0, d) &gt; 0\]</span><br />由条件<span class="math inline">\((a)\)</span>能推出<spanclass="math inline">\(F \in C(D)\)</span>，因此存在含<spanclass="math inline">\(x_0\)</span>的开区间<span class="math inline">\(I\subset I^\prime\)</span>，使得当<span class="math inline">\(x \inI\)</span>时，<br /><span class="math display">\[    F(x, c) &lt; 0, \quad F(x, d) &gt; 0\]</span><br />由连续函数的零值定理和严格单调性可知，对每一个<spanclass="math inline">\(x \in I\)</span>，存在唯一的一个数，记作<spanclass="math inline">\(f(x) \in (c, d) = J\)</span>，使得<spanclass="math inline">\(F(x, f(x)) =0\)</span>，这就证明了（1），显然<spanclass="math inline">\(f\)</span>满足（2）。<br />为了证明（3）和（4），先证明<spanclass="math inline">\(f\)</span>在开区间<spanclass="math inline">\(I\)</span>上连续。特别地，<spanclass="math inline">\(x_0 \in I\)</span>，由上面的证明可知无论区间<spanclass="math inline">\(J\)</span>取得多小，一定存在足够小的区间<spanclass="math inline">\(I\)</span>使得对每一个<spanclass="math inline">\(x \in I\)</span>时，有<spanclass="math inline">\(f(x) \in J\)</span>；这时<spanclass="math inline">\(|f(x) - f(x_0)| &lt; |J|\)</span>，其中<spanclass="math inline">\(|J|\)</span>表示区间<spanclass="math inline">\(J\)</span>的长度。即证明了<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处连续。现任取<spanclass="math inline">\(x_1 \in I\)</span>，设<spanclass="math inline">\(y_1 = f(x_1)\)</span>，则<spanclass="math inline">\((x_1,y_1) \in I \times J\)</span>。因为有<spanclass="math inline">\(F(x_1,y_1)=0\)</span>，<spanclass="math inline">\(\displaystyle \frac{\partial F(x_1,y_1)}{\partialy} &gt; 0\)</span>，所以<span class="math inline">\(F\)</span>在点<spanclass="math inline">\((x_1,y_1)\)</span>处满足它在<spanclass="math inline">\((x_0,y_0)\)</span>处的同样条件，所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_1\)</span>处也是连续的，从而<spanclass="math inline">\(f\)</span>在整个区间<spanclass="math inline">\(I\)</span>上连续。<br />再证（3）和（4）。设<span class="math inline">\(x \inI\)</span>，取<span class="math inline">\(h\)</span>很小，使得<spanclass="math inline">\(x+h \in I\)</span>。令<spanclass="math inline">\(y = f(x)\)</span>，<span class="math inline">\(k =f(x+h) - f(x)\)</span>。由<spanclass="math inline">\(F\)</span>的可微性，并利用<ahref="https://gamersover.github.io/2021/03/31/函数导数8/#定理1">函数导数八的定理1</a>可得<br /><span class="math display">\[    0 = F(x+h, y+k) - F(x, y) = \frac{\partial F}{\partial x}(x, y) h +\frac{\partial F}{\partial y}(x, y) k + \alpha h + \beta k\]</span><br />其中当<span class="math inline">\(h \to 0\)</span>时，<spanclass="math inline">\(\alpha \to 0\)</span>，当<spanclass="math inline">\(k \to 0\)</span>时，<spanclass="math inline">\(\beta \to 0\)</span>。又由于<spanclass="math inline">\(f \in C(I)\)</span>，所以当<spanclass="math inline">\(h \to 0\)</span>时，<span class="math inline">\(k\to 0\)</span>，从而<span class="math inline">\(\beta \to0\)</span>。从而<br /><span class="math display">\[    \lim \limits_{h \to 0} \frac{f(x + h) - f(x)}{h} = \lim \limits_{h\to 0} \frac{k}{h} = \lim\limits_{h \to 0} \frac{-\frac{\partialF}{\partial x} + \alpha}{\frac{\partial F}{\partial y} + \beta}\]</span><br />即<br /><span class="math display">\[    f^\prime(x) = - \frac{\frac{\partial F}{\partial x} (x,y)}{\frac{\partial F}{\partial y} (x,y)}\]</span><br />其中<span class="math inline">\(x \in I\)</span>且<spanclass="math inline">\(y = f(x)\)</span>。由于<spanclass="math inline">\((a)\)</span>知，<spanclass="math inline">\(f^\prime\)</span>在<spanclass="math inline">\(I\)</span>上连续。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^{n+1}\)</span>，<span class="math inline">\(F: D \to\mathbb{R}\)</span>，满足条件：<br />（a）<span class="math inline">\(F \in C^1(D)\)</span>；<br />（b）<span class="math inline">\(F(\boldsymbol{x}_0, y_0) =0\)</span>，这里<span class="math inline">\(\boldsymbol{x}_0 \in\mathbb{R}^n,y_0 \in \mathbb{R}\)</span>且<spanclass="math inline">\((\boldsymbol{x}_0, y_0) \in D\)</span>；<br />（c）<span class="math inline">\(\frac{\partial F(\boldsymbol{x}_0,y_0)}{\partial y} \ne 0\)</span>。<br />那么存在<span class="math inline">\((\boldsymbol{x}_0,y_0)\)</span>的一个邻域<span class="math inline">\(G \timesJ\)</span>，其中<span class="math inline">\(G\)</span>是<spanclass="math inline">\(\boldsymbol{x_0}\)</span>在<spanclass="math inline">\(\mathbb{R}^n\)</span>的一个邻域，<spanclass="math inline">\(J\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>中的一个开区间，使得：<br />（1）对每一个<span class="math inline">\(\boldsymbol{x} \inG\)</span>，方程<br /><span class="math display">\[    F(\boldsymbol{x}, y) = 0\]</span><br />在<span class="math inline">\(J\)</span>中存在唯一的解，记为<spanclass="math inline">\(f(\boldsymbol{x})\)</span>；<br />（2）<span class="math inline">\(y_0 =f(\boldsymbol{x}_0)\)</span>；<br />（3）<span class="math inline">\(f \in C^1(G)\)</span>；<br />（4）当<span class="math inline">\(\boldsymbol{x} \inG\)</span>时，<br /><span class="math display">\[    \frac{\partial f}{\partial x_i} = - \frac{\frac{\partial F}{\partialx_i}(\boldsymbol{x}, y)}{\frac{\partial F}{\partial y}(\boldsymbol{x},y)} \quad (i=1,2,\cdots,n)\]</span><br />其中<span class="math inline">\(y = f(\boldsymbol{x})\)</span>。</p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/04/13/函数导数10/#定理1：隐函数定理">定理1</a>的证明，可知（1）（2）的证明方式一模一样；而在证明（3）（4）时，只需令<spanclass="math inline">\(\boldsymbol{h} = (0, \cdots, h_i, \cdots,0)^T\)</span>，固定<spanclass="math inline">\(x_i\)</span>，其他证明过程一样，即可证得（3）和（4）。</p><p>Q.E.D.</p><hr /><p>设有<span class="math inline">\(m\)</span>个方程组成的方程组<br /><span class="math display">\[    \left\{ \begin{aligned}        &amp; F_1(x_1,x_2,\cdots,x_n, y_1,\cdots, y_m) = 0 \\        &amp; \cdots, \\        &amp; F_m(x_1,x_2,\cdots,x_n, y_1,\cdots, y_m) = 0    \end{aligned} \right.\]</span><br />按照隐函数的想法，是否可以解出<br /><span class="math display">\[    \left\{ \begin{aligned}        &amp; y_1 = f_1(x_1,\cdots,x_n) \\        &amp; \cdots \\        &amp; y_m = f_m(x_1,\cdots,x_n)    \end{aligned} \right.\]</span><br />为了缩短记号，可令<br /><span class="math display">\[    \boldsymbol{F} = \left[ \begin{matrix}         F_1 \\         \vdots \\         F_m    \end{matrix} \right], \quad    \boldsymbol{f} = \left[ \begin{matrix}         f_1 \\         \vdots \\         f_m    \end{matrix} \right]\]</span><br />从而可以把方程改写为<br /><span class="math display">\[    \boldsymbol{F}(\boldsymbol{x}, \boldsymbol{y}) = \boldsymbol{0}\]</span><br />而解出式可改写为<br /><span class="math display">\[    \boldsymbol{y} = \boldsymbol{f}(\boldsymbol{x})\]</span><br />需要再定义几个记号，设<spanclass="math inline">\(\boldsymbol{F}\)</span>定义在开集<spanclass="math inline">\(D \subset \mathbb{R}^{m+n}\)</span>上，在<spanclass="math inline">\(m \times (m+n)\)</span>矩阵<br /><span class="math display">\[    J\boldsymbol{F} = \left[        \begin{matrix}            \frac{\partial F_1}{\partial x_1} &amp; \cdots &amp;\frac{\partial F_1}{x_n} &amp; \frac{\partial F_1}{\partial y_1} &amp;\cdots &amp; \frac{\partial F_1}{\partial y_m} \\            \vdots &amp; &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\            \frac{\partial F_m}{\partial x_1} &amp; \cdots &amp;\frac{\partial F_m}{x_n} &amp; \frac{\partial F_m}{\partial y_1} &amp;\cdots &amp; \frac{\partial F_m}{\partial y_m}        \end{matrix}        \right]\]</span><br />中做分块：<span class="math inline">\(J\boldsymbol{F} =(J_{\boldsymbol{x}}\boldsymbol{F},J_{\boldsymbol{y}}\boldsymbol{F})\)</span>，其中<br /><span class="math display">\[    J_{\boldsymbol{x}}\boldsymbol{F} = \left[        \begin{matrix}            \frac{\partial F_1}{\partial x_1} &amp; \cdots &amp;\frac{\partial F_1}{x_n}  \\            \vdots &amp; &amp; \vdots\\            \frac{\partial F_m}{\partial x_1} &amp; \cdots &amp;\frac{\partial F_m}{x_n}        \end{matrix}        \right], \quad    J_{\boldsymbol{y}}\boldsymbol{F} = \left[        \begin{matrix}            \frac{\partial F_1}{\partial y_1} &amp; \cdots &amp;\frac{\partial F_1}{\partial y_m} \\            \vdots &amp; &amp; \vdots \\            \frac{\partial F_m}{\partial y_1} &amp; \cdots &amp;\frac{\partial F_m}{\partial y_m}        \end{matrix}        \right]\]</span><br /><spanclass="math inline">\(J_{\boldsymbol{x}}\boldsymbol{F}\)</span>是一个<spanclass="math inline">\(m \times n\)</span>矩阵，<spanclass="math inline">\(J_{\boldsymbol{y}}\boldsymbol{F}\)</span>是一个<spanclass="math inline">\(m\)</span>阶方阵。</p><h4 id="定理3隐映射定理">定理3：隐映射定理</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^{n+m}\)</span>，<span class="math inline">\(\boldsymbol{F}: D\to \mathbb{R}^m\)</span>，满足下列条件：<br />（a）<span class="math inline">\(\boldsymbol{F} \inC^1(D)\)</span>；<br />（b）有一点<span class="math inline">\((\boldsymbol{x}_0,\boldsymbol{y}_0) \in D\)</span>，使得<spanclass="math inline">\(\boldsymbol{F}(\boldsymbol{x}_0, \boldsymbol{y}_0)= \boldsymbol{0}\)</span>；<br />（c）行列式<span class="math inline">\(\det J_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x}_0, \boldsymbol{y}_0) \ne 0\)</span><br />那么存在<span class="math inline">\((\boldsymbol{x}_0,\boldsymbol{y}_0)\)</span>的一个邻域<span class="math inline">\(G \timesH\)</span>，使得：<br />（1）对每一个<span class="math inline">\(\boldsymbol{x} \inG\)</span>，方程<spanclass="math inline">\(\boldsymbol{F}(\boldsymbol{x},\boldsymbol{y})=\boldsymbol{0}\)</span>在<spanclass="math inline">\(H\)</span>中有唯一的解，记为<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x})\)</span>；<br />（2）<span class="math inline">\(\boldsymbol{y}_0 =\boldsymbol{f}(\boldsymbol{x}_0)\)</span><br />（3）<span class="math inline">\(\boldsymbol{f} \inC^1(D)\)</span><br />（4）当<span class="math inline">\(\boldsymbol{x} \inG\)</span>时，<br /><span class="math display">\[    J\boldsymbol{f}(\boldsymbol{x}) =-(J_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{y})^{-1})J_{\boldsymbol{x}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{y})\]</span><br />其中<span class="math inline">\(\boldsymbol{y} =\boldsymbol{f}(\boldsymbol{x})\)</span></p></blockquote><p>证：对方程组的个数<spanclass="math inline">\(m\)</span>进行归纳。当<spanclass="math inline">\(m=1\)</span>时，即为该定理<ahref="https://gamersover.github.io/2021/04/13/函数导数10/#定理2">定理2</a>。先设方程组个数为<spanclass="math inline">\(m-1\)</span>时该定理成立，再证明在<spanclass="math inline">\(m\)</span>时依然成立即可。<br />由于<span class="math inline">\(\detJ_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x}_0, \boldsymbol{y}_0) \ne0\)</span>，且<span class="math inline">\(\boldsymbol{F} \inC^1(D)\)</span>，所以总可以找到一个包含<spanclass="math inline">\((\boldsymbol{x}_0,\boldsymbol{y}_0)\)</span>的开集<spanclass="math inline">\(D^\prime\)</span>满足<spanclass="math inline">\((\boldsymbol{x}_0, \boldsymbol{y}_0) \in D^\prime\subset D\)</span>，且在<spanclass="math inline">\(D^\prime\)</span>上的每一个点处都有<spanclass="math inline">\(\det J_{\boldsymbol{y}}\boldsymbol{F} \ne0\)</span>。由条件<span class="math inline">\(（c）\)</span>可知<spanclass="math inline">\(m\)</span>阶方阵<spanclass="math inline">\(J_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x}_0,\boldsymbol{y}_0)\)</span>的元素不全为<spanclass="math inline">\(0\)</span>，不妨设<br /><span class="math display">\[    \frac{\partial F_m}{\partial y_j}(\boldsymbol{x}_0,\boldsymbol{y}_0) \ne 0 \tag{1}\]</span><br />同时令<br /><span class="math display">\[    \boldsymbol{u} = (y_1, \cdots, y_{m-1}), \quad t = y_m, \quad\boldsymbol{y} = (\boldsymbol{u}, t)\]</span><br />同样可以定义<span class="math inline">\(\boldsymbol{y}_0 =(\boldsymbol{u}_0, t_0)\)</span>来规定<spanclass="math inline">\(\boldsymbol{u}_0\)</span>和<spanclass="math inline">\(t_0\)</span>的意义，从而式(1)可写成<br /><span class="math display">\[    \frac{\partial F_m}{\partial t}(\boldsymbol{x}_0, \boldsymbol{u}_0,t_0) \ne 0\]</span><br />又有<br /><span class="math display">\[    F_m (\boldsymbol{x}_0, \boldsymbol{u}_0, t_0) =F_m(\boldsymbol{x}_0, \boldsymbol{y}_0) = 0\]</span><br />由<ahref="https://gamersover.github.io/2021/04/13/函数导数10/#定理2">定理2</a>可知，存在<spanclass="math inline">\((\boldsymbol{x}_0, \boldsymbol{u}_0,t_0)\)</span>的一个邻域<span class="math inline">\((G_n \times G_{m-1})\times J \subset D^\prime\)</span>，使得：<br />（i）对每一点<span class="math inline">\((\boldsymbol{x},\boldsymbol{u}) \in G_{n} \times G_{m=1}\)</span>，方程<br /><span class="math display">\[    F_m(\boldsymbol{x}, \boldsymbol{u}, t) = 0\]</span><br />在<span class="math inline">\(J\)</span>中有唯一的解<spanclass="math inline">\(t = \varphi(\boldsymbol{x},\boldsymbol{u})\)</span>，这里函数<span class="math inline">\(\varphi:G_n \times G_{m-1} \to J\)</span>；<br />（ii）<span class="math inline">\(\varphi(\boldsymbol{x}_0,\boldsymbol{u}_0) = t_0\)</span>；<br />（iii）<span class="math inline">\(\varphi \in C^1(G_{n} \timesG_{m-1})\)</span>；<br />这时将<span class="math inline">\(t = \varphi(\boldsymbol{x},\boldsymbol{u})\)</span>代入到原始方程中，即将<spanclass="math inline">\(y_m\)</span>用<spanclass="math inline">\(x_1,\cdots,x_n,y_1,\cdots,y_{m-1}\)</span>代入，<br /><span class="math display">\[\Phi_i(\boldsymbol{x}, \boldsymbol{u}) = F_i(\boldsymbol{x},\boldsymbol{u}, \varphi(\boldsymbol{x}, \boldsymbol{u})) = 0 \quad(i=1,2,\cdots,m-1) \tag{2}\]</span><br />考虑映射<br /><span class="math display">\[    \boldsymbol{\Phi} = \left[\begin{matrix}            \Phi_1 \\            \vdots \\            \Phi_{m-1}        \end{matrix}\right]: G_n \times G_{m-1} \to \mathbb{R}^{m-1}\]</span><br />若能证明<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>满足定理的三个条件，便可使用归纳假设了。显然<spanclass="math inline">\(\boldsymbol{\Phi} \in C^1\)</span>，并且<br /><span class="math display">\[    \phi_i(\boldsymbol{x}_0, \boldsymbol{u}_0) = F_i(\boldsymbol{x}_0,\boldsymbol{u}_0, \varphi(\boldsymbol{x}_0, \boldsymbol{u}_0)) = 0 \quad(i=1,2\cdots,m-1)\]</span><br />所以<span class="math inline">\(\boldsymbol{\Phi}(\boldsymbol{x}_0,\boldsymbol{y}_0)=\boldsymbol{0}\)</span>。对式(2)两边同时关于<spanclass="math inline">\(u_j\)</span>（即<spanclass="math inline">\(y_j\)</span>）<spanclass="math inline">\((j=1,2,\cdots,m-1)\)</span>求导，得<br /><span class="math display">\[    \frac{\partial \Phi_i}{\partial u_j} = \frac{\partial F_i}{\partialy_j} + \frac{\partial F_i}{\partial y_m} \frac{\partial\varphi}{\partial u_j} \quad (i,j=1,2,\cdots,m-1)\]</span><br />又由（i）可知<br /><span class="math display">\[    F_m(\boldsymbol{x}, \boldsymbol{u}, \varphi(\boldsymbol{x},\boldsymbol{u})) = 0\]</span><br />对上式也关于<span class="math inline">\(u_j\)</span>（即<spanclass="math inline">\(y_j\)</span>）<spanclass="math inline">\((j=1,2,\cdots,m-1)\)</span>求导得<br /><span class="math display">\[    \frac{\partial F_m}{\partial y_j} + \frac{\partial F_m}{\partialy_m} \frac{\partial \varphi}{\partial u_j} = 0 \quad (j=1,2,\cdots,m-1)\]</span><br />从而由<br /><span class="math display">\[    \begin{aligned}        \left|            \begin{matrix}                \frac{\partial F_1}{\partial y_1} &amp; \cdots &amp;\frac{\partial F_1}{\partial y_m} \\                \vdots &amp; &amp; \vdots \\                \frac{\partial F_m}{\partial y_1} &amp; \cdots &amp;\frac{\partial F_m}{\partial y_m}            \end{matrix}        \right|        &amp; =        \left|            \begin{matrix}                \frac{\partial F_1}{\partial y_1} + \frac{\partialF_1}{\partial y_m}\frac{\partial \varphi}{\partial u_1} &amp;\frac{\partial F_1}{\partial y_2} + \frac{\partial F_1}{\partialy_m}\frac{\partial \varphi}{\partial u_2} &amp; \cdots &amp;\frac{\partial F_1}{\partial y_m} \\                \vdots &amp; \vdots &amp; &amp; \vdots \\                \frac{\partial F_m}{\partial y_1} + \frac{\partialF_m}{\partial y_m}\frac{\partial \varphi}{\partial u_1} &amp;\frac{\partial F_m}{\partial y_2} + \frac{\partial F_m}{\partialy_m}\frac{\partial \varphi}{\partial u_2} &amp; \cdots &amp;\frac{\partial F_m}{\partial y_m}            \end{matrix}        \right| \\        &amp; =        \left|            \begin{matrix}                \frac{\partial \Phi_1}{\partial u_1} &amp; \cdots &amp;\frac{\partial \Phi_1}{\partial u_{m-1}} &amp; \frac{\partialF_1}{\partial y_m} \\                \vdots &amp; &amp; \vdots &amp; \vdots \\                \frac{\partial \Phi_{m-1}}{\partial u_1} &amp; \cdots&amp; \frac{\partial \Phi_{m-1}}{\partial u_{m-1}} &amp; \frac{\partialF_{m-1}}{\partial y_m} \\                0 &amp; \cdots &amp; 0 &amp; \frac{\partialF_m}{\partial y_m}            \end{matrix}        \right| \\        &amp; = \frac{\partial F_m}{\partial y_m}(\boldsymbol{x}_0,\boldsymbol{u}_0, t_0) \det(J_{\boldsymbol{u}}\boldsymbol{\Phi}(\boldsymbol{x}_0, \boldsymbol{u}_0))    \end{aligned} \tag{3}\]</span><br />根据条件（c），式子(3)的左边不等于0，因为有<br /><span class="math display">\[     \det(J_{\boldsymbol{u}} \boldsymbol{\Phi}(\boldsymbol{x}_0,\boldsymbol{u}_0)) \ne 0\]</span><br />从而证明了<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>满足本定理中的三个条件，从而对<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>使用归纳假设，可知定理中的结论（1），（2）和（3）对<spanclass="math inline">\(\boldsymbol{\Phi}\)</span>都成立。即存在点<spanclass="math inline">\((\boldsymbol{x}_0,\boldsymbol{y}_0)\)</span>的邻域<span class="math inline">\(G \timesH_{m-1} \subset G_n \times G_{m-1}\)</span>使得：<br />（aa）当<span class="math inline">\(\boldsymbol{x} \inG\)</span>时，方程<spanclass="math inline">\(\boldsymbol{\phi}(\boldsymbol{x}, \boldsymbol{u})= \boldsymbol{0}\)</span>在<spanclass="math inline">\(H_{m-1}\)</span>中有唯一解<spanclass="math inline">\(\boldsymbol{u} =\boldsymbol{g}(\boldsymbol{x})\)</span>，其中映射<spanclass="math inline">\(\boldsymbol{g}: G \to H_{m-1}\)</span>；<br />（ab）<span class="math inline">\(\boldsymbol{\boldsymbol{x}_0} =\boldsymbol{u}_0\)</span>；<br />（ac）<span class="math inline">\(\boldsymbol{g} \inC^1(G)\)</span><br />令<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{x}) = (\boldsymbol{g}(\boldsymbol{x}),\varphi(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}))) \quad(\boldsymbol{x} \in G)\]</span><br /><span class="math display">\[    H = H_{m-1} \times J\]</span><br />于是<span class="math inline">\(\boldsymbol{f}: G \toH\)</span>。我们要证明<spanclass="math inline">\(\boldsymbol{f}\)</span>满足条件（1），（2）和（3）。当<spanclass="math inline">\(\boldsymbol{x} \in G\)</span>，<spanclass="math inline">\((\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}))\in G \times H_{m-1} \subset G_n \timesG_{m-1}\)</span>，从而由（aa）可得<br /><span class="math display">\[    F_i(\boldsymbol{x}, \boldsymbol{f}(\boldsymbol{x})) =F_i(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}),\varphi(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}))) =\Phi_i(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x})) = 0 \quad(i=1,2,\cdots,m-1)\]</span><br />另外由（i）可知<br /><span class="math display">\[    F_m(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x})) =F_m(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}),\varphi(\boldsymbol{x}, \boldsymbol{g}(\boldsymbol{x}))) =  0\]</span><br />从而<spanclass="math inline">\(\boldsymbol{f}\)</span>满足（1）。由（ab）和（ii）可知<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{x}_0) =(\boldsymbol{g}(\boldsymbol{x}_0), \varphi(\boldsymbol{x}_0,\boldsymbol{g}(\boldsymbol{x}_0))) = (\boldsymbol{u}_0,\varphi(\boldsymbol{x}_0, \boldsymbol{u}_0)) = (\boldsymbol{u}_0, t_0) =\boldsymbol{y}_0\]</span><br />所以<spanclass="math inline">\(\boldsymbol{f}\)</span>满足（2）。再由（ac）和（iii）即知<spanclass="math inline">\(\boldsymbol{f}\)</span>满足（3）。再由恒等式<br /><span class="math display">\[    \boldsymbol{F}(\boldsymbol{x}, \boldsymbol{f}(\boldsymbol{x})) =\boldsymbol{0}\]</span><br />对上式复合求导，得<br /><span class="math display">\[    J_{\boldsymbol{x}} \boldsymbol{F}(\boldsymbol{x},\boldsymbol{f}(\boldsymbol{x})) + J_y \boldsymbol{F}(\boldsymbol{x},\boldsymbol{f}(\boldsymbol{x})) J\boldsymbol{f}(\boldsymbol{x}) =\boldsymbol{0}\]</span><br />由于在<span class="math inline">\(D^\prime\)</span>上<spanclass="math inline">\(\detJ_{\boldsymbol{y}}\boldsymbol{F}\)</span>处处不为0，所以<spanclass="math inline">\(J_{\boldsymbol{y}}\boldsymbol{F}\)</span>是可逆方阵，在上式中取逆方阵，得出<br /><span class="math display">\[    J\boldsymbol{f}(\boldsymbol{x}) =-(J_{\boldsymbol{y}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{f}(\boldsymbol{x})))^{-1}J_{\boldsymbol{x}}\boldsymbol{F}(\boldsymbol{x},\boldsymbol{f}(\boldsymbol{x}))\]</span><br />即表明<span class="math inline">\(\boldsymbol{f}\)</span>满足（4）。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分 </tag>
            
            <tag> 隐函数 </tag>
            
            <tag> 隐映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数九：映射微分和复合求导</title>
      <link href="/2021/04/11/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B09/"/>
      <url>/2021/04/11/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B09/</url>
      
        <content type="html"><![CDATA[<p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^m\)</span>。记<spanclass="math inline">\(\boldsymbol{f}\)</span>的分量依次为<spanclass="math inline">\(f_1,f_2,\cdots,f_m\)</span>，可以把<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x})\)</span>写成<br /><span class="math display">\[    \boldsymbol{f(x)} = \left(        \begin{matrix}            f_1(\boldsymbol{x}) \\            f_2(\boldsymbol{x}) \\            \vdots \\            f_m(\boldsymbol{x})        \end{matrix}    \right) \quad (\boldsymbol{x} \in D)\]</span><br />设点<span class="math inline">\(\boldsymbol{x}_0 \in D, \boldsymbol{h}\in \mathbb{R}^n\)</span>。由于<spanclass="math inline">\(\boldsymbol{x}_0\)</span>是<spanclass="math inline">\(D\)</span>的内点，所以总可以找到充分小的<spanclass="math inline">\(\Vert \boldsymbol{h} \Vert\)</span>使得<spanclass="math inline">\(\boldsymbol{x}_0 + \boldsymbol{h} \inD\)</span>。</p><span id="more"></span><h4 id="定义1">定义1</h4><blockquote><p>如果映射<span class="math inline">\(\boldsymbol{f}\)</span>满足<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{x}_0 + \boldsymbol{h}) -\boldsymbol{f}(\boldsymbol{x}_0) = \boldsymbol{Ah} +\boldsymbol{r}(\boldsymbol{h})\]</span><br />式中<span class="math inline">\(\boldsymbol{A}\)</span>是一个<spanclass="math inline">\(m \times n\)</span>矩阵，它的元素不依赖于<spanclass="math inline">\(\boldsymbol{h}\)</span>，且<br /><span class="math display">\[    \lim \limits_{\boldsymbol{h} \to \boldsymbol{0}} \frac{\Vert\boldsymbol{r}(\boldsymbol{h}) \Vert}{\Vert \boldsymbol{h} \Vert} = 0\]</span><br />则称映射<span class="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，并称<spanclass="math inline">\(\boldsymbol{Ah}\)</span>是<spanclass="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处的微分，记作<br /><span class="math display">\[    \mathrm{d}\boldsymbol{f}(\boldsymbol{x}_0) = \boldsymbol{Ah}\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>若映射<span class="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，则有<br /><span class="math display">\[    \mathrm{d}\boldsymbol{f}(\boldsymbol{x}_0) =\boldsymbol{Jf}(\boldsymbol{x}_0)\boldsymbol{h}\]</span><br />其中<br /><span class="math display">\[    \boldsymbol{Jf}(\boldsymbol{x}_0) = \left[        \begin{matrix}            \frac{\partial f_1(\boldsymbol{x}_0)}{\partial x_1}  &amp;\cdots &amp; \frac{\partial f_1(\boldsymbol{x}_0)}{\partial x_n} \\            \vdots &amp; &amp; \vdots \\            \frac{\partial f_m(\boldsymbol{x}_0)}{\partial x_1}  &amp;\cdots &amp; \frac{\partial f_m(\boldsymbol{x}_0)}{\partial x_n}        \end{matrix}    \right]\]</span><br />称之为映射<span class="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处的Jacobi矩阵，也称为导数。</p></blockquote><p>证：有定义可知，<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{x}_0 + \boldsymbol{h}) -\boldsymbol{f}(\boldsymbol{x}_0) = \boldsymbol{Ah} +\boldsymbol{r}(\boldsymbol{h})\]</span><br />设<br /><span class="math display">\[    \boldsymbol{A} = \left[\begin{matrix}        a_{11} &amp; \cdots &amp; a_{1n} \\        \vdots &amp; &amp; \vdots \\        a_{m1} &amp; \cdots &amp; a_{mn}    \end{matrix}\right]\]</span><br />将其代入上式中得<br /><span class="math display">\[    f_i(\boldsymbol{x}_0 + \boldsymbol{h}) - f_i(\boldsymbol{x}_0) =\sum_{j=1}^n a_{ij} h_j + r_i(\boldsymbol{h})\]</span><br />其中<span class="math inline">\(r_i(\boldsymbol{h})\)</span>表示<spanclass="math inline">\(\boldsymbol{r}(\boldsymbol{h})\)</span>的第<spanclass="math inline">\(i\)</span>个分量，由<spanclass="math inline">\(\boldsymbol{r}(\boldsymbol{h})\)</span>的性质可知<br /><span class="math display">\[    r_i(\boldsymbol{h}) = o(\Vert \boldsymbol{h} \Vert) \quad(\boldsymbol{h} \to 0, i=1,2,\cdots,m)\]</span><br />从而继续由<ahref="https://gamersover.github.io/2021/03/31/函数导数8/#定理1">函数导数八定理1</a>可知<br /><span class="math display">\[    a_{ij} = \frac{\partial f_i(\boldsymbol{x}_0)}{\partial x_j}(i=1,2,\cdots,m;j=1,2,\cdots,n)\]</span><br />从而得证。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>若映射<span class="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的某一邻域内存在Jacobi矩阵<spanclass="math inline">\(\boldsymbol{Jf}\)</span>，且<spanclass="math inline">\(\boldsymbol{Jf}\)</span>的各元素在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处都连续，则映射<spanclass="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微。</p></blockquote><p>证：由<ahref="https://gamersover.github.io/2021/04/11/函数导数9/#定理1">定理1</a>与<ahref="https://gamersover.github.io/2021/03/31/函数导数8/#定理2">函数导数八的定理2</a>易证。</p><p>Q.E.D.</p><h4 id="定义2">定义2</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^m\)</span>。如果<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>上的每一点处都连续，则记<spanclass="math inline">\(\boldsymbol{f} \in C(D)\)</span>；如果<spanclass="math inline">\(\boldsymbol{Jf}\)</span>在<spanclass="math inline">\(\boldsymbol{D}\)</span>上的每一点处都连续，则记<spanclass="math inline">\(\boldsymbol{f} \in C^1(D)\)</span>。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(\boldsymbol{g}: D \to\mathbb{R}^m\)</span>，<spanclass="math inline">\(\boldsymbol{g}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0 \in D\)</span>处可微，又设<spanclass="math inline">\(\boldsymbol{f}\)</span>把包含<spanclass="math inline">\(\boldsymbol{g}(D)\)</span>的一个开集映射至<spanclass="math inline">\(\mathbb{R}^l\)</span>，并且<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(\boldsymbol{g}(\boldsymbol{x}_0)\)</span>处可微，那么复合映射<spanclass="math inline">\(\boldsymbol{f} \circ\boldsymbol{g}\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，并且<br /><span class="math display">\[    \boldsymbol{J}(\boldsymbol{f}\circ \boldsymbol{g})(\boldsymbol{x}_0)= \boldsymbol{Jf}(\boldsymbol{g}(\boldsymbol{x}_0))\boldsymbol{Jg}(\boldsymbol{x}_0)\]</span></p></blockquote><p>证：令<span class="math inline">\(\boldsymbol{y}_0 =\boldsymbol{g}(\boldsymbol{x}_0)\)</span>，<spanclass="math inline">\(\boldsymbol{A} =\boldsymbol{Jf}(\boldsymbol{y}_0)，\boldsymbol{B} =\boldsymbol{Jg}(\boldsymbol{x}_0)\)</span>，易知<spanclass="math inline">\(\boldsymbol{A}\)</span>是<spanclass="math inline">\(l\times m\)</span>矩阵，<spanclass="math inline">\(\boldsymbol{B}\)</span>是<spanclass="math inline">\(m \times n\)</span>矩阵，从而若能证明<br /><span class="math display">\[    \lim \limits_{\Vert \boldsymbol{h} \Vert \to 0} \frac{\Vert(\boldsymbol{f} \circ \boldsymbol{g})(\boldsymbol{x}_0 + \boldsymbol{h})- (\boldsymbol{f} \circ \boldsymbol{g})(\boldsymbol{x}_0) -\boldsymbol{ABh} \Vert}{\Vert \boldsymbol{h} \Vert} = 0 \tag{1}\]</span><br />则由<ahref="https://gamersover.github.io/2021/04/11/函数导数9/#定义1">定义1</a>可知，<spanclass="math inline">\(\boldsymbol{J}(\boldsymbol{f}\circ\boldsymbol{g})(\boldsymbol{x}_0) = \boldsymbol{AB}\)</span>。<br />由于<spanclass="math inline">\(\boldsymbol{g},\boldsymbol{f}\)</span>分别在<spanclass="math inline">\(\boldsymbol{x}_0,\boldsymbol{y}_0\)</span>处可微，从而有<br /><span class="math display">\[    \begin{aligned}    \boldsymbol{g}(\boldsymbol{x}_0 + \boldsymbol{h}) -\boldsymbol{g}(\boldsymbol{x}_0) = \boldsymbol{Bh} +\boldsymbol{u}(\boldsymbol{h}) \\    \boldsymbol{f}(\boldsymbol{y}_0 + \boldsymbol{k}) -\boldsymbol{f}(\boldsymbol{y}_0) = \boldsymbol{Ak} +\boldsymbol{v}(\boldsymbol{k})    \end{aligned} \tag{2}\]</span><br />其中<spanclass="math inline">\(\boldsymbol{h}，\boldsymbol{k}\)</span>分别为<spanclass="math inline">\(n \times 1\)</span>矩阵和<spanclass="math inline">\(m \times 1\)</span>矩阵，且<br /><span class="math display">\[    \begin{aligned}        \frac{\Vert \boldsymbol{u}(\boldsymbol{h}) \Vert}{\Vert\boldsymbol{h} \Vert} \to 0 \quad (\Vert \boldsymbol{h} \Vert \to 0) \\        \frac{\Vert \boldsymbol{v}(\boldsymbol{k}) \Vert}{\Vert\boldsymbol{k} \Vert} \to 0 \quad (\Vert \boldsymbol{k} \Vert \to 0)    \end{aligned}\]</span><br />记<br /><span class="math display">\[    \frac{\Vert \boldsymbol{u}(\boldsymbol{h}) \Vert}{\Vert\boldsymbol{h} \Vert} = \varepsilon(\boldsymbol{h})， \quad \frac{\Vert\boldsymbol{v}(\boldsymbol{h}) \Vert}{\Vert \boldsymbol{h} \Vert} =\eta(\boldsymbol{h})\]</span><br />则<br /><span class="math display">\[    \Vert \boldsymbol{u}(\boldsymbol{h}) \Vert =\varepsilon(\boldsymbol{h}) \Vert \boldsymbol{h} \Vert， \quad \Vert\boldsymbol{v}(\boldsymbol{k}) \Vert = \eta(\boldsymbol{k}) \Vert\boldsymbol{k} \Vert\]</span><br />且<br /><span class="math display">\[    \lim \limits_{\Vert \boldsymbol{h} \Vert \to 0}\varepsilon(\boldsymbol{h}) = 0， \quad \lim \limits_{\Vert\boldsymbol{k} \Vert \to 0} \eta(\boldsymbol{k}) = 0 \tag{3}\]</span><br />对给定的<span class="math inline">\(\boldsymbol{h}\)</span>，令<spanclass="math inline">\(\boldsymbol{k} = \boldsymbol{g}(\boldsymbol{x}_0 +\boldsymbol{h}) -\boldsymbol{g}(\boldsymbol{x}_0)\)</span>，由式(2)可得<br /><span class="math display">\[    \Vert \boldsymbol{k} \Vert \le \Vert \boldsymbol{Bh} \Vert + \Vert\boldsymbol{u}(\boldsymbol{h})\Vert \le (\Vert \boldsymbol{B} \Vert +\varepsilon(\boldsymbol{h})) \Vert \boldsymbol{h} \Vert\]</span><br />从而有<br /><span class="math display">\[    \begin{aligned}        &amp; \Vert \boldsymbol{f} \circ \boldsymbol{g}(\boldsymbol{x}_0 + \boldsymbol{h}) - \boldsymbol{f} \circ\boldsymbol{g} (\boldsymbol{x}_0) - \boldsymbol{ABh} \Vert \\        &amp; = \Vert \boldsymbol{f}(\boldsymbol{g} (\boldsymbol{x}_0 +\boldsymbol{h})) - \boldsymbol{f}(\boldsymbol{g} (\boldsymbol{x}_0)) -\boldsymbol{ABh} \Vert \\        &amp; = \Vert \boldsymbol{f}(\boldsymbol{y}_0 + \boldsymbol{k})- \boldsymbol{f}(\boldsymbol{y}_0) - \boldsymbol{ABh} \Vert \\        &amp; = \Vert \boldsymbol{Ak} + \boldsymbol{v}(\boldsymbol{k}) -\boldsymbol{ABh} \Vert \\        &amp; = \Vert \boldsymbol{A}(\boldsymbol{k} - \boldsymbol{Bh}) +\boldsymbol{v}{\boldsymbol{k}} \Vert \\        &amp; \le \Vert \boldsymbol{A} \Vert u(\boldsymbol{h}) +\eta(\boldsymbol{k})\Vert \boldsymbol{k} \Vert \\        &amp; \le \Vert \boldsymbol{A} \Vert \varepsilon(\boldsymbol{h})\Vert \boldsymbol{h} \Vert + \eta(\boldsymbol{k})(\Vert \boldsymbol{B}\Vert + \varepsilon(\boldsymbol{h})) \Vert \boldsymbol{h} \Vert    \end{aligned}\]</span><br />所以<br /><span class="math display">\[    \frac{\Vert (\boldsymbol{f} \circ \boldsymbol{g})(\boldsymbol{x}_0 +\boldsymbol{h}) - (\boldsymbol{f} \circ\boldsymbol{g})(\boldsymbol{x}_0) - \boldsymbol{ABh} \Vert}{\Vert\boldsymbol{h} \Vert} \le \Vert \boldsymbol{A} \Vert\varepsilon(\boldsymbol{h}) + \eta(\boldsymbol{k})(\Vert \boldsymbol{B}\Vert + \varepsilon(\boldsymbol{h}))\]</span><br />再由式(3)可知式(1)成立。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分 </tag>
            
            <tag> 映射 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解22：括号生成</title>
      <link href="/2021/04/05/leetcode%E9%A2%98%E8%A7%A322/"/>
      <url>/2021/04/05/leetcode%E9%A2%98%E8%A7%A322/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/generate-parentheses/">力扣第22题</a></p><p>数字<code>n</code>代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且有效的括号组合。<br /><span id="more"></span> </p><p>示例 1：</p><blockquote><p>输入：n = 3<br />输出：["((()))","(()())","(())()","()(())","()()()"]</p></blockquote><p>示例 2：</p><blockquote><p>输入：n = 1<br />输出：["()"]</p></blockquote><p>提示：</p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="分析">分析</h2><p>要生成有效的括号，第一个字符必然是左括号<code>(</code>，那么第二个有可能是<code>(</code>或者<code>)</code>，以<code>n=3</code>为例，生成有效括号的过程应该如下：<br /><img src="https://raw.githubusercontent.com/gamersover/hexo_blog_assets/main/leetcode/No1.jpg" width="25%"></p><p>可以看出是一颗二叉树，二叉树的每条路径对应着一个有效括号组合，所以关键在于如何生成这颗树。思路也很简单，第一层已经确定只能是<code>(</code>，由于<code>n=3</code>表示最多可以有<code>3</code>个<code>(</code>，所以第二层可能是<code>(</code>，也可能是<code>)</code>，那第三层如何确定呢？</p><p>假如第二层选择的是<code>(</code>，由于左括号的个数为2，小于<code>n</code>，所以第三层也可能是<code>(</code>或者<code>)</code>；如果第二层选择的是<code>)</code>，一样的分析。</p><p>第三层如果选择的是<code>(</code>，这是左括号的个数已经等于<code>n</code>，所以第四层只能添加<code>)</code>了。</p><p>综上分析可知，假设当前层已有的左括号个数为<code>left</code>，已有右括号个数为<code>right</code>，若<code>left&lt;n</code>，则当前层可以为<code>(</code>，同时若<code>right&lt;left</code>，那么当前层也可以是<code>)</code>；否则结束，所有括号添加完毕。</p><p>树生成后，可以使用深度优先遍历所有的路径得到结果，这里可以采用递归的写法，注意一点就是遍历到叶子结点后，需要回溯到初始状态，具体可以看算法说明。</p><h2 id="算法">算法</h2><ol type="1"><li>初始化<code>n</code>,<code>left=right=0</code>，以及路径<code>s=""</code></li><li>递归函数<code>f(n, left, rihgt, s)</code></li><li>进入递归主体，如果<code>len(s)==2*n</code>，表明<code>s</code>已经包含了所有括号，添加到结果列表中，并退出函数</li><li>如果<code>left &lt; n</code>，这时添加<code>(</code>，进入函数<code>f(n, left+1, right, s+"(")</code>，这里<code>s+"("</code>写在函数形参内，刚好避免回溯时<code>s</code>不受影响，<code>s</code>的变化至于该路径的前面所有层有关。</li><li>如果<code>right &lt; n</code>，这时添加<code>)</code>，进入函数<code>f(n, left, right, s+")")</code></li></ol><p>具体算法执行步骤可以这么理解：<br />首先一直添加<code>(</code>直到无法添加为止，然后添加<code>)</code>直到无法添加为止，即一直遍历树的左节点，然后开始回溯，这时<code>s</code>为<code>((()))</code>，根据算法会回溯到<code>s="(("</code>即第二层的左节点也是步骤4的结尾，之后进入步骤5。依次下去。</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generateParenthesis</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.n = n</span><br><span class="line">        self.result = []</span><br><span class="line">        self.generate(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, left, right, s=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) == self.n * <span class="number">2</span>:</span><br><span class="line">            self.result.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt; self.n:</span><br><span class="line">            self.generate(left+<span class="number">1</span>, right, s+<span class="string">&quot;(&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> right &lt; left:</span><br><span class="line">            self.generate(left, right+<span class="number">1</span>, s+<span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">vector&lt;string&gt; arr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">generate</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>, n);</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">generate</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, string s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            arr.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; n)&#123;</span><br><span class="line">            <span class="built_in">generate</span>(left+<span class="number">1</span>, right, s+<span class="string">&quot;(&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; left)&#123;</span><br><span class="line">            <span class="built_in">generate</span>(left, right+<span class="number">1</span>, s+<span class="string">&quot;)&quot;</span>, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        generate(n, <span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> left, <span class="type">int</span> right, String s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">2</span>*n) &#123;</span><br><span class="line">            res.add(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; n)&#123;</span><br><span class="line">            generate(n, left+<span class="number">1</span>, right, s+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; left)&#123;</span><br><span class="line">            generate(n, left, right+<span class="number">1</span>, s+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数八：多变量函数的微分</title>
      <link href="/2021/03/31/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B08/"/>
      <url>/2021/03/31/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B08/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(f: D \to\mathbb{R}\)</span>，<spanclass="math inline">\(\boldsymbol{u}\)</span>是一个方向，<spanclass="math inline">\(x_0 \in D\)</span>，如果极限<br /><span class="math display">\[    \lim \limits_{t \to 0} \frac{f(\boldsymbol{x}_0 + t\boldsymbol{u}) -f(\boldsymbol{x})}{t}\]</span><br />存在且有限，则称这个极限为函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处沿方向<spanclass="math inline">\(u\)</span>的方向导数，记为<spanclass="math inline">\(\frac{\partial f}{\partial\boldsymbol{u}}(\boldsymbol{x}_0)\)</span>。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>记单位坐标向量<br /><span class="math display">\[    \begin{aligned}        &amp; \boldsymbol{e}_1 = (1, 0, 0, \cdots, 0) \\        &amp; \boldsymbol{e}_2 = (0, 1, 0, \cdots, 0) \\        &amp; \cdots \\        &amp; \boldsymbol{e}_n = (0, 0, 0, \cdots, 1)    \end{aligned}\]</span><br />称函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处沿方向<spanclass="math inline">\(\boldsymbol{e}_i\)</span>的方向导数为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处的第<spanclass="math inline">\(i\)</span>个一阶偏导数，记作<br /><span class="math display">\[    \frac{\partial f}{\partial x_i} (\boldsymbol{x}_0) 或\mathrm{D}_if(\boldsymbol{x}_0)\]</span><br />并称<span class="math inline">\(\mathrm{D}_i = \frac{\partial}{\partialx_i}\)</span>为第<span class="math inline">\(i\)</span>个偏微分算子<spanclass="math inline">\((i=1,2,\cdots,n)\)</span>；令<br /><span class="math display">\[    \boldsymbol{J}f(\boldsymbol{x}) =(\mathrm{D_1}f(\boldsymbol{x}),\mathrm{D_2}f(\boldsymbol{x}),\cdots,\mathrm{D_n}f(\boldsymbol{x}))\]</span><br />并称它为函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x}\)</span>处的Jacobi矩阵<spanclass="math inline">\(1 \times n\)</span>矩阵。Jacobi矩阵也常记作<spanclass="math inline">\(\mathrm{grad} f\)</span>或<spanclass="math inline">\(\nabla f\)</span>，也称为数量函数<spanclass="math inline">\(f\)</span>的梯度。</p></blockquote><hr /><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(f: D \to\mathbb{R}\)</span>，取定一点<spanclass="math inline">\(\boldsymbol{x}_0 \in D\)</span>，<spanclass="math inline">\(\boldsymbol{h} \in\mathbb{R}^n\)</span>。由于<spanclass="math inline">\(\boldsymbol{x}_0\)</span>是<spanclass="math inline">\(D\)</span>的一个内点，故当<spanclass="math inline">\(\Vert \boldsymbol{h}\Vert\)</span>充分小时，可以使<spanclass="math inline">\(\boldsymbol{x}_0+\boldsymbol{h}\)</span>完全在<spanclass="math inline">\(D\)</span>之内。</p><h4 id="定义3">定义3</h4><blockquote><p>设<spanclass="math inline">\(\boldsymbol{h}=(h_1,h_2,\cdots,h_n)\)</span>，如果成立<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) =\sum_{i=1}^n \lambda_i h_i + o(\Vert \boldsymbol{h} \Vert) \quad (\Vert\boldsymbol{h} \Vert \to 0)\]</span><br />其中<spanclass="math inline">\(\lambda_i(i=1,2,\cdots,n)\)</span>是不依赖于<spanclass="math inline">\(\boldsymbol{h}\)</span>的常数，那么称函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，并称<spanclass="math inline">\(\sum \limits_{i=1}^n \lambda_i h_i\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处的微分，记作<br /><span class="math display">\[    \mathrm{d}f(\boldsymbol{x}_0) (\boldsymbol{h}) = \sum_{i=1}^n\lambda_i h_i\]</span><br />如果<span class="math inline">\(f\)</span>在开集<spanclass="math inline">\(D\)</span>上的每一点处都可微，则称<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(D\)</span>上的可微函数。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>为了方便，将<spanclass="math inline">\(\boldsymbol{x}_0,\boldsymbol{h}\)</span>表示列向量形式，设函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0 =(x_1,x_2,\cdots,x_n)^T\)</span>处可微，则<br /><span class="math display">\[    \mathrm{d}f(\boldsymbol{x}_0) (\boldsymbol{h}) =\boldsymbol{J}f(\boldsymbol{x_0}) \boldsymbol{h}\]</span></p></blockquote><p>证：<ahref="https://gamersover.github.io/2021/03/31/函数导数8/#定义3">定义3</a>中令<spanclass="math inline">\(\boldsymbol{h} = (h_1,0,\cdots,0)^T\)</span>，此时<br /><span class="math display">\[    f(x_1+h_1, x_2, \cdots, x_n) - f(x_1,x_2,\cdots,x_n) = \lambda_1 h_1+ o(|h_1|)\]</span><br />从而<br /><span class="math display">\[    \frac{f(x_1+h_1, x_2, \cdots, x_n) - f(x_1,x_2,\cdots,x_n)}{h_1} =\lambda_1 + o(1)\]</span><br />令<span class="math inline">\(h_1 \to 0\)</span>，得<br /><span class="math display">\[    \lambda_1 = \mathrm{D}_1f(\boldsymbol{x}_0)\]</span><br />一般地，有<br /><span class="math display">\[    \lambda_i = \mathrm{D}_if(\boldsymbol{x}_0) \quad (i=1,2,\cdots,n)\]</span><br />所以有<br /><span class="math display">\[    \mathrm{d}f(\boldsymbol{x}_0) (\boldsymbol{h}) =\boldsymbol{J}f(\boldsymbol{x_0}) \boldsymbol{h}\]</span><br />Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，则<spanclass="math inline">\(f\)</span>必在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处连续。</p></blockquote><p>证：由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，当<spanclass="math inline">\(\boldsymbol{h} \to\boldsymbol{0}\)</span>时，有<span class="math inline">\(h_i \to 0(i=1,2,\cdots,n)\)</span>，此时<spanclass="math inline">\(\mathrm{d}f(\boldsymbol{x}_0) (\boldsymbol{h}) =\sum \limits_{i=1}^n \lambda_i h_i \to 0\)</span>，从而<spanclass="math inline">\(f(\boldsymbol{x_0} + \boldsymbol{h}) -f(\boldsymbol{x}_0) \to 0\)</span>，所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处连续。<br />Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微当且仅当等式<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) =\boldsymbol{J}f(\boldsymbol{x}_0) \boldsymbol{h} + \sum_{i=1}^n\beta_i(\boldsymbol{h}) h_i\]</span><br />成立。其中，当<span class="math inline">\(\Vert \boldsymbol{h} \Vert \to0\)</span>时，<br /><span class="math display">\[    \beta_i(\boldsymbol{h}) \to 0 \quad (i=1,2,\cdots,n)\]</span></p></blockquote><p>证：充分性。当<span class="math inline">\(\boldsymbol{h} \to\boldsymbol{0}\)</span>时，有<br /><span class="math display">\[    \frac{1}{\Vert \boldsymbol{h} \Vert} |\sum_{i=1}^n\beta_i(\boldsymbol{h})h_i| = \left| \sum_{i=1}^n\beta_i(\boldsymbol{h}) \frac{h_i}{\boldsymbol{\Vert h \Vert}} \right|\le \left| \sum_{i=1}^n \beta_i(\boldsymbol{h}) \right| \to 0\]</span><br />即<br /><span class="math display">\[    \sum_{i=1}^n \beta_i(\boldsymbol{h}) h_i = o(\Vert \boldsymbol{h}\Vert)\]</span><br />由<ahref="https://gamersover.github.io/2021/03/31/函数导数8/#定义3">定义3</a>可知，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微。<br />必要性。记<br /><span class="math display">\[    r(\boldsymbol{h}) = f(\boldsymbol{x}_0 + \boldsymbol{h}) -f(\boldsymbol{x}_0) - \boldsymbol{J}f(\boldsymbol{x_0}) \boldsymbol{h}\]</span><br />可知当<span class="math inline">\(\Vert \boldsymbol{h} \Vert \to0\)</span>时，有<span class="math inline">\(r(\boldsymbol{h}) = o(\Vert\boldsymbol{h} \Vert)\)</span>，由于<br /><span class="math display">\[    r(\boldsymbol{h}) = \left(\sum_{i=1}^n \frac{h_i}{\Vert\boldsymbol{h} \Vert} h_i \right)\frac{r(\boldsymbol{h})}{\Vert\boldsymbol{h} \Vert}\]</span><br />故令<br /><span class="math display">\[    \beta_i(\boldsymbol{h}) = \frac{r(\boldsymbol{h})}{\Vert\boldsymbol{h} \Vert} \frac{h_i}{\Vert \boldsymbol{h} \Vert}\]</span><br />由于<br /><span class="math display">\[    \frac{h_i}{\Vert \boldsymbol{h} \Vert} \le 1 \quad (i=1,2,\cdots,n)\]</span><br />从而可知<span class="math inline">\(\beta_i(\boldsymbol{h}) \to0\)</span>，且<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) =\boldsymbol{J}f(\boldsymbol{x}_0) \boldsymbol{h} + \sum_{i=1}^n\beta_i(\boldsymbol{h}) h_i\]</span></p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设开集<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，<span class="math inline">\(f: D \to\mathbb{R}\)</span>，<span class="math inline">\(\boldsymbol{x}_0 \inD\)</span>，如果<spanclass="math inline">\(\mathrm{D}_if(\boldsymbol{x})(i=1,2,\cdots,n)\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>的一个邻域中存在且在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处连续，则<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微。</p></blockquote><p>证：使用数学归纳法。当<spanclass="math inline">\(n=1\)</span>时自然成立，因为单变量函数的导数存在即可微。设定理对<spanclass="math inline">\(n-1\)</span>维成立，令<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) = K_1 +K_2\]</span><br />其中<br /><span class="math display">\[    \begin{aligned}    &amp; K_1 = f(x_1+h_1,x_2+h_2,\cdots,x_n+h_n) -f(x_1+h_1,\cdots,x_{n-1}+h_{n-1},x_n) \\    &amp; K_2 = f(x_1+h_1,\cdots,x_{n-1}+h_{n-1},x_n) -f(x_1,x_2,\cdots,x_n)    \end{aligned}\]</span><br />对<spanclass="math inline">\(K_1\)</span>运用一元微分中值定理，得到<br /><span class="math display">\[    K_1 = \frac{\partial f}{\partialx_n}(x_1+h_1,\cdots,x_{n-1}+h_{n-1},x_n+\theta h_n) h_n\]</span><br />其中<span class="math inline">\(\theta \in (0, 1)\)</span>，可以令<br /><span class="math display">\[    K_1 = \frac{\partial f}{\partial x_n}(\boldsymbol{x}_0) h_n + r_1\]</span><br />其中<br /><span class="math display">\[    \begin{aligned}    r_1 &amp; = \left( \frac{\partial f}{\partialx_n}(x_1+h_1,\cdots,x_{n-1}+h_{n-1},x_n+\theta h_n) - \frac{\partialf}{\partial x_n}(\boldsymbol{x}_0) \right) h_n \\    &amp; = \beta_n(\boldsymbol{h}) h_n    \end{aligned}\]</span><br />由<span class="math inline">\(\frac{\partial f}{\partialx_n}\)</span>函数的连续性可知，当<span class="math inline">\(\Vert\boldsymbol{h} \Vert \to 0\)</span>时，<spanclass="math inline">\(\beta_n(\boldsymbol{h}) \to 0\)</span>，从而<br /><span class="math display">\[    K_1 = \frac{\partial f}{\partial x_n}(\boldsymbol{x}_0)h_n +\beta_n(\boldsymbol{h})h_n\]</span><br />对<span class="math inline">\(K_2\)</span>使用<spanclass="math inline">\(n-1\)</span>维的归纳假设，可知<br /><span class="math display">\[    K_2 = \sum_{i=1}^{n-1} \frac{\partial f}{\partial x_i} h_i +\sum_{i=1}^{n-1} \beta_i(\boldsymbol{h}) h_i\]</span><br />当<span class="math inline">\(\Vert \boldsymbol{h} \Vert \to0\)</span>时，<span class="math inline">\(\beta_i(\boldsymbol{h}) \to 0(i=1,2,\cdots,n-1)\)</span>，从而<br /><span class="math display">\[    f(\boldsymbol{x}_0 + \boldsymbol{h}) - f(\boldsymbol{x}_0) = K_1+K_2= \sum \limits_{i=1}^n \frac{\partial f}{\partial x_i}(\boldsymbol{x}_0) h_i + \sum_{i=1}^{n-1} \beta_i(\boldsymbol{h})h_i\]</span><br />其中<span class="math inline">\(\beta_i(\boldsymbol{h}) \to 0 (\Vert\boldsymbol{h} \Vert \to 0)(i=1,2,\cdots,n)\)</span>。所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微。即对<spanclass="math inline">\(n\)</span>维定理也成立。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>若<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处的任意方向<spanclass="math inline">\(\boldsymbol{u} =(u_1,u_2,\cdots,u_n)\)</span>的方向导数都存在，且<br /><span class="math display">\[    \frac{\partial f}{\partial \boldsymbol{u}}(\boldsymbol{x}_0) =\frac{\partial f}{\partial x_1}(\boldsymbol{x}_0) u_1 +  \frac{\partialf}{\partial x_2}(\boldsymbol{x}_0) u_2 + \cdots + \frac{\partialf}{\partial x_n}(\boldsymbol{x}_0) u_n\]</span></p></blockquote><p>证：由于<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处可微，从而<br /><span class="math display">\[    f(\boldsymbol{x}_0 + t \boldsymbol{u}) - f(\boldsymbol{x}_0) =\sum_{i=1}^n \frac{\partial f}{\partial x_i} (\boldsymbol{x}_0) tu_i +o(t)\]</span><br />而<br /><span class="math display">\[    \frac{\partial f}{\partial \boldsymbol{u}}(\boldsymbol{x}_0) = \lim\limits_{t \to 0} \frac{f(\boldsymbol{x}_0+t \boldsymbol{u}) -f(\boldsymbol{x})}{t} = \sum_{i=1}^n \frac{\partial f}{\partial x_i} u_i\]</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分 </tag>
            
            <tag> 多变量函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数七：Taylor定理</title>
      <link href="/2021/03/28/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B07/"/>
      <url>/2021/03/28/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B07/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有直到<spanclass="math inline">\(n\)</span>阶的导数，这里<spanclass="math inline">\(n\)</span>是任意给定的正整数，令<br /><span class="math display">\[    T_n(f,x_0;x) = f(x_0) + \frac{1}{1!}f^\prime(x_0)(x - x_0) +\frac{1}{2!}f^{\prime\prime}(x_0)(x-x_0)^2 + \cdots +\frac{1}{n!}f^{(n)}(x_0)(x-x_0)^n\]</span><br />称它为<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的<spanclass="math inline">\(n\)</span>次Taylor多项式。</p></blockquote><span id="more"></span><h4id="定理1带peano余项的taylor定理">定理1：带Peano余项的Taylor定理</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有直到<spanclass="math inline">\(n\)</span>阶的导数，则有<br /><span class="math display">\[    f(x) = T_n(f,x_0;x) + o((x-x_0)^n)  \quad (x \to x_0)\]</span></p></blockquote><p>证：用数学归纳法。当<spanclass="math inline">\(n=1\)</span>时，由微分性质可知成立。现设<spanclass="math inline">\(n=k\)</span>时，上式成立。由于<br /><span class="math display">\[    T_{k+1}^{\prime}(f,x_0;x) = T_k(f^\prime, x_0; x)\]</span><br />由L'Hospital法则可知<br /><span class="math display">\[    \lim \limits_{x \to x_0} \frac{f(x) -T_{k+1}(f,x_0,x)}{(x-x_0)^{k+1}} = \frac{1}{k+1}\lim \limits_{x \to x_0}\frac{f^\prime(x) - T_k(f^\prime, x_0;x)}{(x-x_0)^k}\]</span><br />而<span class="math inline">\(f^\prime\)</span>在<spanclass="math inline">\(n = k\)</span>时定理成立，从而<br /><span class="math display">\[    \lim \limits_{x \to x_0} \frac{f^\prime(x) - T_k(f^\prime,x_0;x)}{(x-x_0)^k} = 0\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{x \to x_0} \frac{f(x) -T_{k+1}(f,x_0,x)}{(x-x_0)^{k+1}} = 0\]</span><br />令<br /><span class="math display">\[    R_n(x) = f(x) - T_n(f,x_0;x) \quad (n=1,2,\cdots)\]</span><br />称它为余项，满足<br /><span class="math display">\[    \lim \limits_{x \to x_0} \frac{R_n(x)}{(x-x_0)^n} = 0\]</span><br />这种余项称为Peano余项，该定理也称为带有Peano余项的Tyalor定理，也叫做函数<spanclass="math inline">\(f\)</span>的Taylor展开式。</p><p>Q.E.D.</p><h4id="定理2带peano余项的maclaurin定理">定理2：带Peano余项的Maclaurin定理</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x=0\)</span>处有直到<spanclass="math inline">\(n\)</span>阶的导数，则多项式<br /><span class="math display">\[    T_n(f,0;x) = f(0) + \frac{f^\prime(0)}{1!} x +\frac{f^{\prime\prime}(0)}{2!}x^2 + \cdots + \frac{f^{(n)}(0)}{n!}x^n\]</span><br />为<span class="math inline">\(f\)</span>的<spanclass="math inline">\(n\)</span>次Maclaurin多项式，相应地，<br /><span class="math display">\[    f(x) = T_n(f,0,x) + o(x^n) \quad (x \to x_0)\]</span><br />称为带Peano余项的Maclaurin定理，也叫做函数<spanclass="math inline">\(f\)</span>的Maclaurin展开式。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有直到<spanclass="math inline">\(k\)</span>阶的导数，并且<br /><span class="math display">\[    f^\prime(x_0) = f^{\prime\prime}(x_0) = \cdots = f^{(k-1)} (x_0) =0, f^{(k)}(x_0) \ne 0\]</span><br />那么：<br />（1）当<span class="math inline">\(k\)</span>为奇数时，<spanclass="math inline">\(x_0\)</span>不是<spanclass="math inline">\(f\)</span>的极值点。<br />（2）当<span class="math inline">\(k\)</span>为偶数时，若<spanclass="math inline">\(f^{(k)}(x_0)&gt;0\)</span>，则<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的严格极小值；若<spanclass="math inline">\(f^{(k)}(x_0)&lt;0\)</span>，则<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的严格极大值。</p></blockquote><p>证：由Peano余项的Taylor定理可知：<br /><span class="math display">\[    f(x) = f(x_0) + \frac{f^{(k)}(x_0)}{k!}(x-x_0)^k + o((x-x_0)^k)\quad (x \to x_0)\]</span><br />即<br /><span class="math display">\[    \frac{f(x) - f(x_0)}{(x-x_0)^k} = \frac{f^{(k)}(x_0)}{k!} + o(1)\]</span><br />（1）当<span class="math inline">\(k\)</span>为奇数时。若<spanclass="math inline">\(f^{(k)}(x_0) &gt; 0\)</span>，则当<spanclass="math inline">\(x&gt;x_0\)</span>时，<spanclass="math inline">\(f(x)&gt;f(x_0)\)</span>，<spanclass="math inline">\(x&lt;x_0\)</span>时，<spanclass="math inline">\(f(x)&lt;f(x_0)\)</span>，表明<spanclass="math inline">\(x_0\)</span>不是极值点；对于<spanclass="math inline">\(f^{(k)}(x_0) &lt;0\)</span>时，讨论是一样的；<br />（2）当<span class="math inline">\(k\)</span>为偶数时，由于<spanclass="math inline">\((x - x_0)^k\)</span>在<spanclass="math inline">\(x\ne x_0\)</span>处总是正值，所以当<spanclass="math inline">\(f^{(k)}(x_0)&gt;0\)</span>时，总有<spanclass="math inline">\(f(x)&gt;f(x_0)\)</span>，可知此时<spanclass="math inline">\(x_0\)</span>是极小值；同理当<spanclass="math inline">\(f^{(k)}(x_0)&lt;0\)</span>时，总有<spanclass="math inline">\(f(x)&lt;f(x_0)\)</span>，此时<spanclass="math inline">\(x_0\)</span>是极大值点。</p><p>Q.E.D.</p><h4id="定理4带lagrange余项和cauchy余项的taylor定理">定理4：带Lagrange余项和Cauchy余项的Taylor定理</h4><blockquote><p>设<span class="math inline">\(f\)</span>在开区间<spanclass="math inline">\((a,b)\)</span>上有<spanclass="math inline">\(n+1\)</span>阶导数，<spanclass="math inline">\(x_0,x\)</span>是<spanclass="math inline">\((a,b)\)</span>中任意两点，那么<br /><span class="math display">\[    f(x) = T_n(f,x_0;x) + R_n(x)\]</span><br />其中<br /><span class="math display">\[    R_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!}(x - x_0)^{(n+1)}\]</span><br />称为Lagrange余项；<br />或者<br /><span class="math display">\[    R_n(x) = \frac{f^{(n+1)}(\xi)}{n!}(x - \xi)^n(x - x_0)\]</span><br />称为Cauchy余项。</p></blockquote><p>证：记<br /><span class="math display">\[    F(t) = T_n(f,t;x) = f(t) + \sum_{k=1}^n \frac{f^{(k)}(t)}{k!}(x-t)^k\]</span><br />有<br /><span class="math display">\[\begin{aligned}    F^\prime(t) &amp; = f^\prime(t) + \sum_{k=1}^n\left(\frac{f^{(k+1)}(t)}{k!}(x-t)^k -\frac{f^{(k)}(t)}{(k-1)!}(x-t)^{(k-1)} \right) \\    &amp; = f^\prime(t) + \sum_{k=1}^n \frac{f^{(k+1)}(t)}{k!}(x-t)^k +\sum_{k=1}^n \frac{f^{(k)}(t)}{(k-1)!}(x-t)^{(k-1)} \\    &amp; = f^\prime(t) + \frac{f^{(n+1)}(t)}{n!}(x-t)^{(n)} -f^\prime(t) = \frac{f^{(n+1)}(t)}{n!}(x-t)^{(n)}\end{aligned}\]</span><br />对函数<span class="math inline">\(g(t)=F(t),\lambda(t) = \left(\frac{x-t}{x-x_0}\right)^{n+1}\)</span>，在区间<spanclass="math inline">\([x_0,x]\)</span>（先设<spanclass="math inline">\(x_0&lt;x\)</span>）上使用<ahref="https://gamersover.github.io/2021/02/01/函数导数3/#定理3">函数导数三的定理3</a>可知，必存在<spanclass="math inline">\(\xi \in (x_0, x)\)</span>，使得<br /><span class="math display">\[    F^\prime(\xi) = \lambda^\prime(\xi)(F(x_0) - F(x))\]</span><br />而<br /><span class="math display">\[    \lambda^\prime(t) = -(n+1)\frac{(x-t)^n}{(x-x_0)^{n+1}}\]</span><br />从而<br /><span class="math display">\[    \frac{f^{(n+1)}(\xi)}{n!}(x-\xi)^{n} =-(n+1)\frac{(x-\xi)^n}{(x-x_0)^{n+1}}(T_n(f,x_0;x)-f(x))\]</span><br />即<br /><span class="math display">\[    f(x) = T_n(f,x_0;x) + \frac{f^{(n+1)}(\xi)}{(n+1)!}(x-x_0)^{n+1}\]</span><br />这就是带Lagrange余项的Taylor定理；若令<spanclass="math inline">\(\lambda(t) = \frac{x-t}{x-x_0}\)</span>，则同上可得<br /><span class="math display">\[    \frac{f^{(n+1)}(\xi)}{n!}(x-\xi)^{n} =-\frac{1}{x-x_0}(T_n(f,x_0;x)-f(x))\]</span><br />即<br /><span class="math display">\[    f(x) = T_n(f,x_0;x) + \frac{f^{(n+1)}(\xi)}{n!}(x-\xi)^n(x-x_0)\]</span><br />这就是带Cauchy余项的Taylor定理。</p><p>如果<span class="math inline">\(x &lt; x_0\)</span>，分别取<br /><span class="math display">\[    \lambda(t) = 1 - \left( \frac{x - t}{x-x_0} \right)^{(n+1)}, \quad\lambda(t) = 1 - \frac{x-t}{x-x_0}\]</span><br />即可证。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> Taylor定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解19：删除链表的倒数第N个结点</title>
      <link href="/2021/03/28/leetcode%E9%A2%98%E8%A7%A319/"/>
      <url>/2021/03/28/leetcode%E9%A2%98%E8%A7%A319/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">力扣第19题</a></p><p>给你一个链表，删除链表的倒数第<code>n</code>个结点，并且返回链表的头结点。<br />进阶：你能尝试使用一趟扫描实现吗？</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入：head = [1,2,3,4,5], n = 2<br />输出：[1,2,3,5]</p></blockquote><p>示例 2：</p><blockquote><p>输入：head = [1], n = 1<br />输出：[]</p></blockquote><p>示例 3：</p><blockquote><p>输入：head = [1,2], n = 1<br />输出：[1]</p></blockquote><p>提示：</p><ul><li>链表中结点的数目为<code>sz</code></li><li>1 &lt;= <code>sz</code> &lt;= 30</li><li>0 &lt;= <code>Node.val</code> &lt;= 100</li><li>1 &lt;= <code>n</code> &lt;= sz</li></ul><h2 id="分析">分析</h2><p>想找到倒数第<code>n</code>个结点，就相当于找到第<code>sz - n + 1</code>个结点，但是<code>sz</code>不知道，需要一趟遍历整个链表才能获得，这样看来无论如何都需要两遍扫描；还记得找到中点结点的方法吗？快慢指针，一遍扫描即可；这里也可以用类似的想法；比如，现有一链表如下，要删除倒数第2个结点：</p><blockquote><p>1 -&gt; 2 -&gt; 3 -&gt; <font color='blue'>4</font> -&gt; 5 -&gt;<font color='red'>6</font></p></blockquote><p>如果我们能够让第一个指针<code>p1</code>指向4，那么就可以进行删除操作了；利用快慢指针的想法，第二个指针<code>p2</code>需要指向最后一个结点即6，所以两个指针相差2个结点，如果最开始让<code>p1</code>指向1，<code>p2</code>指向3，然后只需让<code>p1++,p2++</code>直到<code>p2</code>到达最后一个结点，这时<code>p1</code>自然达到了倒数第<code>n</code>个结点了。</p><p>所以先让<code>p2</code>指针往右走<code>n</code>步，达到第<code>n+1</code>个结点，然后<code>p1,p2</code>指针同时走动1步，直到<code>p2</code>指针指向<code>sz</code>，这时<code>p1</code>自然会指向<code>sz -n</code>，即要删除结点的父结点位置，然后就可以删除了。当然，还要考虑特殊情况：删除一个结点的时候的特殊处理。或者用一个虚假的头指向链表原有head，这样就不用考虑特殊情况了。</p><h2 id="算法">算法</h2><p>采用双指针法，<br />1. 初始化<code>p1=head,p2=head</code><br />2.进入循环<code>p2 = p2-&gt;next</code>，直到<code>i==n</code>，如果<code>p2==null</code>，表明删除的是头结点，则让<code>head = p1-&gt;next</code>退出程序，或则进入3<br />3.进入循环<code>p1 = p1-&gt;next, p2=p2-&gt;next</code>，直到<code>p2-&gt;next == null</code>，表明<code>p2</code>已到达最后一个结点，此时让<code>p1-&gt;next = p1-&gt;next-&gt;next</code></p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head, n</span>):</span><br><span class="line">        p1, p2 = head, head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; n <span class="keyword">and</span> p2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p2 <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            head = p1.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> p2.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">        p1.<span class="built_in">next</span> = p1.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* p1 = head;</span><br><span class="line">        ListNode* p2 = head;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; p2 != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p2-&gt;next != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            p1 = p1-&gt;next;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1-&gt;next = p1-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p2</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; p2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(p2.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            p1 = p1.next;</span><br><span class="line">            p2 = p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p1.next = p1.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 双指针法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数六：函数的微分</title>
      <link href="/2021/03/16/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B06/"/>
      <url>/2021/03/16/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B06/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1微分">定义1：微分</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上有定义，且<spanclass="math inline">\(x_0 \in (a,b)\)</span>，如果存在一个常熟<spanclass="math inline">\(\lambda\)</span>，使得<br /><span class="math display">\[    f(x_0 + \Delta x) - f(x_0) = \lambda \Delta x + o(\Delta x)  \quad(\Delta x \to 0)\]</span><br />则称函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>处可微，<spanclass="math inline">\(\lambda \Delta x\)</span>称为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的微分，记作<spanclass="math inline">\(\mathrm{d}f(x_0)\)</span>。如果<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上任意一点都可微，则称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上可微。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>处可微的充分必要条件是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>出可导。</p></blockquote><p>证：必要性。由可微的定义可知<br /><span class="math display">\[    f(x_0 + \Delta x) - f(x_0) = \lambda \Delta x + o(\Delta x)  \quad(\Delta x \to 0)\]</span><br />上式两边同时除以<span class="math inline">\(\Deltax\)</span>，可得<br /><span class="math display">\[    \frac{f(x_0 + \Delta x) - f(x_0)}{\Delta x} = \lambda + o(1)  \quad(\Delta x \to 0)\]</span><br />从而得到<br /><span class="math display">\[    \lambda = \lim \limits_{\Delta x \to 0} \frac{f(x_0 + \Delta x) -f(x_0)}{\Delta x} = f^\prime(x_0)\]</span><br />这就表明<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处可导；</p><p>充分性。由可导的定义可知<br /><span class="math display">\[    f^\prime(x_0) = \lim \limits_{\Delta x \to 0} \frac{f(x_0 + \Deltax) - f(x_0)}{\Delta x}\]</span><br />然后根据上面的证明反推，即可证。<br />从而对单变量函数来说，可导和可微是同一回事。且有<br /><span class="math display">\[    \mathrm{d} f(x_0) = f^\prime(x_0) \Delta x\]</span><br />Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>（1）<span class="math inline">\(\mathrm{d} x = \Deltax\)</span><br />（2）<span class="math inline">\(\mathrm{d} f(x) = f^\prime(x)\mathrm{d}x\)</span></p></blockquote><p>证：由于<br /><span class="math display">\[    \mathrm{d} f(x) = f^\prime(x) \Delta x \tag 1\]</span><br />从而当<span class="math inline">\(f(x) = x\)</span>时，有<spanclass="math inline">\(f^\prime(x) = 1\)</span>，所以<br /><span class="math display">\[    \mathrm{d} f(x) = \Delta x \tag 2\]</span><br />将(2)式代入(1)式即可得<br /><span class="math display">\[    \mathrm{d} f(x) = f^\prime(x) \mathrm{d}x\]</span></p><h4 id="定义2微商">定义2：微商</h4><blockquote><p>函数<span class="math inline">\(f\)</span>如果在区间<spanclass="math inline">\(I\)</span>上可微，则称<spanclass="math inline">\(\frac{\mathrm{d}f(x)}{\mathrm{d}x}\)</span>为函数<spanclass="math inline">\(f\)</span>的微商，由于<spanclass="math inline">\(\frac{\mathrm{d}f(x)}{\mathrm{d}x} =f^\prime(x)\)</span>，所以微商也称为导数。</p></blockquote><h4 id="定理3微分的四则运算">定理3：微分的四则运算</h4><blockquote><p>函数<span class="math inline">\(f,g\)</span>在区间<spanclass="math inline">\(I\)</span>上可微，则<br />（1）<span class="math inline">\(\mathrm{d} (f \pm g) = \mathrm{d} f +\mathrm{d} g\)</span><br />（2）<span class="math inline">\(\mathrm{d} (fg) = g \mathrm{d}f + f\mathrm{d} g\)</span><br />（3）<span class="math inline">\(\mathrm{d} \left(\frac{f}{g}\right) =\frac{g \mathrm{d}f - f \mathrm{d} g}{g^2}\)</span></p></blockquote><p>证：利用微分与导数的关系易证。</p><h4 id="定义3">定义3</h4><blockquote><p>设函数<span class="math inline">\(y=f(x)\)</span>在区间<spanclass="math inline">\(I\)</span>上可微，那么<spanclass="math inline">\(\mathrm{d} y = f^\prime(x)\mathrm{d}x\)</span>仍然是<spanclass="math inline">\(x\)</span>的函数，如果<spanclass="math inline">\(f^\prime(x)\)</span>仍可微，则可计算<spanclass="math inline">\(\mathrm{d}y\)</span>的微分，记<spanclass="math inline">\(\mathrm{d}^2 y = \mathrm{d} (\mathrm{d}y)\)</span>，可知<br /><span class="math display">\[    \mathrm{d}^2 y = \mathrm{d} (\mathrm{d} y) = \mathrm{d} (f^\prime(x)\mathrm{d} x) = f^{\prime\prime}(x) \mathrm{d} x^2\]</span><br />这里<span class="math inline">\(\mathrm{d} x^2 = (\mathrm{d}x)^2\)</span>，称<spanclass="math inline">\(\mathrm{d}^2y\)</span>为<spanclass="math inline">\(y = f(x)\)</span>的二次微分。如果<spanclass="math inline">\(f^{\prime\prime}(x)\)</span>仍可微，则可定义三阶微分<br /><span class="math display">\[    \mathrm{d}^3 y = f^{\prime\prime\prime}(x) \mathrm{d} x^3\]</span><br />如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x\)</span>处有<spanclass="math inline">\(n\)</span>阶导数，那么有<br /><span class="math display">\[    \mathrm{d}^n y = f^{(n)}(x) \mathrm{d} x^n\]</span><br />且有<span class="math inline">\(n\)</span>阶导数的记号<br /><span class="math display">\[    \frac{\mathrm{d}^n y}{\mathrm{d} x^n} = f^{(n)} (x)\]</span></p></blockquote><h4 id="定理4复合函数的微分">定理4：复合函数的微分</h4><blockquote><p>设<span class="math inline">\(y=f(x)\)</span>且<spanclass="math inline">\(x = \varphi(t)\)</span>，当<spanclass="math inline">\(t\)</span>在<spanclass="math inline">\(\varphi\)</span>的定义域内变化时，<spanclass="math inline">\(\varphi(t)\)</span>的值也在<spanclass="math inline">\(f\)</span>的定义域内。且函数<spanclass="math inline">\(f,\varphi\)</span>都可微，则复合函数<spanclass="math inline">\(y = f\circ \varphi (t)\)</span>，也可微。</p></blockquote><p>证：由于<br /><span class="math display">\[    \mathrm{d} y = (f \circ \varphi)^\prime \mathrm{d}t  = f^\prime(x)\varphi^\prime(t) \mathrm{d} t\]</span><br />又知<span class="math inline">\(\mathrm{d} x = \varphi(t)^\prime\mathrm{d} t\)</span>，代入上式，可得<br /><span class="math display">\[    \mathrm{d} y = f^\prime(x) \mathrm{d} x\]</span><br />如果<spanclass="math inline">\(x\)</span>是自变量，上式自然成立。也就是无论是对独立的自变量还是对中间变量上式都是正确的，这称为一阶微分形式的不变性。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解16：最接近的三数之和</title>
      <link href="/2021/03/13/leetcode%E9%A2%98%E8%A7%A316/"/>
      <url>/2021/03/13/leetcode%E9%A2%98%E8%A7%A316/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/3sum-closest/">力扣第16题</a><br />给定一个包括<code>n</code>个整数的数组<code>nums</code>和一个目标值<code>target</code>。找出<code>nums</code>中的三个整数，使得它们的和与<code>target</code>最接近。返回这三个数的和。假定每组输入只存在唯一答案。</p><span id="more"></span><p> <br />示例：</p><blockquote><p>输入：nums = [-1,2,1,-4], target = 1<br />输出：2<br />解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</p></blockquote><p>提示：</p><ul><li><code>3 &lt;= nums.length &lt;= 10^3</code></li><li><code>-10^3 &lt;= nums[i] &lt;= 10^3</code></li><li><code>-10^4 &lt;= target &lt;= 10^4</code></li></ul><h2 id="分析">分析</h2><p>首先想到三数之和的解法，将数组排序，然后先固定第一个数，接下来就是如何找到另外两个数，使得三个数的和最接近target。还是用双指针法，假设第一个数下标为<code>first</code>，第二个数下标为<code>second=first+1</code>，第三个数下标为<code>third=n-1</code>，记<code>s=nums[first]+nums[second]+nums[third]</code>，由于数组是排过序的，所以分三种情况<br />1.如果<code>s=target</code>，直接返回这<code>target</code>就可以了；<br />2.如果<code>s&gt;target</code>，那么移动指针<code>second</code>，只会让<code>s</code>更大，从而与<code>target</code>相差更大，所以让<code>third--</code>；<br />3.如果<code>s&lt;target</code>，那么移动指针<code>third</code>，只会让<code>s</code>更小，从而与<code>target</code>相差更大，所以让<code>second--</code></p><p>经过上述步骤，如果没有返回，记录<code>s-target</code>的绝对值是否是最小的，并更新s，然后遍历<code>first</code>就可以找到最终结果了。<br />## 算法<br />1. 排序数组<br />2.将最接近<code>target</code>的值<code>closest</code>初始化为<code>nums[0]+nums[1]+nums[2]</code><br />3.第一个数下标<code>first</code>从<code>0</code>到<code>n-3</code>遍历数组<br />4.进入循环体，设<code>second=first + 1</code>，<code>third=n-1</code>，计算<code>s=nums[first] + nums[second] + nums[third]</code><br />5.判断<code>s</code>与<code>target</code>的关系，如果<code>s==target</code>，直接返回target，退出程序；否则按照上面的分析更新<code>second</code>，<code>third</code><br />6.如果<code>|s-target|&lt;|closest-target|</code>，那么更新<code>closest=s</code><br />7.判断<code>second</code>是否大于等于<code>third</code>，如果是，退出循环；否则<code>first++</code>，并进入循环体（第4步）</p><p>小优化：</p><blockquote><p>在三数之和中，为了避免找到重复解，每到一个新数时可以和前面数比较，如果一样直接跳过。这里在遍历<code>first,second,third</code>三个数时都可以跳过重复值，避免重复计算。<br />## 代码</p></blockquote><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        closest = <span class="built_in">sum</span>(nums[:<span class="number">3</span>])</span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> first &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span>:</span><br><span class="line">            second, third = first + <span class="number">1</span>, <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> second &lt; third:</span><br><span class="line">                s = nums[first] + nums[second] + nums[third]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">abs</span>(s - target) &lt;= <span class="built_in">abs</span>(closest - target):</span><br><span class="line">                    closest = s</span><br><span class="line">                    <span class="keyword">if</span> closest == target:</span><br><span class="line">                        <span class="keyword">return</span> target</span><br><span class="line">                <span class="keyword">if</span> s &gt; target:</span><br><span class="line">                    <span class="keyword">while</span> third &gt; second <span class="keyword">and</span> nums[third] == nums[third-<span class="number">1</span>]:</span><br><span class="line">                        third -= <span class="number">1</span></span><br><span class="line">                    third -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> s &lt; target:</span><br><span class="line">                    <span class="keyword">while</span> second &lt; third <span class="keyword">and</span> nums[second] == nums[second+<span class="number">1</span>]:</span><br><span class="line">                        second += <span class="number">1</span></span><br><span class="line">                    second += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> first &lt; <span class="built_in">len</span>(nums) - <span class="number">2</span> <span class="keyword">and</span> nums[first] == nums[first+<span class="number">1</span>]:</span><br><span class="line">                first += <span class="number">1</span></span><br><span class="line">            first += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> closest</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">threeSumClosest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> closest = nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (first &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> third = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (second &lt; third) &#123;</span><br><span class="line">                <span class="type">int</span> s = nums[first] + nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">abs</span>(s - target) &lt;= <span class="built_in">abs</span>(closest - target)) &#123;</span><br><span class="line">                    closest = s;</span><br><span class="line">                    <span class="keyword">if</span> (closest == target) <span class="keyword">return</span> target;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (s &gt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span>((third &gt; second) &amp;&amp; (nums[third] == nums[third<span class="number">-1</span>])) third--;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s &lt; target) &#123;</span><br><span class="line">                    <span class="keyword">while</span> ((second &lt; third) &amp;&amp; (nums[second] == nums[second + <span class="number">1</span>])) second++;;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((first &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>) &amp;&amp; (nums[first + <span class="number">1</span>] == nums[first])) first++;</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">threeSumClosest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">closest</span> <span class="operator">=</span> nums[<span class="number">0</span>] + nums[<span class="number">1</span>] + nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">while</span> (first &lt; nums.length - <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> first + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">third</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (second &lt; third)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums[first] + nums[second] + nums[third];</span><br><span class="line">                <span class="keyword">if</span> (Math.abs(s - target) &lt;= Math.abs(closest - target))&#123;</span><br><span class="line">                    closest = s;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (closest == target) <span class="keyword">return</span> target;</span><br><span class="line">                <span class="keyword">if</span> (s &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span> ((third &gt; second) &amp;&amp; (nums[third] == nums[third-<span class="number">1</span>])) third--;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; target)&#123;</span><br><span class="line">                    <span class="keyword">while</span> ((second &lt; third) &amp;&amp; (nums[second] == nums[second+<span class="number">1</span>])) second++;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((first &lt; nums.length - <span class="number">2</span>) &amp;&amp; (nums[first] == nums[first+<span class="number">1</span>])) first++;</span><br><span class="line">            first++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> closest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学科普一：平均数</title>
      <link href="/2021/03/12/%E6%95%B0%E5%AD%A6%E7%A7%91%E6%99%AE1/"/>
      <url>/2021/03/12/%E6%95%B0%E5%AD%A6%E7%A7%91%E6%99%AE1/</url>
      
        <content type="html"><![CDATA[<p>假设两个正数<span class="math inline">\(a,b\)</span>，我们知道<spanclass="math inline">\(\frac{a+b}{2}\)</span>称为算术平均数，<spanclass="math inline">\(\sqrt{ab}\)</span>称为几何平均数，<spanclass="math inline">\(\frac{2}{a^{-1}+b^{-1}}\)</span>称为调和平均数。对于任意<spanclass="math inline">\(n\)</span>个正数也有同样的定义，观察到算术平均数为<spanclass="math inline">\(\left(\frac{a^{1}+b^{1}}{2}\right)^1\)</span>，调和平均数为<spanclass="math inline">\(\left(\frac{a^{-1}+b^{-1}}{2}\right)^{-1}\)</span>，可以猜想一类平均数的定义。</p><span id="more"></span><h4 id="定义1s阶平均数">定义1：<spanclass="math inline">\(s\)</span>阶平均数</h4><blockquote><p>设<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>是<spanclass="math inline">\(n\)</span>个正数，定义<br /><span class="math display">\[    f(s) = \left\{        \begin{aligned}            &amp; \left(\frac{a_1^s+a_2^s+\cdots+a_n^s}{n}\right)^{1/s}&amp; \quad s \ne 0  \\            &amp; \sqrt[n]{a_1a_2\cdots a_n} &amp; \quad s = 0        \end{aligned}        \right.\]</span><br />称<span class="math inline">\(f(s)\)</span>为这<spanclass="math inline">\(n\)</span>个正数的<spanclass="math inline">\(s\)</span>阶平均数。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>是<spanclass="math inline">\(n\)</span>个正数，则这<spanclass="math inline">\(n\)</span>个数的<spanclass="math inline">\(s\)</span>阶平均数<spanclass="math inline">\(f(s)\)</span>是关于<spanclass="math inline">\(s\)</span>在<spanclass="math inline">\((-\infty,+\infty)\)</span>上的连续函数。且<br /><span class="math display">\[    \begin{aligned}        \lim \limits_{s \to +\infty} f(s) = \max(a_1,a_2,\cdots,a_n) \\        \lim \limits_{s \to -\infty} f(s) = \min(a_1,a_2,\cdots,a_n)    \end{aligned}\]</span></p></blockquote><p>证：先证<spanclass="math inline">\(f(s)\)</span>是连续函数。由于分段函数的两段都是初等函数，所以只需要证明<spanclass="math inline">\(f(s)\)</span>在<spanclass="math inline">\(s=0\)</span>处连续，即可。而<br /><span class="math display">\[    \begin{aligned}        \lim \limits_{s \to 0}\left(\frac{a_1^s+a_2^s+\cdots+a_n^s}{n}\right)^{1/s} &amp; =\lim\limits_{s \to 0} e^{\frac{1}{s} \ln\left(\frac{a_1^s-1 + a_2^s - 1+ \cdots + a_n^s-1 + n}{n}\right)} \\        &amp; = \lim\limits_{s \to 0} e^{\frac{1}{s} \ln \left(1 +\frac{a_1^s-1}{n} + \frac{a_2^s-1}{n} + \cdots + \frac{a_n^s-1}{n}\right)} \\        &amp; = \lim\limits_{s \to 0} e^{\frac{1}{n}\left(\frac{a_1^s-1}{s} + \frac{a_2^s-1}{s} + \cdots + \frac{a_n^s-1}{s}\right)} \\        &amp; = e^{\frac{1}{n} \ln(a_1a_2\cdots a_n)} =\sqrt[n]{a_1a_2\cdots a_n}    \end{aligned}\]</span><br />所以<span class="math inline">\(f(s)\)</span>是连续的。<br />再证后半段。不妨设<span class="math inline">\(p =\max(a_1,a_2,\cdots,a_n)\)</span>，从而当<span class="math inline">\(s&gt; 0\)</span>时，有<br /><span class="math display">\[    \left(\frac{p^s}{n}\right)^{1/s} \le\left(\frac{a_1^s+a_2^s+\cdots+a_n^s}{n}\right)^{1/s} \le\left(\frac{p^s+p^s+\cdots+p^s}{n}\right)^{1/s} = p\]</span><br />而<br /><span class="math display">\[    \lim \limits_{s \to +\infty} \left(\frac{p^s}{n}\right)^{1/s}  = p\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{s \to +\infty} f(s) = p = \max(a_1,a_2,\cdots,a_n)\]</span><br />同样设<span class="math inline">\(q =\min(a_1,a_2,\cdots,a_n)\)</span>，当<span class="math inline">\(s &lt;0\)</span>时，有<br /><span class="math display">\[    \left(\frac{q^s}{n}\right)^{1/s} \ge\left(\frac{a_1^s+a_2^s+\cdots+a_n^s}{n}\right)^{1/s} \ge\left(\frac{q^s+q^s+\cdots+q^s}{n}\right)^{1/s} = q\]</span><br />而<br /><span class="math display">\[    \lim \limits_{s \to -\infty} \left(\frac{q^s}{n}\right)^{1/s}  = q\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{s \to -\infty} f(s) = q = \min(a_1,a_2,\cdots,a_n)\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(a_1,a_2,\cdots,a_n\)</span>是<spanclass="math inline">\(n\)</span>个正数，则这<spanclass="math inline">\(n\)</span>个数的<spanclass="math inline">\(s\)</span>阶平均数<spanclass="math inline">\(f(s)\)</span>是<spanclass="math inline">\((-\infty,+\infty)\)</span>上的递增函数。若<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>不全相等，则<spanclass="math inline">\(f(s)\)</span>是<spanclass="math inline">\((-\infty,+\infty)\)</span>上的严格递增函数。</p></blockquote><p>证：先设<span class="math inline">\(0 &lt; \alpha &lt;\beta\)</span>，我们证明<span class="math inline">\(f(\alpha) \lef(\beta)\)</span>，即<br /><span class="math display">\[    \left(\frac{a_1^\alpha+a_2^\alpha+\cdots+a_n^\alpha}{n}\right)^{1/\alpha} \le \left(\frac{a_1^\beta + a_2^\beta + \cdots+a_n^\beta}{n}\right)^{1/\beta}\]</span><br />记<span class="math inline">\(g(x) = x^m (x &gt; 0)\)</span>，则<spanclass="math inline">\(g^\prime(x) = m x^{m-1}\)</span>，<spanclass="math inline">\(g^{\prime\prime}(x) =m(m-1)x^{m-2}\)</span>，当<span class="math inline">\(m &gt;1\)</span>时，知<spanclass="math inline">\(g(x)\)</span>是凸函数，从而由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理7">函数导数五的定理7</a>可知，有<br /><span class="math display">\[    g\left(\frac{x_1}{n} + \frac{x_2}{n} + \cdots + \frac{x_n}{n}\right)\le \frac{g(x_1)+g(x_2)+\cdots+g(x_n)}{n}\]</span><br />即<br /><span class="math display">\[    \left(\frac{x_1+x_2+\cdots+x_n}{n} \right)^m \le \frac{x_1^m + x_2^m+ \cdots+ x_n^m}{n} \tag 1\]</span><br />令<span class="math inline">\(x_i = a_i^\alpha, m = \beta / \alpha &gt;1\)</span>，代入上式得<br /><span class="math display">\[    \left(\frac{a_1^\alpha+a_2^\alpha+\cdots+a_n^\alpha}{n}\right)^{\beta / \alpha} \le \frac{a_1^\beta + a_2^\beta + \cdots+a_n^\beta}{n}\]</span><br />即<br /><span class="math display">\[    \left(\frac{a_1^\alpha+a_2^\alpha+\cdots+a_n^\alpha}{n}\right)^{1/\alpha} \le \left(\frac{a_1^\beta + a_2^\beta + \cdots+a_n^\beta}{n}\right)^{1/\beta} \tag 2\]</span><br />再设<span class="math inline">\(\alpha &lt; \beta &lt;0\)</span>，我们证明<span class="math inline">\(f(\alpha) &lt;f(\beta)\)</span>。由于<span class="math inline">\(-\alpha &gt; -\beta&gt; 0\)</span>，这时设<spanclass="math inline">\(n\)</span>个正数为<spanclass="math inline">\(a_1^{-1},a_2^{-1},\cdots,a_n^{-1}\)</span>，并令<spanclass="math inline">\(x_i = (a_i^{-1})^{-\beta}, m = (-\alpha) /(-\beta) &gt; 1\)</span>，代入(1)式得<br /><span class="math display">\[    \left(\frac{a_1^{\beta}+a_2^{\beta}+\cdots+a_n^{\beta}}{n}\right)^{-\alpha / -\beta} \le \frac{a_1^{\alpha} + a_2^{\alpha} +\cdots+ a_n^{\alpha}}{n}\]</span><br />即<br /><span class="math display">\[    \left(\frac{a_1^{\beta}+a_2^{\beta}+\cdots+a_n^{\beta}}{n}\right)^{-1 / \beta} \le \left(\frac{a_1^{\alpha} + a_2^{\alpha} +\cdots+ a_n^{\alpha}}{n} \right)^{-1 / \alpha}\]</span><br />进一步化简得<br /><span class="math display">\[    \left(\frac{a_1^{\alpha} + a_2^{\alpha} + \cdots+ a_n^{\alpha}}{n}\right)^{1 / \alpha} \le\left(\frac{a_1^{\beta}+a_2^{\beta}+\cdots+a_n^{\beta}}{n} \right)^{1 /\beta} \tag 3\]</span><br />最后证明<span class="math inline">\(f(\alpha) &lt; f(0) &lt;f(\beta)\)</span>，其中<span class="math inline">\(\alpha &lt; 0 &lt;\beta\)</span>。在(2)式中令<span class="math inline">\(\alpha \to0^+\)</span>，得<span class="math inline">\(\sqrt[n]{a_1a_2\cdots a_n}\le f(\beta)\)</span>；在(3)式中令<span class="math inline">\(\beta \to0^-\)</span>，得<span class="math inline">\(f(\alpha) &lt;\sqrt[n]{a_1a_2\cdots a_n}\)</span>。从而<spanclass="math inline">\(f(s)\)</span>是<spanclass="math inline">\((-\infty,+\infty)\)</span>上的递增函数。</p><p>而上面所有等式成立的充分必要条件是<spanclass="math inline">\(a_1=a_2=\cdots=a_n\)</span>。所以当<spanclass="math inline">\(a_1,a_2,\cdots,a_n\)</span>不全相等时，<spanclass="math inline">\(f(s)\)</span>是<spanclass="math inline">\((-\infty,+\infty)\)</span>上的严格递增函数。</p><p>Q.E.D.</p><h4 id="总结">总结</h4><p>从上面分析易知调和平均数是<spanclass="math inline">\(-1\)</span>阶平均数，几何平均数是<spanclass="math inline">\(0\)</span>阶平均数，算术平均数是<spanclass="math inline">\(1\)</span>阶平均数；且有调和平均数<spanclass="math inline">\(&lt;\)</span>几何平均数<spanclass="math inline">\(&lt;\)</span>算术平均数。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学科普 </tag>
            
            <tag> 平均数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数五：函数性质与导数的关系</title>
      <link href="/2021/03/08/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B05/"/>
      <url>/2021/03/08/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B05/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1">定理1</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上递增（减）的充分必要条件是<spanclass="math inline">\(f^\prime \ge 0 (\le 0)\)</span>在区间<spanclass="math inline">\((a,b)\)</span>上成立。</p></blockquote><span id="more"></span><p>证：必要性。设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上递增，任取一点<spanclass="math inline">\(x \in (a,b)\)</span>，对能使<spanclass="math inline">\(x + h \in (a,b)\)</span>的一切<spanclass="math inline">\(h\)</span>，都有<br /><span class="math display">\[    \frac{f(x+h) - f(x)}{h} \ge 0\]</span><br />令<span class="math inline">\(h \to 0\)</span>，得<spanclass="math inline">\(f^\prime(x) \ge 0 (a &lt; x &lt;b)\)</span>。<br />类似地，当<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上递减时，可以推出<spanclass="math inline">\(f^\prime(x) \ge 0\)</span>对<spanclass="math inline">\(x \in (a,b)\)</span>成立。</p><p>充分性。设在<span class="math inline">\((a,b)\)</span>上<spanclass="math inline">\(f^\prime \ge 0\)</span>，对任何<spanclass="math inline">\(x_1, x_2 \in [a,b]\)</span>且<spanclass="math inline">\(x_1 &lt;x_2\)</span>，由Lagrange中值定理可知，<br /><span class="math display">\[    f(x_2) - f(x_1) = f^\prime(\xi) (x_2 - x_1)\]</span><br />其中<span class="math inline">\(\xi \in (x_1,x_2) \in(a,b)\)</span>，由于<span class="math inline">\(f^\prime(\xi) \ge0\)</span>，从而<span class="math inline">\(f(x_2) \gef(x_1)\)</span>。<br />类似地，当在<span class="math inline">\((a,b)\)</span>上<spanclass="math inline">\(f^\prime \le 0\)</span>时，对任何<spanclass="math inline">\(x_1,x_2 \in [a,b]\)</span>且<spanclass="math inline">\(x_1 &lt; x_2\)</span>，可以推出<spanclass="math inline">\(f(x_1) \ge f(x_2)\)</span>。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，如果<spanclass="math inline">\(f^\prime &gt; 0 (&lt; 0)\)</span>在区间<spanclass="math inline">\((a,b)\)</span>上成立。那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格递增（严格递减）的。</p></blockquote><p>证：证法与<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理1">定理1</a>一样。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，在区间<spanclass="math inline">\((a,b)\)</span>内，除了有限个点之外，<spanclass="math inline">\(f^\prime &gt; 0 (&lt; 0)\)</span>成立。那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格递增（严格递减）的。</p></blockquote><p>证。设除了点<span class="math inline">\(x_1,x_2,\cdots,x_n \in(a,b)\)</span>外，<span class="math inline">\(f^\prime &gt;0\)</span>，这里<span class="math inline">\(x_1 &lt; x_2 &lt; \cdots&lt; x_n\)</span>，<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,x_1],[x_1,x_2],\cdots,[x_n,b]\)</span>上都是连续的，且<spanclass="math inline">\(f^\prime &gt; 0\)</span>，因此在<spanclass="math inline">\([a,x_1],[x_1,x_2],\cdots,[x_n,b]\)</span>的每一个区间上都是严格递增的，因此在<spanclass="math inline">\([a,b]\)</span>上也是严格递增的。<br />类似地，递减也可证。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格递增（严格递减）的充分必要条件是：<br />（1）当<span class="math inline">\(x \in (a,b)\)</span>时，<spanclass="math inline">\(f^\prime \ge 0 (f^\prime \le 0)\)</span>；<br />（2）在<span class="math inline">\((a,b)\)</span>的任何开子区间上，<spanclass="math inline">\(f^\prime \ne 0\)</span>。</p></blockquote><p>证：必要性。由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理1">定理1</a>可知，（1）是必要的，假如（2）不正确，则存在一个被<spanclass="math inline">\((a,b)\)</span>包含的开区间，在其上<spanclass="math inline">\(f^\prime = 0\)</span>，那么在这个开区间上<spanclass="math inline">\(f\)</span>为常数，因此<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上不是严格单调的，从而（2）必然正确。</p><p>充分性。设（1）（2）同时成立，由（1）和<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理1">定理1</a>可知，<spanclass="math inline">\(f\)</span>是单调的，若有<spanclass="math inline">\(x_1,x_2 \in [a,b]\)</span>，其中<spanclass="math inline">\(x_1 &lt; x_2\)</span>，使得<spanclass="math inline">\(f(x_1) = f(x_2)\)</span>，那么对<spanclass="math inline">\(x \in [x_1, x_2]\)</span>，有<spanclass="math inline">\(f(x_1) = f(x) = f(x_2)\)</span>。从而对<spanclass="math inline">\(x \in (x_1,x_2)\)</span>，有<spanclass="math inline">\(f^\prime = 0\)</span>，这与（2）矛盾，从而<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上严格单调。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，<spanclass="math inline">\(x_0 \in (a,b)\)</span>；<br />（1）如果存在正数<span class="math inline">\(\delta &gt;0\)</span>，使得在<span class="math inline">\((x_0 - \delta,x_0)\)</span>上<span class="math inline">\(f^\prime &gt;0\)</span>，而在<span class="math inline">\((x_0, x_0 +\delta)\)</span>上<span class="math inline">\(f^\prime &lt;0\)</span>，那么<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极大值，所谓严格极大值是指，当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>时，<spanclass="math inline">\(f(x) &lt; f(x_0)\)</span>；<br />（2）如果存在正数<span class="math inline">\(\delta &gt;0\)</span>，使得在<span class="math inline">\((x_0 - \delta,x_0)\)</span>上<span class="math inline">\(f^\prime &lt;0\)</span>，而在<span class="math inline">\((x_0, x_0 +\delta)\)</span>上<span class="math inline">\(f^\prime &gt;0\)</span>，那么<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极小值，所谓严格极小值是指，当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>时，<spanclass="math inline">\(f(x) &gt; f(x_0)\)</span>；</p></blockquote><p>证：这里只证（1），（2）是同样的证法。由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理2">定理2</a>可知，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([x_0-\delta, x_0]\)</span>上严格递增，所以当<spanclass="math inline">\(x \in (x_0-\delta, x_0)\)</span>时，<spanclass="math inline">\(f(x) &lt; f(x_0)\)</span>，而<spanclass="math inline">\(f\)</span>在<span class="math inline">\([x_0,x_0+\delta]\)</span>上严格递减，所以当<span class="math inline">\(x \in(x_0, x_0 + \delta)\)</span>时，<span class="math inline">\(f(x) &lt;f(x_0)\)</span>，即<spanclass="math inline">\(f(x_0)\)</span>是一个严格极大值。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，<spanclass="math inline">\(x_0 \in (a,b)\)</span>是<spanclass="math inline">\(f\)</span>的一个驻点，进一步假设<spanclass="math inline">\(f^{\prime\prime}(x_0)\)</span>存在，那么<br />（1）当<span class="math inline">\(f^{\prime\prime} &lt;0\)</span>时，<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极大值；<br />（2）当<span class="math inline">\(f^{\prime\prime} &gt;0\)</span>时，<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极小值。</p></blockquote><p>证：这里只证（1），（2）是同样的证法。因为<br /><span class="math display">\[    f^{\prime\prime}(x_0) = \lim \limits_{x \to x_0} \frac{f^\prime(x) -f^\prime(x_0)}{x - x_0} = \lim\limits_{x \to x_0}\frac{f^\prime(x)}{x-x_0} &lt; 0\]</span><br />从而存在一个<span class="math inline">\(\delta &gt;0\)</span>，使得当<span class="math inline">\(0 &lt; |x - x_0| &lt;\delta\)</span>时，有<br /><span class="math display">\[    \frac{f^\prime(x)}{x - x_0} &lt; 0\]</span><br />所以，当<span class="math inline">\(x \in (x_0, x_0 +\delta)\)</span>时，<span class="math inline">\(f^\prime(x) &lt;0\)</span>；而当<span class="math inline">\(x \in (x_0 - \delta,x_0)\)</span>时，<span class="math inline">\(f^\prime(x) &gt;0\)</span>，即<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>的一个严格极大值。</p><p>Q.E.D.</p><h4 id="定义1凸函数">定义1：凸函数</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上有定义，如果对任何<spanclass="math inline">\(x_1,x_2 \in I\)</span>，<spanclass="math inline">\(x_1\ne x_2\)</span>，以及任意的<spanclass="math inline">\(\lambda_1,\lambda_2 &gt; 0\)</span>，且<spanclass="math inline">\(\lambda_1 + \lambda_2 = 1\)</span>，都有<br /><span class="math display">\[    f(\lambda_1 x_1 + \lambda_2 x_2) \le \lambda_1 f(x_1) + \lambda_2f(x_2)\]</span><br />则称<span class="math inline">\(f\)</span>为<spanclass="math inline">\(I\)</span>上的凸函数，如果上述不等式的不等号总成立，则称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(I\)</span>上的严格凸函数。</p></blockquote><h4 id="定理7">定理7</h4><blockquote><p>设<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上是凸函数，则对任何的<spanclass="math inline">\(x_1,x_2,\cdots,x_n \in I\)</span>，以及<spanclass="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n &gt;0\)</span>，且<span class="math inline">\(\lambda _1+\lambda_2+\cdots+\lambda_n = 1\)</span>，都有<br /><span class="math display">\[    f(\sum_{i=1}^n \lambda_i x_i) \le \sum_{i=1}^n \lambda_i f(x_i)\]</span><br />如果<span class="math inline">\(f\)</span>是<spanclass="math inline">\(I\)</span>上的严格凸函数，则当<spanclass="math inline">\(x_1,x_2,\cdots,x_n\)</span>不全相等时，有<br /><span class="math display">\[    f(\sum_{i=1}^n \lambda_i x_i) &lt; \sum_{i=1}^n \lambda_i f(x_i)\]</span></p></blockquote><p>证：使用数学归纳法。当<spanclass="math inline">\(n=2\)</span>时，由凸函数定义知显然成立；设<spanclass="math inline">\(n = k\)</span>时命题成立，现在证<spanclass="math inline">\(n = k+1\)</span>时命题也成立。设<spanclass="math inline">\(x_1,x_2,\cdots,x_{k+1} \in I\)</span>，<spanclass="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_{k+1} &gt;0\)</span>，并且<span class="math inline">\(\lambda_1 + \lambda_2 +\cdots + \lambda_{k+1} = 1\)</span>，知<br /><span class="math display">\[    \lambda_1 + \lambda_2 + \cdots + \lambda_k = 1 - \lambda_{k+1}\Rightarrow \frac{\lambda_1}{1-\lambda_{k+1}} +\frac{\lambda_2}{1-\lambda_{k+1}} + \cdots +\frac{\lambda_k}{1-\lambda_{k+1}} = 1\]</span><br />令<span class="math inline">\(u_i = \frac{\lambda_i}{1-\lambda_{k+1}}(i=1,2\cdots,k)\)</span>，从而有<br /><span class="math display">\[    \begin{aligned}        f(\sum_{i=1}^{k+1} \lambda_i x_i) &amp; =f\left((1-\lambda_{k+1})\sum_{i=1}^k u_i x_i +\lambda_{k+1}x_{k+1}\right) \\        &amp; \le (1-\lambda_{k+1}) f(\sum_{i=1}^k u_ix_i) +\lambda_{k+1} f(x_{k+1}) \\        &amp; \le (1-\lambda_{k+1}) \sum_{i=1}^k u_i f(x_i) +\lambda_{k+1} f(x_{k+1}) \\        &amp; = \sum_{i=1}^{k+1} \lambda_i f(x_i)    \end{aligned}\]</span><br />从而当<span class="math inline">\(f\)</span>为<spanclass="math inline">\(I\)</span>上的凸函数时，对任何<spanclass="math inline">\(n \in\mathbb{N^{*}}\)</span>，不等式都成立。<br />再设<span class="math inline">\(f\)</span>是<spanclass="math inline">\(I\)</span>上的严格凸函数，同样当<spanclass="math inline">\(n=2\)</span>时，自然严格不等号成立。假设当<spanclass="math inline">\(n=k\)</span>时，严格不等号成立。现设<spanclass="math inline">\(x_1,x_2,\cdots,x_{k+1}\)</span>不全相等，有两种情况：<br />（1）<spanclass="math inline">\(x_1,x_2,\cdots,x_k\)</span>不全相等，则此时上述归纳法的最后一个不等号是严格的，<br />（2）<span class="math inline">\(x_1=x_2=\cdots=x_k \nex_{k+1}\)</span>，则<br /><span class="math display">\[    \sum_{i=1}^k u_ix_i = x_1 \ne x_{k+1}\]</span><br />此时上述归纳法的第一个不等号是严格的。从而对任何<spanclass="math inline">\(n \in\mathbb{N^+}\)</span>，最终不等式都是严格的。</p><p>Q.E.D.</p><h4 id="定理8jensen不等式">定理8：Jensen不等式</h4><blockquote><p>设<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上是凸函数，则对任何<spanclass="math inline">\(x_1,x_2,\cdots,x_n \inI\)</span>，以及对任何的正数<spanclass="math inline">\(\beta_1,\beta_2,\cdots,\beta_n\)</span>，有不等式<br /><span class="math display">\[    f(\sum_{i=1}^n \beta_i x_i / \sum_{i=1}^n \beta_n) \le\frac{\sum\limits_{i=1}^n \beta_i f(x_i)}{\sum\limits_{i=1}^n \beta_i}\]</span></p></blockquote><p>证：令<br /><span class="math display">\[    \lambda_i = \frac{\beta_i}{\sum\limits_{i=1}^n \beta_i} \quad(i=1,2,\cdots,n)\]</span><br />再由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理7">定理7</a>可证。</p><p>Q.E.D.</p><h4 id="定理9">定理9</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>是凸函数，当且仅当对任何<spanclass="math inline">\((x_1,x_2) \in I\)</span>及任何<spanclass="math inline">\(x \in (x_1,x_2)\)</span>，有<br /><span class="math display">\[    \frac{f(x) - f(x_1)}{x - x_1} \le \frac{f(x_2) - f(x_1)}{x_2 - x_1}\le \frac{f(x_2) - f(x)}{x_2 - x}\]</span><br />若<spanclass="math inline">\(f\)</span>是严格凸函数，当且仅当上述不等式是严格的。</p></blockquote><p>证：必要性。记<br /><span class="math display">\[    \lambda_1 = \frac{x_2 - x}{x_2 - x_1} \qquad \lambda_2 = \frac{x -x_1}{x_2 - x_1}\]</span><br />则有<span class="math inline">\(\lambda_1 &gt; 0, \lambda_2 &gt; 0,\lambda_1 + \lambda_2 = 1\)</span>，且<span class="math inline">\(x =\lambda_1 x_1 + \lambda_2 x_2\)</span>，<br />由凸函数的定义可知<br /><span class="math display">\[    \lambda_1 f(x) + \lambda_2 f(x) = f(x) = f(\lambda_1 x_1 + \lambda_2x_2) \le \lambda_1 f(x_1) + \lambda_2 f(x_2)\]</span><br />可得<br /><span class="math display">\[    \lambda_1 (f(x) - f(x_1)) \le \lambda_2 (f(x_2) - f(x)) \Rightarrow\frac{f(x) - f(x_1)}{x - x_1} \le \frac{f(x_2) - f(x)}{x_2 - x}\]</span></p><p>又易证得：若<span class="math inline">\(b&gt;0,d&gt;0,a/b \lec/d\)</span>，则有<br /><span class="math display">\[\frac{a}{b} \le \frac{a+c}{b+d} \le \frac{c}{d}\]</span><br />由以上性质，易得要证不等式成立，若<spanclass="math inline">\(f\)</span>是严格凸函数，那么上述证明中得不等号都是严格的。</p><p>充分性。必要性的证明倒推回去即可证。</p><p>Q.E.D.</p><h4 id="定理10">定理10</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上可导，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上为凸函数（严格凸函数）的充分必要条件是，<spanclass="math inline">\(f^\prime\)</span>在<spanclass="math inline">\((a,b)\)</span>上递增（严格递增）。</p></blockquote><p>证：必要性。设<span class="math inline">\((x_1,x_2) \subset(a,b)\)</span>，由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理9">定理9</a>可知，当<spanclass="math inline">\(x \in (x_1,x_2)\)</span>，有<br /><span class="math display">\[    \frac{f(x) - f(x_1)}{x - x_1} \le \frac{f(x_2) - f(x_1)}{x_2 - x_1}\le \frac{f(x_2) - f(x)}{x_2 - x}\]</span><br />左边不等式令<span class="math inline">\(x \to x_1^+\)</span>，得<br /><span class="math display">\[    f^\prime(x_1) \le \frac{f(x_2) - f(x_1)}{x_2 - x_1} \tag 1\]</span><br />右边不等式令<span class="math inline">\(x \to x_2^-\)</span>，得<br /><span class="math display">\[    \frac{f(x_2) - f(x_1)}{x_2 - x_1} \le f^\prime(x_2) \tag 2\]</span><br />从而有<br /><span class="math display">\[    f^\prime(x_1) \le f^\prime(x_2)\]</span><br />所以<span class="math inline">\(f^\prime\)</span>是递增的。<br />当<span class="math inline">\(f\)</span>是严格凸函数时，我们取<spanclass="math inline">\(x_1 &lt; x^* &lt; x_2\)</span>，由于<spanclass="math inline">\(x_1 &lt; x^*\)</span>，从而由式(1)可知<br /><span class="math display">\[    f^\prime(x_1) \le \frac{f(x^*) - f(x_1)}{x^* - x_1}\]</span><br />又由于<span class="math inline">\(x^* &lt;x_2\)</span>，从而有式(2)可知<br /><span class="math display">\[    \frac{f(x_2) - f(x^*)}{x_2 - x^*} \le f^\prime(x_2)\]</span><br />而再由<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理9">定理9</a>中严格凸函数的结论有<br /><span class="math display">\[    \frac{f(x^*) - f(x_1)}{x^* - x_1}  &lt; \frac{f(x_2) - f(x^*)}{x_2 -x^*}\]</span><br />从而得<span class="math inline">\(f^\prime(x_1) &lt;f^\prime(x_2)\)</span>，即<spanclass="math inline">\(f^\prime\)</span>是严格递增的。</p><p>充分性。设<span class="math inline">\(f^\prime\)</span>在<spanclass="math inline">\((a,b)\)</span>上递增，对任何<spanclass="math inline">\(x \in (x_1,x_2)\)</span>，有<br /><span class="math display">\[    \frac{f(x) - f(x_1)}{x - x_1} = f^\prime(\xi_1)  \qquad \frac{f(x_2)- f(x)}{x_2 - x} = f^\prime(\xi_2)\]</span><br />其中<span class="math inline">\(\xi_1 \in (x_1, x), \xi_2 \in (x,x_2)\)</span>，可知<span class="math inline">\(\xi_1 &lt; x &lt;\xi_2\)</span>，从而<span class="math inline">\(f^\prime(\xi_1) \lef^\prime(\xi_2)\)</span>，即<br /><span class="math display">\[    \frac{f(x) - f(x_1)}{x - x_1} \le \frac{f(x_2) - f(x)}{x_2 - x}\]</span><br />当<spanclass="math inline">\(f^\prime\)</span>严格递增时，上述不等式都是严格的，即得证。</p><p>Q.E.D.</p><h4 id="定理11">定理11</h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>上有二阶导数，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上为凸函数的充分必要条件是，<spanclass="math inline">\(f^{\prime\prime} \ge 0\)</span>在<spanclass="math inline">\((a,b)\)</span>上成立；而<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上为严格凸函数的充分必要条件是，<spanclass="math inline">\(f^{\prime\prime} \ge 0\)</span>在<spanclass="math inline">\((a,b)\)</span>上成立，且在<spanclass="math inline">\((a,b)\)</span>的任何开区间的子区间内<spanclass="math inline">\(f^{\prime\prime}\)</span>不恒等于<spanclass="math inline">\(0\)</span>。</p></blockquote><p>证：结合<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理1">定理1</a>和<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理10">定理10</a>易证得前半部分，结合<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理4">定理4</a>和<ahref="https://gamersover.github.io/2021/03/08/函数导数5/#定理10">定理10</a>易证得后半部分。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数四：L’Hospital法则</title>
      <link href="/2021/02/22/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B04/"/>
      <url>/2021/02/22/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B04/</url>
      
        <content type="html"><![CDATA[<h4 id="定理1">定理1</h4><blockquote><p>设函数<span class="math inline">\(f,g\)</span>在<spanclass="math inline">\((a,b)\)</span>上可导，并且<spanclass="math inline">\(g(x) \ne 0\)</span>对<span class="math inline">\(x\in (a,b)\)</span>成立。又设<br /><span class="math display">\[    \lim \limits_{x \to a^+} f(x) = \lim \limits_{x \to a^+} g(x) = 0\]</span><br />如果极限<br /><span class="math display">\[    \lim \limits_{x \to a^+} \frac{f^\prime(x)}{g^\prime(x)}\]</span><br />存在(或为<span class="math inline">\(\infty\)</span>)，那么便有<br /><span class="math display">\[    \lim \limits_{x \to a^+} \frac{f(x)}{g(x)} = \lim \limits_{x \toa^+} \frac{f^\prime(x)}{g^\prime(x)}\]</span></p></blockquote><span id="more"></span><p>证：补充定义<span class="math inline">\(f(a) = g(a) =0\)</span>，从而<span class="math inline">\(f,g\)</span>在<spanclass="math inline">\([a,b)\)</span>上连续，利用Cauchy中值定理，对<spanclass="math inline">\(x \in (a,b)\)</span>，有<br /><span class="math display">\[    \frac{f(x)}{g(x)} = \frac{f(x) - f(a)}{g(x) - g(a)} =\frac{f^\prime(\xi)}{g^\prime(\xi)}\]</span><br />这里<span class="math inline">\(a &lt; \xi &lt; x\)</span>，所以当<spanclass="math inline">\(x \to a^+\)</span>时，有<spanclass="math inline">\(\xi \to a^+\)</span>，从而<br /><span class="math display">\[    \lim\limits_{x \to a^+} \frac{f(x)}{g(x)} = \lim\limits_{\xi \toa^+} \frac{f^\prime(\xi)}{g^\prime(\xi)} = \lim\limits_{x \to a^+}\frac{f^\prime(x)}{g^\prime(x)}\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设函数<span class="math inline">\(f,g\)</span>在区间<spanclass="math inline">\((a,+\infty)\)</span>上可导，且<spanclass="math inline">\(g(x) \ne 0\)</span>对<span class="math inline">\(x\in (a, +\infty)\)</span>成立，并且<br /><span class="math display">\[    \lim\limits_{x \to +\infty} f(x) = \lim\limits_{x \to +\infty} g(x)= 0\]</span><br />那么当<span class="math inline">\(\lim \limits_{x \to +\infty}\frac{f^\prime(x)}{g^\prime(x)}\)</span>存在（或为<spanclass="math inline">\(\infty\)</span>）时，有<br /><span class="math display">\[    \lim \limits_{x \to +\infty} \frac{f(x)}{g(x)} = \lim \limits_{x \to+\infty} \frac{f^\prime(x)}{g^\prime(x)}\]</span></p></blockquote><p>证：令<span class="math inline">\(x = \frac{1}{t}\)</span>，则当<spanclass="math inline">\(x \to +\infty\)</span>相当于<spanclass="math inline">\(t \to 0^+\)</span>，这时，我们有<br /><span class="math display">\[    \lim\limits_{t \to 0^+} f\left(\frac{1}{t}\right) = \lim\limits_{t\to 0^+} g\left(\frac{1}{t}\right) = 0\]</span><br />由定理1可知<br /><span class="math display">\[\begin{aligned}    \lim\limits_{x \to +\infty} \frac{f(x)}{g(x)} = \lim\limits_{t \to0^+} \frac{f\left(\frac{1}{t}\right)}{g\left(\frac{1}{t}\right)} =\frac{f^\prime\left(\frac{1}{t}\right)\left(-\frac{1}{t^2}\right)}{g^\prime\left(\frac{1}{t}\right)\left(-\frac{1}{t^2}\right)}\\ = \lim\limits_{t \to 0^+}\frac{f^\prime\left(\frac{1}{t}\right)}{g^\prime\left(\frac{1}{t}\right)}= \lim\limits_{x \to +\infty} \frac{f^\prime(x)}{g^\prime(x)}\end{aligned}\]</span></p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设函数<span class="math inline">\(f,g\)</span>在<spanclass="math inline">\((a,b)\)</span>上可导，<spanclass="math inline">\(g(x) \ne 0\)</span>，且<br /><span class="math display">\[    \lim\limits_{x \to a^+} g(x) = \infty\]</span><br />如果极限<span class="math inline">\(\lim \limits_{x \to a^+}\frac{f^\prime(x)}{g^\prime(x)}\)</span>存在（或为<spanclass="math inline">\(\infty\)</span>），那么<br /><span class="math display">\[    \lim \limits_{x \to a^+} \frac{f(x)}{g(x)} = \lim \limits_{x \toa^+} \frac{f^\prime(x)}{g^\prime(x)}\]</span></p></blockquote><p>证：令<br /><span class="math display">\[    l = \lim\limits_{x \to a^+} \frac{g^\prime(x)}{g^\prime(x)}\]</span><br />不妨设<span class="math inline">\(l\)</span>为有限数，则对任意的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(x \in (a, a+\delta)\)</span>时，有<br /><span class="math display">\[    l - \varepsilon &lt; \frac{f^\prime(x)}{g^\prime(x)} &lt; l +\varepsilon\]</span><br />从而对<span class="math inline">\((x,c) \in (a,a+\delta)\)</span>，由Cauchy中值定理可知，必存在<spanclass="math inline">\(\xi \in (x,c)\)</span>使得<br /><span class="math display">\[    l - \varepsilon &lt; \frac{f(x) - f(c)}{g(x) - g(c)} =\frac{f^\prime(\xi)}{g^\prime(\xi)} &lt; l + \varepsilon\]</span><br />又因为<br /><span class="math display">\[    \frac{f(x)-f(c)}{g(x) - g(c)} = \left( \frac{f(x)}{g(x)} -\frac{f(c)}{g(x)}\right) \left(1 - \frac{g(c)}{g(x)}\right)^{-1}\]</span><br />固定<span class="math inline">\(c\)</span>，对<spanclass="math inline">\(x \to a^+\)</span>取上极限，得<br /><span class="math display">\[    \limsup_{x \to a^+} \frac{f(x)}{g(x)} \le l + \varepsilon\]</span><br />再令<span class="math inline">\(\varepsilon \to 0\)</span>，得<br /><span class="math display">\[    \limsup_{x \to a^+} \frac{f(x)}{g(x)} \le l\]</span><br />利用同样得方式，可得<br /><span class="math display">\[    \liminf_{x \to a^+} \frac{f(x)}{g(x)} \ge l\]</span><br />从而有<br /><span class="math display">\[    \lim\limits_{x \to a^+} \frac{f(x)}{g(x)} = l\]</span></p><p>当<span class="math inline">\(l\)</span>为<spanclass="math inline">\(-\infty\)</span>或<spanclass="math inline">\(+\infty\)</span>也可使用类似得方法证明。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 洛必达法则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学试题一：初中篇</title>
      <link href="/2021/02/20/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%981/"/>
      <url>/2021/02/20/%E6%95%B0%E5%AD%A6%E8%AF%95%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h4 id="几何题">几何题</h4><p><span class="math inline">\(1.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB=AC\)</span>，点<spanclass="math inline">\(D\)</span>在线段<spanclass="math inline">\(BC\)</span>上，且<spanclass="math inline">\(\angle BAD = 20^\circ\)</span>，点<spanclass="math inline">\(E\)</span>在线段<spanclass="math inline">\(AC\)</span>上，且<span class="math inline">\(AE =AD\)</span>，求<span class="math inline">\(\angle CDE\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3m0ztdhm7mo0.png" width="20%"><br /><span id="more"></span></p><p><span class="math inline">\(2.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，点<spanclass="math inline">\(D,E\)</span>分别是<spanclass="math inline">\(AC,BC\)</span>的中点，点<spanclass="math inline">\(F\)</span>在线段<spanclass="math inline">\(AB\)</span>上，且<spanclass="math inline">\(BF=\frac{1}{3}AB\)</span>，<spanclass="math inline">\(BD\)</span>与<spanclass="math inline">\(CF\)</span>相交于点<spanclass="math inline">\(G\)</span>，连接<spanclass="math inline">\(EG\)</span>；<br />（1）证：<span class="math inline">\(EG \parallel AC\)</span>。<br />（2）求<span class="math inline">\(\displaystyle \frac{S_{\triangleBFG}}{S_{\triangle BEG}}\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3yab6h8om400.png" width="25%"></p><p><span class="math inline">\(3.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(\angle BAC\)</span>的角平分线<spanclass="math inline">\(AD\)</span>交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，点<spanclass="math inline">\(E\)</span>是<spanclass="math inline">\(BC\)</span>的中点，过点<spanclass="math inline">\(E\)</span>作<span class="math inline">\(EG\parallel AD\)</span>交<span class="math inline">\(AB\)</span>于点<spanclass="math inline">\(F\)</span>，交<spanclass="math inline">\(CA\)</span>的延长线于点<spanclass="math inline">\(G\)</span>。证：<span class="math inline">\(BF =CG\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5624mi9lzn40.png" width="25%"></p><p><span class="math inline">\(4.\)</span> 在<spanclass="math inline">\(Rt\triangle ABC\)</span>中，<spanclass="math inline">\(\angle ACB = 90^\circ\)</span>，点<spanclass="math inline">\(D\)</span>在<spanclass="math inline">\(AB\)</span>上，且<span class="math inline">\(CD\perp AB\)</span>，<span class="math inline">\(AE\)</span>平分<spanclass="math inline">\(\angle BAC\)</span>交<spanclass="math inline">\(CD\)</span>于点<spanclass="math inline">\(K\)</span>，交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(E\)</span>，<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(BE\)</span>上的点，且<spanclass="math inline">\(BF=CE\)</span>，证：<span class="math inline">\(FK\parallel AB\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.1znoa8xpzv28.png" width="25%"></p><p><span class="math inline">\(5.\)</span> <spanclass="math inline">\(EFGH\)</span>是正方形<spanclass="math inline">\(ABCD\)</span>的内接四边形，其中点<spanclass="math inline">\(E,F,G,H\)</span>分别在线段<spanclass="math inline">\(AB,BC,CD,DA\)</span>中，<spanclass="math inline">\(\angle BEG,\angle CFH\)</span>都是锐角，已知<spanclass="math inline">\(EG=3,FH=4\)</span>，四边形<spanclass="math inline">\(EFGH\)</span>的面积为<spanclass="math inline">\(5\)</span>，求正方形<spanclass="math inline">\(ABCD\)</span>的面积。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4oasv01zcqw0.png" width="25%"></p><p><span class="math inline">\(6.\)</span> 平行四边形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(BC=2AB\)</span>，<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(AD\)</span>的中点，点<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(AB\)</span>上，且<span class="math inline">\(CE\perp AB\)</span>，求<span class="math inline">\(\angle DME : \angleAEM\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6va1qkqldsk0.png" width="30%"></p><p><span class="math inline">\(7.\)</span> 矩形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AB=a,BC=b\)</span>，点<spanclass="math inline">\(E,F\)</span>分别在<spanclass="math inline">\(AB,BC\)</span>上，定义<spanclass="math inline">\(S_1=S_{\triangle DAE},S_2=S_{\triangleCDF},S_3=S_{\triangle BEF},S_4=S_{\triangle DEF}\)</span>，如果<spanclass="math inline">\(\displaystyle S_1=S_2=\frac{1}{2} (S_3 +S_4)\)</span>，求<span class="math inline">\(S_4\)</span>（用<spanclass="math inline">\(a,b\)</span>表示）。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2f4ooc66bjk0.png" width="25%"></p><p><span class="math inline">\(8.\)</span> 平行四边形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(BC\)</span>的中点，且<spanclass="math inline">\(AM=9,BD=12,AD=10\)</span>，求平行四边形<spanclass="math inline">\(ABCD\)</span>的面积。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/No.8.png" width="25%"></p><p><span class="math inline">\(9.\)</span> 平行四边形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AB=5,AD=8\)</span>，<spanclass="math inline">\(\angle BAD,\angleADC\)</span>的角平分线分别交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(E,F\)</span>，求<spanclass="math inline">\(EF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/截屏2021-11-16-下午1.05.36.4k5j37rkpkm0.png" width="30%"></p><p><span class="math inline">\(10.\)</span> <spanclass="math inline">\(\triangle ABC\)</span>是<spanclass="math inline">\(\bigodot O\)</span>的内接三角形，且<spanclass="math inline">\(AC=BC\)</span>，点<spanclass="math inline">\(D\)</span>在<span class="math inline">\(\bigodotO\)</span>上，延长<span class="math inline">\(DA\)</span>至点<spanclass="math inline">\(E\)</span>，使<spanclass="math inline">\(CE=CD\)</span>；<br />（1）证：<span class="math inline">\(AE=BD\)</span>。<br />（2）若<span class="math inline">\(AC \perp BC\)</span>，证：<spanclass="math inline">\(AD+BD = \sqrt 2 CD\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/截屏2021-11-16-下午1.39.17.5mu0amvppwg0.png" width="25%"></p><p><span class="math inline">\(11.\)</span> 在三角形<spanclass="math inline">\(ABC\)</span>中，点<spanclass="math inline">\(O\)</span>是<spanclass="math inline">\(AC\)</span>上的一个动点，过点<spanclass="math inline">\(O\)</span>作直线<span class="math inline">\(MN\parallel BC\)</span>，设<span class="math inline">\(MN\)</span>交<spanclass="math inline">\(\triangle BCA\)</span>的角平分线于点<spanclass="math inline">\(E\)</span>，交<spanclass="math inline">\(\triangle BCA\)</span>的外角平行线于点<spanclass="math inline">\(F\)</span>；<br />（1）证：<span class="math inline">\(OE=OF\)</span>。<br />（2）点<span class="math inline">\(O\)</span>在何处时，四边形<spanclass="math inline">\(AECF\)</span>是矩形？<br />（3）若<span class="math inline">\(AC\)</span>上存在点<spanclass="math inline">\(O\)</span>使四边形<spanclass="math inline">\(AECF\)</span>是正方形，且$ = <spanclass="math inline">\(，求\)</span>B$的大小。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/截屏2021-11-16-下午1.57.58.46n7smzyjp00.png" width="30%"></p><p><span class="math inline">\(12.\)</span> 三角形<spanclass="math inline">\(ABC\)</span>中，<spanclass="math inline">\(AB=5,AC=3\)</span>，<spanclass="math inline">\(D\)</span>为<spanclass="math inline">\(BC\)</span>的中点，<spanclass="math inline">\(AD=2\)</span>，求<spanclass="math inline">\(BC\)</span>的长。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.41jnicx25vo.png" width="40%"></p><p><span class="math inline">\(13.\)</span> <spanclass="math inline">\(Rt\triangle ABC\)</span>中，<spanclass="math inline">\(\angle C = 90^\circ\)</span>，点<spanclass="math inline">\(M\)</span>是<spanclass="math inline">\(BC\)</span>的中点，点<spanclass="math inline">\(D\)</span>在<spanclass="math inline">\(AB\)</span>上，<span class="math inline">\(MD\perp AB\)</span>，证：<span class="math inline">\(AC^2 + BD^2 =AD^2\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6w6n19d0ayo0.png" width="30%"></p><p><span class="math inline">\(14.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB=AC\)</span>，点<spanclass="math inline">\(P\)</span>是<spanclass="math inline">\(BC\)</span>上一点，证：<spanclass="math inline">\(PA^2 + PB\cdot PC = AB^2\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4gb6s2x5av00.png" width="20%"></p><p><span class="math inline">\(15.\)</span> 点<spanclass="math inline">\(P\)</span>是<span class="math inline">\(\triangleABC\)</span>内一点，<span class="math inline">\(PD \perpAB\)</span>于点<span class="math inline">\(D\)</span>，<spanclass="math inline">\(PE \perp BC\)</span>于点<spanclass="math inline">\(E\)</span>，<span class="math inline">\(PF \perpAC\)</span>于点<span class="math inline">\(F\)</span>，证：<spanclass="math inline">\(AD^2 + BE^2 + CF^2 = AF^2 + BD^2 +CE^2\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4xk3omzsyuk0.png" width="22%"></p><p><span class="math inline">\(16.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(BD \perp AC\)</span>于点<spanclass="math inline">\(D\)</span>，<span class="math inline">\(CE \perpAB\)</span>于点<span class="math inline">\(E\)</span>，点<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(BD\)</span>上，且<spanclass="math inline">\(BF=AC\)</span>，点<spanclass="math inline">\(G\)</span>在<spanclass="math inline">\(CE\)</span>的延长线上，且<spanclass="math inline">\(CG = AB\)</span>，证：<spanclass="math inline">\(AG \perp AF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.16zyvh2in0u8.png" width="25%"></p><p><span class="math inline">\(17.\)</span> 在等腰<spanclass="math inline">\(Rt \triangle ABC\)</span>中，<spanclass="math inline">\(\angle A = 90^\circ\)</span>，<spanclass="math inline">\(\angle ABC\)</span>的角平分线<spanclass="math inline">\(BD\)</span>交<spanclass="math inline">\(AC\)</span>于点<spanclass="math inline">\(D\)</span>，点<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(BC\)</span>上，且<spanclass="math inline">\(\angle CDE = 45^\circ\)</span>，连接<spanclass="math inline">\(AE\)</span>，证：<span class="math inline">\(AE\perp BD\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4qnvhgvls6q0.png" width="30%"></p><p><span class="math inline">\(18.\)</span> 点<spanclass="math inline">\(E\)</span>为平行四边形<spanclass="math inline">\(ABCD\)</span>的边<spanclass="math inline">\(BC\)</span>上一动点，<spanclass="math inline">\(DE\)</span>交直线<spanclass="math inline">\(AB\)</span>于点<spanclass="math inline">\(F\)</span>，连接<spanclass="math inline">\(AE,CF\)</span>；<br />（1）<span class="math inline">\(\triangle ABE\)</span>与<spanclass="math inline">\(\triangle CEF\)</span>的面积有何关系？<br />（2）若<span class="math inline">\(E\)</span>在<spanclass="math inline">\(CB\)</span>的延长线上，（1）的结论依然成立吗？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3k8ehmsk8s40.png" width="60%"></p><p><span class="math inline">\(19.\)</span> <spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB=5,AC=11\)</span>，<spanclass="math inline">\(\triangle BAC\)</span>的角平分线<spanclass="math inline">\(AD\)</span>交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，点<spanclass="math inline">\(E\)</span>为<spanclass="math inline">\(BC\)</span>的中点，过点<spanclass="math inline">\(E\)</span>作<span class="math inline">\(EF\parallel AD\)</span>交<span class="math inline">\(AC\)</span>于点<spanclass="math inline">\(F\)</span>，求<spanclass="math inline">\(CF\)</span>的长。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3524gyskygc0.png" width="35%"></p><p><span class="math inline">\(20.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，点<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(AB\)</span>上，<spanclass="math inline">\(AE:EB=1:3\)</span>，点<spanclass="math inline">\(D\)</span>在<spanclass="math inline">\(BC\)</span>上，<spanclass="math inline">\(BD:DC=2:1\)</span>，<spanclass="math inline">\(AD\)</span>与<spanclass="math inline">\(CE\)</span>相交于点<spanclass="math inline">\(F\)</span>，则<spanclass="math inline">\(\displaystyle \frac{EF}{FC} +\frac{AF}{FD}\)</span>的值为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.42x3wpnk5tw0.png" width="20%"></p><p><span class="math inline">\(21.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB &gt; AC\)</span>，<spanclass="math inline">\(AD\)</span>平分<span class="math inline">\(\angleBAC\)</span>且交<span class="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，<span class="math inline">\(EF \perpAD\)</span>交<span class="math inline">\(AB\)</span>于点<spanclass="math inline">\(E\)</span>，交<spanclass="math inline">\(AC\)</span>于点<spanclass="math inline">\(F\)</span>，交<spanclass="math inline">\(AD\)</span>于点<spanclass="math inline">\(G\)</span>，交<spanclass="math inline">\(BC\)</span>的延长线于点<spanclass="math inline">\(M\)</span>，证：<spanclass="math inline">\(\displaystyle \angle M = \frac{1}{2} (\angle ACB -\angle B)\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.roypk736hnk.png" width="30%"></p><p><span class="math inline">\(22.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AD\)</span>是<span class="math inline">\(\angleBAC\)</span>的角平分线且交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，若<span class="math inline">\(AB + BD= 25, AC - CD = 4\)</span>，则<spanclass="math inline">\(AD\)</span>为多少？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.1h14ukokk8kg.png" width="25%"></p><p><span class="math inline">\(23.\)</span> 如图，在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(DE \parallel FG \parallel BC\)</span>，<spanclass="math inline">\(GI \parallel EF \parallel AB\)</span>，若<spanclass="math inline">\(S_{\triangle ADE} = 20, S_{\triangle EFG} = 45,S_{\triangle GIC} = 80\)</span>，则<spanclass="math inline">\(S_{\triangle ABC}\)</span>是多少？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.j0fthnbfyds.png" width="25%"></p><p><span class="math inline">\(24.\)</span> 在梯形<spanclass="math inline">\(ABCD\)</span>中，<span class="math inline">\(AD\parallel BC\)</span>，<span class="math inline">\(AC \perpBD\)</span>，已知<span class="math inline">\(AD:BC=3:4\)</span>，则<spanclass="math inline">\(BD:AC\)</span>的值为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.7c4vqzqi4s00.png" width="25%"></p><p><span class="math inline">\(25.\)</span> 如图，六边形<spanclass="math inline">\(ABCDEF\)</span>由<spanclass="math inline">\(6\)</span>个全等的正方形组成，正方形边长为<spanclass="math inline">\(1\)</span>，过点<spanclass="math inline">\(A\)</span>的一条直线分别与<spanclass="math inline">\(ED,CD\)</span>交于<spanclass="math inline">\(M,N\)</span>，若这个六边形在<spanclass="math inline">\(MN\)</span>两侧的部分面积相等，则<spanclass="math inline">\(EM\)</span>的长度是？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2uagyymv2js0.png" width="25%"></p><p><span class="math inline">\(26.\)</span> 正方形<spanclass="math inline">\(ABCD\)</span>的边<spanclass="math inline">\(AB=12\)</span>，点<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(CD\)</span>上，且<spanclass="math inline">\(DE=5\)</span>，点<spanclass="math inline">\(M\)</span>在<spanclass="math inline">\(AE\)</span>上，且<spanclass="math inline">\(EM=5\)</span>，过点<spanclass="math inline">\(M\)</span>的线段<span class="math inline">\(PQ\perp AE\)</span>分别交<spanclass="math inline">\(AD,BC\)</span>于点<spanclass="math inline">\(P,Q\)</span>，则<spanclass="math inline">\(PM:MQ\)</span>为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.1zk14p6fh4io.png" width="20%"></p><p><span class="math inline">\(27.\)</span> <spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AD\)</span>是<spanclass="math inline">\(BC\)</span>边上的中线，点<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(AD\)</span>上，且<spanclass="math inline">\(AF:FD=1:5\)</span>，连接<spanclass="math inline">\(CF\)</span>并延交<spanclass="math inline">\(AB\)</span>于点<spanclass="math inline">\(E\)</span>，则<spanclass="math inline">\(AE:EB\)</span>为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5nqei4ccgk80.png" width="25%"></p><p><span class="math inline">\(28.\)</span> 在梯形<spanclass="math inline">\(ABCD\)</span>中，<span class="math inline">\(AD\parallel BC\)</span>，<span class="math inline">\(EH \parallelBC\)</span>分别交<spanclass="math inline">\(AB,BD,AC,CD\)</span>于点<spanclass="math inline">\(E,F,G,H\)</span>，且<spanclass="math inline">\(BC=a,AD=b (a &gt; b)\)</span>，<spanclass="math inline">\(AE:EB=3:2\)</span>，则<spanclass="math inline">\(FG\)</span>为？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4m5lt9o5llw0.png" width="25%"></p><p><span class="math inline">\(29.\)</span> 设<spanclass="math inline">\(P,M,N\)</span>分别是<spanclass="math inline">\(\triangle ABC\)</span>的边<spanclass="math inline">\(BC,CA,AB\)</span>上的点，且<spanclass="math inline">\(AP,BM,CN\)</span>三线共点，证<spanclass="math inline">\(\displaystyle \frac{AN}{NB} \cdot \frac{BP}{CP} =\frac{AM}{MC}\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6afk041ri8k0.png" width="25%"></p><p><span class="math inline">\(30.\)</span> 已知<spanclass="math inline">\(M,N\)</span>为<spanclass="math inline">\(\triangle ABC\)</span>的边<spanclass="math inline">\(BC\)</span>上的两点，且满足<spanclass="math inline">\(BM=MN=NC\)</span>，一条平行于<spanclass="math inline">\(AC\)</span>的直线分别交<spanclass="math inline">\(AB,AM\)</span>和<spanclass="math inline">\(AN\)</span>的延长线于点<spanclass="math inline">\(D,E,F\)</span>，证<spanclass="math inline">\(EF=3DE\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6b4yjboq9kc0.png" width="25%"></p><p><span class="math inline">\(31.\)</span> 已知<spanclass="math inline">\(\triangle ABC\)</span>和<spanclass="math inline">\(\triangle A_1B_1C_1\)</span>均为正三角形，<spanclass="math inline">\(BC\)</span>和<spanclass="math inline">\(B_1C_1\)</span>的中点均为<spanclass="math inline">\(D\)</span>，证<span class="math inline">\(AA_1\perp CC_1\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.69nse9xmwjw0.png" width="25%"></p><p><span class="math inline">\(32.\)</span> 如图，在<spanclass="math inline">\(\triangle ABC\)</span>内部选取一点<spanclass="math inline">\(P\)</span>，过点<spanclass="math inline">\(P\)</span>作三条分别与<spanclass="math inline">\(\triangleABC\)</span>的三边平行的直线，这样所得的三角形<spanclass="math inline">\(t_1,t_2,t_3\)</span>的面积分别为<spanclass="math inline">\(4, 9, 49\)</span>，求<spanclass="math inline">\(S_{\triangle ABC}\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5jhl4evm4f80.png" width="28%"></p><p><span class="math inline">\(33.\)</span> 点<spanclass="math inline">\(E\)</span>是四边形<spanclass="math inline">\(ABCD\)</span>的对角线<spanclass="math inline">\(BD\)</span>上一点，且<spanclass="math inline">\(\angle BAC=\angle BDC=\angle DAE\)</span>，<br />（1）证：<span class="math inline">\(BE \cdot AD = CD \cdotAE\)</span>；<br />（2）猜想<span class="math inline">\(\displaystyle\frac{BC}{DE}\)</span>可能等于哪两条线段之比？注：只需写出一组比？并证明你的猜想。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.1uetjkghwlcw.webp" width="26%"></p><p><span class="math inline">\(34.\)</span> 在<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(\angle BAC = 120^\circ\)</span>，<spanclass="math inline">\(AD \perp BC\)</span>并交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(D\)</span>，且<spanclass="math inline">\(AB+BD=DC\)</span>，则<spanclass="math inline">\(\angle C=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6vwlh46f4700.png" width="35%"></p><p><span class="math inline">\(35.\)</span> <spanclass="math inline">\(BM\)</span>和<spanclass="math inline">\(CM\)</span>分别是<spanclass="math inline">\(\triangle ABC\)</span>的内角<spanclass="math inline">\(ABC\)</span>和外角<spanclass="math inline">\(ACD\)</span>的角平分线，<spanclass="math inline">\(ME \parallel BC\)</span>交<spanclass="math inline">\(AB\)</span>于点<spanclass="math inline">\(E\)</span>，交<spanclass="math inline">\(AC\)</span>于点<spanclass="math inline">\(F\)</span>，证<span class="math inline">\(EF = BE- CF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.gtyou5lzc0w.png" width="30%"></p><p><span class="math inline">\(36.\)</span> 在等腰<spanclass="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(AB=AC\)</span>，点<spanclass="math inline">\(D,E\)</span>在线段<spanclass="math inline">\(BC\)</span>上，且<spanclass="math inline">\(BD=DE=EC\)</span>，证<spanclass="math inline">\(\angle BAD &lt; \angle DAE\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5xgfxcyceb00.png" width="25%"></p><p><span class="math inline">\(37.\)</span> 如图，已知<spanclass="math inline">\(BE\)</span>是<span class="math inline">\(\angleABD\)</span>的角平分线，<span class="math inline">\(CF\)</span>是<spanclass="math inline">\(\angle ACD\)</span>的角平分线，<spanclass="math inline">\(BE\)</span>与<spanclass="math inline">\(CF\)</span>交于点<spanclass="math inline">\(G\)</span>，若<span class="math inline">\(\angleBDC=140^\circ,\angle BGC=110^\circ\)</span>，则<spanclass="math inline">\(\angle A=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.1ta94gpijew0.png" width="25%"></p><p><span class="math inline">\(38.\)</span> 已知<spanclass="math inline">\(\angle xOy = 90^\circ\)</span>，点<spanclass="math inline">\(A,B\)</span>分别在射线<spanclass="math inline">\(Ox,Oy\)</span>上移动，<spanclass="math inline">\(BE\)</span>是<span class="math inline">\(\angleABy\)</span>的角平分线，<spanclass="math inline">\(BE\)</span>的反向延长线与<spanclass="math inline">\(\angle OAB\)</span>的角平分线交于点<spanclass="math inline">\(C\)</span>。试问<span class="math inline">\(\angleACB\)</span>的大小是否变化，如果保持不变，请证明；如果变化，请求出变化范围。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5oz095olj500.png" width="30%"></p><p><span class="math inline">\(39.\)</span> 点<spanclass="math inline">\(D,F\)</span>分别是<spanclass="math inline">\(\triangle ABC\)</span>的边<spanclass="math inline">\(AB,AC\)</span>上的点，且<spanclass="math inline">\(AD:DB=CF:FA=2:3\)</span>，<spanclass="math inline">\(DF\)</span>延长线交<spanclass="math inline">\(BC\)</span>的延长线于点<spanclass="math inline">\(E\)</span>，则<spanclass="math inline">\(EF:FD=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6aev6uj85ns0.png" width="25%"></p><p><span class="math inline">\(40.\)</span> 已知矩形<spanclass="math inline">\(ABCD\)</span>的边长<spanclass="math inline">\(AB=2,BC=3\)</span>，点<spanclass="math inline">\(P\)</span>是<spanclass="math inline">\(AD\)</span>边上的一动点，<spanclass="math inline">\(Q\)</span>是<spanclass="math inline">\(BC\)</span>边上的任意一点，连接<spanclass="math inline">\(AQ,DQ\)</span>，过点<spanclass="math inline">\(P\)</span>作<span class="math inline">\(PE\parallel DQ\)</span>交<span class="math inline">\(AQ\)</span>于点<spanclass="math inline">\(E\)</span>，作<span class="math inline">\(PF\parallel AQ\)</span>交<span class="math inline">\(DQ\)</span>于点<spanclass="math inline">\(F\)</span>，<br />（1）设<span class="math inline">\(AP\)</span>的长为<spanclass="math inline">\(x\)</span>，试求<spanclass="math inline">\(S_{\triangle PEF}\)</span>关于<spanclass="math inline">\(x\)</span>的函数式，并求当<spanclass="math inline">\(P\)</span>在何处时，<spanclass="math inline">\(S_{\trianglePEF}\)</span>取最大值，最大值是多少？<br />（2）当<span class="math inline">\(Q\)</span>在何处时，<spanclass="math inline">\(\triangle ADQ\)</span>的周长最小？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6frnpycvung0.png" width="25%"></p><p><span class="math inline">\(41.\)</span> 在矩形<spanclass="math inline">\(ABCD\)</span>中，点<spanclass="math inline">\(E\)</span>为<spanclass="math inline">\(AD\)</span>的中点，点<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(AB\)</span>上且<span class="math inline">\(EF\perp EC\)</span>，连接<span class="math inline">\(FC\)</span>，<spanclass="math inline">\((AB &gt; AE)\)</span>，<br />（1）<span class="math inline">\(\triangle AEF \sim \triangleECF\)</span>成立吗？若成立，请证明；否则，请说明理由。<br />（2）设<span class="math inline">\(\displaystyle\frac{AB}{BC}=k\)</span>，是否存在这样的<spanclass="math inline">\(k\)</span>使得<spanclass="math inline">\(\triangle AEF \sim \triangleBCF\)</span>？若存在，证明之并求出<spanclass="math inline">\(k\)</span>；否则，请说明理由。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4zgtvz42r680.png" width="20%"></p><p><span class="math inline">\(42.\)</span> 点<spanclass="math inline">\(M\)</span>为<span class="math inline">\(\triangleABC\)</span>的边<span class="math inline">\(BC\)</span>的中点，截线<spanclass="math inline">\(PQ\)</span>分别交<spanclass="math inline">\(AB,AM,AC\)</span>于点<spanclass="math inline">\(P,N,Q\)</span>，求证<spanclass="math inline">\(\displaystyle \frac{AB}{AP} + \frac{AC}{AQ} =2\frac{AM}{AN}\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.7i1yhmm04sw0.png" width="25%"></p><p><span class="math inline">\(43.\)</span> 点<spanclass="math inline">\(M\)</span>为正方形<spanclass="math inline">\(ABCD\)</span>的边<spanclass="math inline">\(AB\)</span>上一点，<span class="math inline">\(BP\perp CM\)</span>于点<span class="math inline">\(P\)</span>，<spanclass="math inline">\(N\)</span>为<spanclass="math inline">\(BC\)</span>上一点，且<spanclass="math inline">\(BM=BN\)</span>，求证<span class="math inline">\(PD\perp PN\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.319r20rcagu0.png" width="25%"></p><p><span class="math inline">\(44.\)</span> 四边形<spanclass="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AC,BD\)</span>相交于点<spanclass="math inline">\(O\)</span>，过点<spanclass="math inline">\(O\)</span>作<spanclass="math inline">\(AB\)</span>的平行线分别交<spanclass="math inline">\(AD,BC\)</span>以及<spanclass="math inline">\(DC\)</span>的延长线于点<spanclass="math inline">\(E,F,G\)</span>，求证<spanclass="math inline">\(GO^2 = GE\cdot GF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.xtthc2o9eu8.png" width="30%"></p><p>$45. $ 在平行四边形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(O_1,O_2,O_3\)</span>为<spanclass="math inline">\(BD\)</span>上三点，且<spanclass="math inline">\(BO_1=O_1O_2=O_2O_3=O_3D\)</span>，连接<spanclass="math inline">\(AO_1\)</span>并延长交<spanclass="math inline">\(BC\)</span>于点<spanclass="math inline">\(E\)</span>，连接<spanclass="math inline">\(EO_3\)</span>并延长交<spanclass="math inline">\(AD\)</span>于点<spanclass="math inline">\(F\)</span>，则<spanclass="math inline">\(AD:FD=?\)</span></p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.560r00h9b0k0.webp" width="30%"></p><p>$46. $ 在等腰直角三角形<spanclass="math inline">\(BAC\)</span>中，<span class="math inline">\(\angleA = 90^\circ\)</span>, <span class="math inline">\(AB=1\)</span>，<spanclass="math inline">\(E\)</span>为<spanclass="math inline">\(AC\)</span>的中点，点<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(BC\)</span>上，且<span class="math inline">\(EF\perp BE\)</span>，求<span class="math inline">\(\triangleCEF\)</span>的面积。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.39wwblp9b6s0.webp" width="30%"></p><p>$47. $ 在梯形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AD \parallel BC\)</span>，<spanclass="math inline">\(AB=DC=3\)</span>，点<spanclass="math inline">\(P\)</span>是<spanclass="math inline">\(BC\)</span>上一点，<span class="math inline">\(PE\parallel AB\)</span> 交<span class="math inline">\(AC\)</span>与点<spanclass="math inline">\(E\)</span>，<span class="math inline">\(PF\parallel CD\)</span>交<span class="math inline">\(BD\)</span>于点<spanclass="math inline">\(F\)</span>，令<spanclass="math inline">\(m=PE,n=PF,x=m+n\)</span>，那么当<spanclass="math inline">\(P\)</span>在<spanclass="math inline">\(BC\)</span>上移动时，<spanclass="math inline">\(x\)</span>的值是否变化，如果变化，求出<spanclass="math inline">\(x\)</span>的取值范围，否则，求出<spanclass="math inline">\(x\)</span>的值，并说明理由。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.4ilp8rhcss80.webp" width="30%"></p><p>$48. $ 设点<span class="math inline">\(P\)</span>是等边三角形<spanclass="math inline">\(ABC\)</span>的边<spanclass="math inline">\(BC\)</span>上任一点，连接<spanclass="math inline">\(AP\)</span>并作<spanclass="math inline">\(AP\)</span>的中垂线交<spanclass="math inline">\(AB\)</span>与<spanclass="math inline">\(AC\)</span>分别于点<spanclass="math inline">\(M,N\)</span>，求证<spanclass="math inline">\(BP\cdot PC=BM\cdot CN\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5yxwp9vkaxo0.webp" width="25%"></p><p>$49. $ 正方形<span class="math inline">\(GEFD\)</span>内接于<spanclass="math inline">\(\triangle ABC\)</span>，若<spanclass="math inline">\(\angle C=90^\circ\)</span>，<spanclass="math inline">\(AC=b,AB=c,BC=a\)</span>，则<spanclass="math inline">\(AD:DE:EB=?\)</span></p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2rfrug3rl240.webp" width="32%"></p><p>$50. $ <span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(E,D\)</span>是边<spanclass="math inline">\(BC\)</span>上两点，若<spanclass="math inline">\(AD=AE\)</span>，<span class="math inline">\(\angleBAD = \angle C\)</span>，<spanclass="math inline">\(AC=6\)</span>，<spanclass="math inline">\(CE=4\)</span>，则<spanclass="math inline">\(BE=?\)</span></p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5w819kyc0eo0.webp" width="30%"></p><p>$51. $ <span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(F\)</span>是<spanclass="math inline">\(AC\)</span>的中点，<spanclass="math inline">\(DE\)</span>是<spanclass="math inline">\(BC\)</span>的三等分点，<spanclass="math inline">\(BF\)</span>分别交<spanclass="math inline">\(AD,AE\)</span>于点<spanclass="math inline">\(G,H\)</span>，则<spanclass="math inline">\(BG:GH:HF=?\)</span></p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2lcovn91y680.webp" width="35%"></p><p>$52. $ <span class="math inline">\(\triangle ABC\)</span>中，点<spanclass="math inline">\(D,E,F\)</span>分别在边<spanclass="math inline">\(AB,BC,CA\)</span>上，已知<spanclass="math inline">\(S_{\triangle ABC} = 18, AD=4, BD=5, S_{\triangleABE}=S_{DBEF}\)</span>，则<span class="math inline">\(S_{\triangleABE}=?\)</span></p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.15nmfbydi5eo.webp" width="30%"></p><p>$53. $ 在四边形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AB=CD\)</span>，但不平行，点<spanclass="math inline">\(M,N\)</span>分别是<spanclass="math inline">\(AD,BC\)</span>的中点，<spanclass="math inline">\(NM\)</span>的延长线与<spanclass="math inline">\(BA,CD\)</span>的延长线分别交于点<spanclass="math inline">\(P,Q\)</span>，求证<spanclass="math inline">\(\angle APM = \angle DQM\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.75mtzlzqzgg0.webp" width="20%"></p><p>$54. $ 在等腰<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(AB=AC, AM \parallelBC\)</span>，且<span class="math inline">\(\displaystyleAM=\frac{1}{2}AC\)</span>，点<spanclass="math inline">\(D\)</span>在<spanclass="math inline">\(AB\)</span>上，<spanclass="math inline">\(\displaystyle AD=\frac{1}{4}AB\)</span>，延长<spanclass="math inline">\(MD\)</span>至<spanclass="math inline">\(N\)</span>，使得<spanclass="math inline">\(DM=DN\)</span>，连接<spanclass="math inline">\(AN,BN\)</span>，证明<span class="math inline">\(AN\perp BN\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.18lypfnsq4qo.webp" width="26%"></p><p>$55. $ 直角<span class="math inline">\(\triangleABC\)</span>中，<span class="math inline">\(\angle C =90^\circ\)</span>，作<span class="math inline">\(\displaystyle BN \perpBC, BN=AN, BD=\frac{1}{4}BA\)</span>，连接<spanclass="math inline">\(ND\)</span>至点<spanclass="math inline">\(M\)</span>，使得<spanclass="math inline">\(MD=ND\)</span>，<br />（1）证明<span class="math inline">\(BM \perp AB\)</span>；<br />（2）<span class="math inline">\(M\)</span>点于<spanclass="math inline">\(BC\)</span>的垂直平分线有何位置关系，为什么？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.i9nnsgjmt6o.webp" width="17%"></p><p>$56. $ 在正方形<span class="math inline">\(ABCD\)</span>中，点<spanclass="math inline">\(E\)</span>在<spanclass="math inline">\(CB\)</span>的延长线上，点<spanclass="math inline">\(F\)</span>在<spanclass="math inline">\(BA\)</span>的延长线上，且<spanclass="math inline">\(AF=CE\)</span>，点<spanclass="math inline">\(P\)</span>是<span class="math inline">\(\triangleEFB\)</span>中<span class="math inline">\(\angle FEB, \angleFBE\)</span>两个外角平分线的交点，证明<spanclass="math inline">\(DP=DF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3nkmkp7zsui0.webp" width="19%"></p><p>$57. $ 在平面直角坐标系中，抛物线<spanclass="math inline">\(y=ax^2+2ax-b\)</span>与<spanclass="math inline">\(x\)</span>轴交于<spanclass="math inline">\(A,B\)</span>两点，与<spanclass="math inline">\(y\)</span>轴的正半轴交于<spanclass="math inline">\(C\)</span>点，且<spanclass="math inline">\(A(-4,0), OC=2OB\)</span>，<br />（1）求<span class="math inline">\(a,b\)</span>的值；<br />（2）点<span class="math inline">\(T\)</span>为其顶点，<spanclass="math inline">\(L\)</span>为抛物线上一动点，且<spanclass="math inline">\(\displaystyle MN=\frac{2}{3}LN\)</span>（点<spanclass="math inline">\(M,N,L\)</span>按逆时针顺序），当点<spanclass="math inline">\(L\)</span>在抛物线上运动时，直线<spanclass="math inline">\(AM,TL\)</span>是否存在某种未知关系，若存在，请证明；若不存在，请说明理由。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5riktwc847o0.webp" width="27%"></p><p>$58. $ 在菱形<span class="math inline">\(ABCD\)</span>与菱形<spanclass="math inline">\(BEFG\)</span>中，且<spanclass="math inline">\(\angle ABC=\angle BEF=60^o\)</span>，<spanclass="math inline">\(A,B,E\)</span>在同一条直线上，<br />（1）点<span class="math inline">\(P\)</span>是线段<spanclass="math inline">\(DF\)</span>的中点，连接<spanclass="math inline">\(PG,PC\)</span>，探究<spanclass="math inline">\(PG\)</span>与<spanclass="math inline">\(PC\)</span>的位置和数量关系？<spanclass="math inline">\(\displaystyle \frac{PG}{PC}\)</span>的值；<br />（2）如果将<span class="math inline">\(BEFG\)</span>绕点<spanclass="math inline">\(B\)</span>顺时针旋转，使<spanclass="math inline">\(BF\)</span>与菱形<spanclass="math inline">\(ABCD\)</span>边<spanclass="math inline">\(AB\)</span>在同一条直线上，原条件不变，则（1）中的结论是否依然成立？为什么？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.3fz3dxfw44w0.webp" width="60%"></p><p>$59. $ 如果，直角梯形<spanclass="math inline">\(ABCD\)</span>中，<span class="math inline">\(AB\parallel CD, \angle A = 90^o, CD=3, AD=4, \tan B =2\)</span>，过点<span class="math inline">\(C\)</span>作<spanclass="math inline">\(CH \perp AB\)</span>，点<spanclass="math inline">\(P\)</span>为线段<spanclass="math inline">\(AD\)</span>上一动点，直线<spanclass="math inline">\(PM \parallel AB\)</span>分别交<spanclass="math inline">\(BC,CH\)</span>于点<spanclass="math inline">\(M,Q\)</span>，以<spanclass="math inline">\(PM\)</span>为斜边向右作等腰直角三角形<spanclass="math inline">\(PMN\)</span>，直线<spanclass="math inline">\(MN\)</span>交<spanclass="math inline">\(AB\)</span>与点<spanclass="math inline">\(E\)</span>，直线<spanclass="math inline">\(PN\)</span>交<spanclass="math inline">\(AB\)</span>于点<spanclass="math inline">\(F\)</span>，设<spanclass="math inline">\(PD\)</span>的长为<spanclass="math inline">\(x\)</span>，<spanclass="math inline">\(EF\)</span>的长为<spanclass="math inline">\(y\)</span>；<br />（1）求<span class="math inline">\(PM\)</span>的长；<br />（2）求<span class="math inline">\(y\)</span>与<spanclass="math inline">\(x\)</span>的函数关系及自变量<spanclass="math inline">\(x\)</span>的取值范围；<br />（3）当点<span class="math inline">\(E\)</span>在线段<spanclass="math inline">\(AH\)</span>上时，求<spanclass="math inline">\(x\)</span>的取值范围。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6gcxdmgdi280.webp" width="25%"></p><p>$60. $ 点<spanclass="math inline">\(A,B\)</span>分别是两条平行线<spanclass="math inline">\(m,n\)</span>上的任意两点，在直线<spanclass="math inline">\(n\)</span>上找一点<spanclass="math inline">\(C\)</span>，使得<spanclass="math inline">\(BC=kAB\)</span>，连接<spanclass="math inline">\(AC\)</span>，在线段<spanclass="math inline">\(AC\)</span>上任取一点<spanclass="math inline">\(E\)</span>，作<span class="math inline">\(\angleBEF = \angle ABC\)</span>，<spanclass="math inline">\(EF\)</span>交直线<spanclass="math inline">\(m\)</span>于点<spanclass="math inline">\(F\)</span>，<br />（1）当<span class="math inline">\(k=1\)</span>时，探究线段<spanclass="math inline">\(EF\)</span>与<spanclass="math inline">\(EB\)</span>的关系，并加以说明；<br />（2）若<span class="math inline">\(\angle ABC=90^\circ, k \ne1\)</span>，探究线段<span class="math inline">\(EF\)</span>与<spanclass="math inline">\(EB\)</span>的关系。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5cx6af6nsqc0.webp" width="35%"></p><p>$61. $ 如图，<span class="math inline">\(E\)</span>是正方形<spanclass="math inline">\(ABCD\)</span>的边<spanclass="math inline">\(BC\)</span>上一点，<spanclass="math inline">\(AF\)</span>平分<span class="math inline">\(\angleEAD\)</span>交<span class="math inline">\(CD\)</span>于点<spanclass="math inline">\(F\)</span>，求证<span class="math inline">\(AE =BE + DF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.7g67qj4kkjk0.webp" width="25%"></p><p>$62. $ 矩形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(AD = a, AB = b\)</span>，要使<spanclass="math inline">\(BC\)</span>边上至少存在一点<spanclass="math inline">\(P\)</span>，使<spanclass="math inline">\(\triangle ABP, \triangle APD, \triangleCDP\)</span>两两相似，则<span class="math inline">\(\displaystyle\frac{a}{b}\)</span>的取值范围是？</p><p>$63. $ 如图，<span class="math inline">\(AM\)</span>为<spanclass="math inline">\(\angle BAD\)</span>的平分线，<spanclass="math inline">\(CM\)</span>为<span class="math inline">\(\angleBCD\)</span>的平分线，求证<span class="math inline">\(\displaystyle\angle M = \frac{1}{2} (\angle B + \angle D)\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.79d4yuzadps0.webp" width="25%"></p><p>$64. $ 如图，<span class="math inline">\(ABCD\)</span>为矩形，<spanclass="math inline">\(CD\)</span>的延长线上有一点<spanclass="math inline">\(E\)</span>，连接<spanclass="math inline">\(BE\)</span>，<spanclass="math inline">\(BE\)</span>上有一点<spanclass="math inline">\(G\)</span>，有<span class="math inline">\(BD = DG,DG = GE\)</span>，求证<span class="math inline">\(\angle DBA = 3 \angleEBA\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2h9e05me23m0.webp" width="35%"></p><p>$65. $ 在平行四边形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(E\)</span>为<spanclass="math inline">\(CD\)</span>上一点，<spanclass="math inline">\(DE:EC = 2:3\)</span>，连接<spanclass="math inline">\(AE,BE,BD\)</span>，且<spanclass="math inline">\(AE,BD\)</span>交于点<spanclass="math inline">\(F\)</span>，则$S_{EDF}: S_{EBF}: S_{ABF} = $？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5qiu3sm5po80.webp" width="30%"></p><p>$66. $ 过<span class="math inline">\(\triangleABC\)</span>内任一点<span class="math inline">\(P\)</span>，作<spanclass="math inline">\(DE \parallel BC, HK \parallel AB, GF \parallelAC\)</span>，则<span class="math inline">\(\displaystyle \frac{DE}{BC} +\frac{FG}{AC} + \frac{KH}{AB}=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.6irrt5m3fjk0.webp" width="30%"></p><p>$67. $ <span class="math inline">\(\triangle ABC\)</span>中，<spanclass="math inline">\(\angle ABC = 45^\circ\)</span>，<spanclass="math inline">\(AD\)</span>是<span class="math inline">\(\angleBAC\)</span>的平分线，<spanclass="math inline">\(EF\)</span>垂直平分<spanclass="math inline">\(AD\)</span>交<spanclass="math inline">\(BC\)</span>延长线于<spanclass="math inline">\(F\)</span>，则<span class="math inline">\(\angleCAF=\)</span>？</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.5v1li1s6cqg0.webp" width="30%"></p><p>$68. $ 在锐角三角形中，三个内角度数都是质数，则<spanclass="math inline">\(3\)</span>个内角大小为？</p><p>$69. $ 已知四边形<span class="math inline">\(ABCD\)</span>中，<spanclass="math inline">\(\angle ADC = \angle ABC = 90^\circ\)</span>，<spanclass="math inline">\(M,N\)</span>分别是<spanclass="math inline">\(AC,BD\)</span>的中点，证明<spanclass="math inline">\(MN \perp BD\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.ycmivwk99u8.webp" width="30%"></p><p>$70. $ 三角形<span class="math inline">\(ABC\)</span>中，若<spanclass="math inline">\(\angleA\)</span>的外角平分线与三角形的外接圆交于点<spanclass="math inline">\(D\)</span>，证明<spanclass="math inline">\(BD=CD\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.2l3tuxikk5a0.webp" width="35%"></p><p>$71. $ 若<span class="math inline">\(a,b,c\)</span>表示<spanclass="math inline">\(\triangle ABC\)</span>的三边长，<spanclass="math inline">\(m&gt;0\)</span>，证明<spanclass="math inline">\(\displaystyle \frac{a}{a+m} + \frac{b}{b+m} &gt;\frac{c}{c+m}\)</span>。</p><p>$72. $ 已知<span class="math inline">\(BE,CF\)</span>分别为<spanclass="math inline">\(\triangle ABC\)</span>的边<spanclass="math inline">\(AC,AB\)</span>上的高，<spanclass="math inline">\(G\)</span>为<spanclass="math inline">\(EF\)</span>的中点，<spanclass="math inline">\(H\)</span>为<spanclass="math inline">\(BC\)</span>的中点，求证<spanclass="math inline">\(HG \perp EF\)</span>。</p><p><img src="https://cdn.staticaly.com/gh/gamersover/hexo_blog_assets@main/数学试题1/xxx.v511icym1zk.webp" width="35%"></p><p>$73. $证明：等腰三角形底边延长线上一点到两腰距离之差等于一腰上的高。</p><h4 id="代数题">代数题</h4><p>$1. $ 当关于<span class="math inline">\(x\)</span>的方程<spanclass="math inline">\(rx^2 + (r+2)^2x + r - 1 =0\)</span>有且仅有整数根时，求<spanclass="math inline">\(r\)</span>的值。</p><p>$2. $ 已知<span class="math inline">\(\displaystyle\frac{1}{4}(b-c)^2 = (a-b)(c-a)\)</span>，且<spanclass="math inline">\(a \ne 0\)</span>，则<spanclass="math inline">\(\displaystyle \frac{b+c}{a}=\)</span>？</p><p>$3. $ 已知<span class="math inline">\(x + y + z=0\)</span>，则<spanclass="math inline">\(\displaystyle \frac{1}{y^2+z^2-x^2} +\frac{1}{z^2+x^2-y^2} + \frac{1}{x^2+y^2-z^2}=\)</span>？</p><p>$4. $ 已知<span class="math inline">\(\displaystyle \frac{x}{m} +\frac{y}{n} + \frac{z}{p} = 1\)</span>，<spanclass="math inline">\(\displaystyle \frac{m}{x} + \frac{n}{y} +\frac{p}{z} = 0\)</span>，则<span class="math inline">\(\displaystyle\frac{x^2}{m^2} + \frac{y^2}{n^2} + \frac{z^2}{p^2}=\)</span>？</p><p>$5. $ 已知<span class="math inline">\(f(x) = ax^2 + bx + c (a \ne0)\)</span>且<span class="math inline">\(a,b,c\)</span>都为整数，<spanclass="math inline">\(f(0),f(1)\)</span>都为奇数，求证：<spanclass="math inline">\(f(x)=0\)</span>无整实根。</p><p>$6. $ 已知<spanclass="math inline">\(x,y,z\)</span>为互不相等的实数，且<spanclass="math inline">\(\displaystyle x + \frac{1}{y} = y + \frac{1}{z} =z + \frac{1}{x}\)</span>，证明<span class="math inline">\(x^2y^2z^2 =1\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数三：极值定义与微分中值定理</title>
      <link href="/2021/02/01/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B03/"/>
      <url>/2021/02/01/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B03/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1极值">定义1：极值</h4><blockquote><p>设函数<span class="math inline">\(f: (a,b) \to\mathbb{R}\)</span>，如果对点<span class="math inline">\(x_0 \in (a,b)\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，使得<span class="math inline">\(\Delta = (x_0 - \delta, x_0+ \delta) \subset (a,b)\)</span>，且当<span class="math inline">\(x \in\Delta\)</span>时，有<span class="math inline">\(f(x_0) \gef(x)\)</span>，则称<span class="math inline">\(f(x_0)\)</span>是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上的极大值，<spanclass="math inline">\(x_0\)</span>称为极大值点。类似地，可以定义<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上的极小值和极小值点。极小值和极大值统称为极值，而极小值点和极大值点统称为极值点。</p></blockquote><span id="more"></span><h4 id="定理1fermat">定理1：Fermat</h4><blockquote><p>若函数<span class="math inline">\(f\)</span>在其极值点<spanclass="math inline">\(x_0 \in (a,b)\)</span>处可导，则必有<spanclass="math inline">\(f^\prime(x) = 0\)</span>。</p></blockquote><p>证：不妨设<spanclass="math inline">\(f(x_0)\)</span>时极大值，由极大值点的定义可知，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(x \in (x_0 - \delta, x_0 +\delta)\)</span>，有<span class="math inline">\(f(x_0) &gt;f(x)\)</span>。从而，当<span class="math inline">\(x \in (x_0 - \delta,x_0)\)</span>时，有<br /><span class="math display">\[    \frac{f(x) - f(x_0)}{x - x_0} \ge 0\]</span><br />而当<span class="math inline">\(x \in (x_0,x_0+\delta)\)</span>，又有<br /><span class="math display">\[    \frac{f(x) - f(x_0)}{x - x_0} \le 0\]</span><br />由于<span class="math inline">\(f^\prime(x)\)</span>存在，因此<spanclass="math inline">\(f_-^{\prime}(x)\)</span>和<spanclass="math inline">\(f_+^{\prime}(x)\)</span>都存在，且相等。从而在以上两个不等式中分别令<spanclass="math inline">\(x \to x_0^-, x \to x_0^+\)</span>，得<br /><span class="math display">\[    f_-^{\prime}(x_0) \ge 0 \qquad f_+^{\prime}(x) \le 0\]</span><br />因此必有<span class="math inline">\(f^\prime(x) = 0\)</span>。</p><p>Q.E.D.</p><h4 id="定义2驻点">定义2：驻点</h4><blockquote><p>满足<span class="math inline">\(x_0 \in (a,b)\)</span>且<spanclass="math inline">\(f^\prime(x_0) = 0\)</span>的点<spanclass="math inline">\(x_0\)</span>称为函数<spanclass="math inline">\(f\)</span>的一个驻点。</p></blockquote><h4 id="定理2rolle">定理2：Rolle</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>内可导，且<spanclass="math inline">\(f(a) = f(b)\)</span>，那么存在一点<spanclass="math inline">\(\xi \in (a,b)\)</span>，使得<spanclass="math inline">\(f^\prime(\xi) = 0\)</span>。</p></blockquote><p>证：闭区间<span class="math inline">\([a,b]\)</span>上的连续函数<spanclass="math inline">\(f\)</span>取到最小值和最大值分别记为<spanclass="math inline">\(m\)</span> 和 <spanclass="math inline">\(M\)</span>。如果<span class="math inline">\(m =M\)</span>，那么<spanclass="math inline">\(f\)</span>时常值函数，这时<spanclass="math inline">\(f^\prime = 0\)</span>，因此<spanclass="math inline">\((a,b)\)</span>上任意一点都可为所求的点。若<spanclass="math inline">\(M &gt; m\)</span>，由于<spanclass="math inline">\(f(a) = f(b)\)</span>，则<spanclass="math inline">\(m, M\)</span>至少有一个时<spanclass="math inline">\(f\)</span>在内点<span class="math inline">\(\xi\in (a,b)\)</span>上所取得的。这时<spanclass="math inline">\(\xi\)</span>为一个极值点，由<ahref="函数导数3/#定理1：Fermat">定理1</a>可知<spanclass="math inline">\(f^\prime(\xi) = 0\)</span>。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\lambda\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>内可导，且<spanclass="math inline">\(\lambda(a) = 1,\lambda(b) =0\)</span>，则必存在一点<span class="math inline">\(\xi \in(a,b)\)</span>使得<br /><span class="math display">\[    f^\prime(\xi) = \lambda^\prime(\xi)(f(a) - f(b))\]</span></p></blockquote><p>证：构造函数<br /><span class="math display">\[    \varphi(x) = f(x) - (\lambda(x)f(a) + (1 - \lambda(x))f(b))\]</span><br />可知<span class="math inline">\(\varphi(a) = \varphi(b) =0\)</span>。因此函数<spanclass="math inline">\(\varphi\)</span>满足Rolle定理条件，从而存在一点<spanclass="math inline">\(\xi \in (a,b)\)</span>使得<spanclass="math inline">\(\varphi^{\prime}(\xi) = 0\)</span>，由于<br /><span class="math display">\[    \varphi^\prime(x) = f^\prime(x) - \lambda^\prime(x)(f(a) - f(b))\]</span><br />将<span class="math inline">\(\xi\)</span>代入上式，得<br /><span class="math display">\[    f^\prime(\xi) = \lambda^\prime(\xi)(f(a) - f(b))\]</span></p><p>Q.E.D.</p><h4 id="定理4lagrange">定理4：Lagrange</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>内可导，则存在<spanclass="math inline">\(\xi \in (a,b)\)</span>使得<br /><span class="math display">\[    \frac{f(a) - f(b)}{a - b} = f^\prime(\xi)\]</span></p></blockquote><p>证：在<ahref="https://gamersover.github.io/2021/02/01/函数导数3/#定理3">定理3</a>中取<br /><span class="math display">\[    \lambda (x) = \frac{b-x}{b-a} \quad (a \le x \le b)\]</span><br />即可得。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>与在<spanclass="math inline">\([a,b]\)</span>上连续，在<spanclass="math inline">\((a,b)\)</span>内可导，则函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上为常数的充分必要条件是<spanclass="math inline">\(f^\prime = 0\)</span>。</p></blockquote><p>证：必要性易证。充分性：设<span class="math inline">\(f^\prime =0\)</span>，任取<span class="math inline">\(x_1,x_2 \in[a,b]\)</span>，且<span class="math inline">\(x_1 &lt;x_2\)</span>，那么存在<span class="math inline">\(\xi \in(x_1,x_2)\)</span>，使得<br /><span class="math display">\[    f(x_2) - f(x_1) = f^\prime(\xi) (x_2 - x_1)\]</span><br />由于<span class="math inline">\(f^\prime(\xi) = 0\)</span>，从而<spanclass="math inline">\(f(x_2) = f(x_1)\)</span>。</p><p>Q.E.D.</p><h4 id="定理6cauchy">定理6：Cauchy</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在区间<spanclass="math inline">\([a,b]\)</span>上连续，在区间<spanclass="math inline">\((a,b)\)</span>内可导，且当<spanclass="math inline">\(x \in (a,b)\)</span>时，<spanclass="math inline">\(g^\prime(x) \ne 0\)</span>，这时必存在一点<spanclass="math inline">\(\xi \in (a,b)\)</span>，使得<br /><span class="math display">\[    \frac{f(a) - f(b)}{g(a) - g(b)} =\frac{f^\prime(\xi)}{g^\prime(\xi)}\]</span></p></blockquote><p>证：在<ahref="https://gamersover.github.io/2021/02/01/函数导数3/#定理3">定理3</a>中取<br /><span class="math display">\[    \lambda (x) = \frac{g(b) - g(x)}{g(b) - g(a)} \quad (a \le x \le b)\]</span><br />即可得。</p><p>Q.E.D.</p><h4 id="定理7darboux">定理7：Darboux</h4><blockquote><p>如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上可导，那么：<br />（1）导函数<span class="math inline">\(f^\prime\)</span>可以取到<spanclass="math inline">\(f^\prime(a)\)</span>与<spanclass="math inline">\(f^\prime(b)\)</span>之间的一切值。<br />（2）<span class="math inline">\(f^\prime\)</span>无第一类间断点。</p></blockquote><p>证：（1）先证明：如果<spanclass="math inline">\(f^\prime(a)f^\prime(b) &lt;0\)</span>，那么必有<span class="math inline">\(\xi \in(a,b)\)</span>，使得<span class="math inline">\(f^\prime(\xi) =0\)</span>。不妨设<span class="math inline">\(f^\prime(a) &gt; 0,f^\prime(b) &lt; 0\)</span>。由于<br /><span class="math display">\[    f^\prime(a) = \lim\limits_{x\to a^+} \frac{f(x) - f(a)}{x - a} &gt;0\]</span><br />所以存在<span class="math inline">\(\delta_1 &gt; 0\)</span>，当<spanclass="math inline">\(x \in (a, a+\delta_1)\)</span>时，<spanclass="math inline">\(\frac{f(x) - f(a)}{x - a} &gt;0\)</span>，由于<span class="math inline">\(x &gt; a\)</span>，所以<spanclass="math inline">\(f(x) &gt; f(a)\)</span>。同理可知存在<spanclass="math inline">\(\delta_2 &gt; 0\)</span>，当<spanclass="math inline">\(x \in (b - \delta_2, b)\)</span>时，<spanclass="math inline">\(f(x) &gt; f(b)\)</span>，表明<spanclass="math inline">\(f(a),f(b)\)</span>都不是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上的最大值，从而必存在<spanclass="math inline">\(\xi \in (a,b)\)</span>，使得<spanclass="math inline">\(f^\prime(\xi) = 0\)</span>。</p><p>现在设<span class="math inline">\(f^\prime(a) &lt;f^\prime(b)\)</span>，任取介于<spanclass="math inline">\(f^\prime(a)\)</span>和<spanclass="math inline">\(f^\prime(b)\)</span>之间的值<spanclass="math inline">\(\gamma\)</span>，即<br /><span class="math display">\[    f^\prime(a) &lt; \gamma &lt; f^\prime(b)\]</span><br />记<span class="math inline">\(F(x) = f(x) - \lambdax\)</span>，那么<span class="math inline">\(F^\prime(x) = f^\prime(x) -\lambda\)</span>，可知<span class="math inline">\(F^\prime(a)F^\prime(b)&lt; 0\)</span>，从而利用上面所证的结论可知，存在<spanclass="math inline">\(\xi \in (a,b)\)</span>，使得<spanclass="math inline">\(F^\prime(\xi) = 0\)</span>，即<br /><span class="math display">\[    f^\prime(\xi) = \lambda\]</span></p><p>（2）用反证法。如果<span class="math inline">\(x_0\)</span>是<spanclass="math inline">\(f^\prime\)</span>的一个第一类间断点，那么<spanclass="math inline">\(f^\prime(x_0+)\)</span>和<spanclass="math inline">\(f^\prime(x_0-)\)</span>都存在，于是由<ahref="https://gamersover.github.io/2021/02/01/函数导数3/#定理4：Lagrange">定理4</a>可得<br /><span class="math display">\[    f^\prime(x_0) = f_+^\prime(x_0) = \lim\limits_{x \to x_0+}\frac{f(x) - f(x_0)}{x - x_0} = \lim\limits_{x \to x_0^+}\frac{f^\prime(\xi_+)(x-x_0)}{x - x_0}  = \lim\limits_{x \to x_0^+}f^\prime(\xi_+)\]</span><br />其中<span class="math inline">\(\xi_+ \in (x_0, x)\)</span>。由于当<spanclass="math inline">\(x \to x_0^+\)</span>，<spanclass="math inline">\(\xi_+ \to x_0^+\)</span>，且已知<spanclass="math inline">\(f^\prime(x_0+)\)</span>存在，所以得<br /><span class="math display">\[    f^\prime(x_0) = f^\prime(x_0+)\]</span><br />同理可证<span class="math inline">\(f^\prime(x_0) =f^\prime(x_0-)\)</span>。由此可知<spanclass="math inline">\(f^\prime\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，这与<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f^\prime\)</span>的间断点矛盾。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 微分中值定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数二：初等函数的导数</title>
      <link href="/2021/01/27/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B02/"/>
      <url>/2021/01/27/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B02/</url>
      
        <content type="html"><![CDATA[<p>本章介绍常见初等函数的导函数及其求法。<br /><span id="more"></span></p><h4 id="常值函数">常值函数</h4><blockquote><p>函数<span class="math inline">\(f = c\)</span>为常值函数，证：<spanclass="math inline">\(f^\prime = 0\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    f^\prime(x) = \frac{f(x+h) - f(x)}{h} = \frac{c-c}{h} = 0\]</span></p><p>Q.E.D.</p><h4 id="指数函数">指数函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = x^\alpha (x &gt; 0, \alpha \in\mathbb{R})\)</span>，证：<span class="math inline">\(f^\prime(x) =\alpha x^{\alpha - 1}\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    f^\prime(x) = \lim\limits_{h \to 0} \frac{(x+h)^\alpha -x^\alpha}{h} = x^{\alpha-1}\lim\limits_{h \to 0} \frac{(1 +h/x)^{\alpha} - 1}{h/x}\]</span><br />而<br /><span class="math display">\[    \lim\limits_{t \to 0} \frac{(1+t)^\alpha - 1}{t} = \lim\limits_{t\to 0} \frac{e^{\alpha \ln(1+t)} - 1}{\alpha \ln (1+t)} \frac{\alpha \ln(1+t)}{t}\]</span><br />由于<span class="math inline">\(\ln(1+x) \sim x, e^x-1 \sim x \quad (x\to 0)\)</span>，从而<br /><span class="math display">\[    \lim\limits_{t \to 0} \frac{(1+t)^\alpha - 1}{t} = \alpha\]</span><br />所以<br /><span class="math display">\[     f^\prime(x) = \alpha x^{\alpha - 1}\]</span></p><p>Q.E.D.</p><h4 id="正弦函数">正弦函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \sin x\)</span>，证<spanclass="math inline">\(f^\prime(x) = \cos x\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    f^\prime(x) = \lim\limits_{h \to 0} \frac{\sin(x+h) - \sin x}{h} =\lim\limits_{h \to 0} \frac{\cos (x+h/2) \sin (h/2)}{h/2} = \cos x\]</span></p><p>Q.E.D.</p><h4 id="余弦函数">余弦函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \cos x\)</span>，证<spanclass="math inline">\(f^\prime(x) = -\sin x\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    f^\prime(x) = \lim \limits_{h \to 0} \frac{\cos (x+h) - \cos x}{h} =\lim\limits_{h \to 0} \frac{-\sin(x+h)\sin (h/2)}{h/2} = -\sin x\]</span></p><p>Q.E.D.</p><h4 id="正切函数">正切函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \tan x\)</span>，证<spanclass="math inline">\(f^\prime(x) = \sec^2x\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    (\tan x)^\prime = \begin{aligned} \left( \frac{\sin x}{\cos x}\right)\end{aligned} ^\prime = \frac{(\sin x)^\prime \cos x - \sin x(\cos x)^\prime}{\cos^2x} = \frac{1}{\cos^2 x} = \sec^2x\]</span></p><p>Q.E.D.</p><h4 id="余切函数">余切函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \cot x\)</span>，证<spanclass="math inline">\(f^\prime(x) = -\csc^2x\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    (\tan x)^\prime = \begin{aligned} \left( \frac{\cos x}{\sin x}\right)\end{aligned} ^\prime = \frac{(\cos x)^\prime \sin x - \cos x(\sin x)^\prime}{\sin^2x} = - \frac{1}{\cos^2 x} = -\csc^2x\]</span></p><p>Q.E.D.</p><h4 id="反正弦函数">反正弦函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \arcsin x\)</span>，证<spanclass="math inline">\(f^\prime(x) =\frac{1}{\sqrt{1-x^2}}\)</span>。</p></blockquote><p>证：函数<span class="math inline">\(f(x)\)</span>的反函数为<spanclass="math inline">\(x = \sin y\)</span>，从而<br /><span class="math display">\[    f^\prime(x) = \frac{1}{(\sin y)^\prime} = \frac{1}{\cos y} =\frac{1}{\sqrt{1-x^2}}\]</span></p><p>Q.E.D.</p><h4 id="反余弦函数">反余弦函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \arccos x\)</span>，证<spanclass="math inline">\(f^\prime(x) =-\frac{1}{\sqrt{1-x^2}}\)</span>。</p></blockquote><p>证：函数<span class="math inline">\(f(x)\)</span>的反函数为<spanclass="math inline">\(x = \cos y\)</span>，从而<br /><span class="math display">\[    f^\prime(x) = \frac{1}{(\cos y)^\prime} = \frac{1}{-\sin y} =-\frac{1}{\sqrt{1-x^2}}\]</span></p><p>Q.E.D.</p><h4 id="反正切函数">反正切函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \arctan x\)</span>，证<spanclass="math inline">\(f^\prime(x) = \frac{1}{1+x^2}\)</span>。</p></blockquote><p>证：函数<span class="math inline">\(f(x)\)</span>的反函数为<spanclass="math inline">\(x = \tan y\)</span>，从而<br /><span class="math display">\[    f^\prime(x) = \frac{1}{(\tan y)^\prime} = {\cos^2 y} =\frac{1}{1+\tan^2y} = \frac{1}{1+x^2}\]</span></p><p>Q.E.D.</p><h4 id="反余切函数">反余切函数</h4><!--markdown 不支持\arccot--><blockquote><p>函数<span class="math inline">\(f(x) = \mathrm{arccot}x\)</span>，证<span class="math inline">\(f^\prime(x) =-\frac{1}{1+x^2}\)</span>。</p></blockquote><p>证：函数<span class="math inline">\(f(x)\)</span>的反函数为<spanclass="math inline">\(x = \cot y\)</span>，从而<br /><span class="math display">\[    f^\prime(x) = \frac{1}{(\cot y)^\prime} = -{\sin^2 y} =-\frac{1}{1+\cot^2y} = -\frac{1}{1+x^2}\]</span></p><p>Q.E.D.</p><h4 id="幂函数">幂函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = a^x (a&gt;0)\)</span>，证<spanclass="math inline">\(f^\prime(x) = a^x \ln a\)</span>。</p></blockquote><p>证：由于<br /><span class="math display">\[    f^\prime(x) = \lim\limits_{h \to 0} \frac{a^{x+h} - a^x}{h} = a^x\lim\limits_{h \to 0} \frac{a^{h} - 1}{h} = a^x \ln a\]</span><br />特别地，当<span class="math inline">\(a= e\)</span>时，有<spanclass="math inline">\((e^x)^\prime = e^x\)</span>。</p><p>Q.E.D.</p><h4 id="对数函数">对数函数</h4><blockquote><p>函数<span class="math inline">\(f(x) = \log_a x \quad (a &gt;0)\)</span>，证<span class="math inline">\(f^\prime(x) = \frac{1}{x \lna}\)</span>。</p></blockquote><p>证：由于<span class="math inline">\(f(x)\)</span>的反函数为<spanclass="math inline">\(x = a^y\)</span>，所以<br /><span class="math display">\[    f^\prime(x) = \frac{1}{(a^y)^\prime} = \frac{1}{a^y \ln a} =\frac{1}{x \ln a}\]</span><br />特别地，当<span class="math inline">\(a=e\)</span>时，有<spanclass="math inline">\((\ln x)^\prime = \frac{1}{x}\)</span>。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
            <tag> 初等函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数导数一：导数的定义与基本性质</title>
      <link href="/2021/01/25/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B01/"/>
      <url>/2021/01/25/%E5%87%BD%E6%95%B0%E5%AF%BC%E6%95%B01/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1导数">定义1：导数</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>的近旁处有定义，如果极限<br /><span class="math display">\[    \lim \limits_{h \to 0} \frac{f(x_0+h) - f(x_0)}{h}\]</span><br />存在且有限，则称这个极限值为<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的导数，记作<spanclass="math inline">\(f^{\prime}(x_0)\)</span>，并称函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>处可导。</p></blockquote><span id="more"></span><h4 id="定义2单边导数">定义2：单边导数</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的右边<spanclass="math inline">\([x_0,x_0+r)\)</span>上有定义，其中<spanclass="math inline">\(r&gt;0\)</span>，若极限<br /><span class="math display">\[    \lim \limits_{h \to 0^+} \frac{f(x_0 + h) - f(x_0)}{h}\]</span><br />存在且有限，则称此极限为函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的右导数，记作<spanclass="math inline">\(f_+^{\prime}(x_0)\)</span>。<br />类似地，设函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的右边<spanclass="math inline">\((x_0-r,x_0]\)</span>上有定义，其中<spanclass="math inline">\(r&gt;0\)</span>，若极限<br /><span class="math display">\[    \lim \limits_{h \to 0^-} \frac{f(x_0 + h) - f(x_0)}{h}\]</span><br />存在且有限，则称此极限为函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的左导数，记作<spanclass="math inline">\(f_-^{\prime}(x_0)\)</span>。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>处可导的充分必要条件是<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的左、右导数存在且相等，即<spanclass="math inline">\(f^\prime(x_0) = f_-^\prime(x_0) =f_+^\prime(x_0)\)</span>。</p></blockquote><p>证：由定义1与定义2易证。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>若函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>处可导，则<spanclass="math inline">\(f\)</span>必在<spanclass="math inline">\(x_0\)</span>处连续。</p></blockquote><p>证：记<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的导数为<spanclass="math inline">\(f^\prime(x_0)\)</span>，于是有<br /><span class="math display">\[    \lim \limits_{x \to x_0} (f(x) - f(x_0)) = \lim \limits_{x \to x_0}\frac{f(x) - f(x_0)}{x-x_0} \cdot (x-x_0)\]</span><br />上式中令<span class="math inline">\(x-x_0 = h\)</span>，可得<br /><span class="math display">\[    \lim \limits_{x \to x_0} (f(x) - f(x_0)) = \lim \limits_{h \to 0}\frac{f(x_0+h) - f(x_0)}{h} \cdot h = f^\prime(x_0) \cdot 0 = 0\]</span></p><p>Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>如果函数<span class="math inline">\(f\)</span>在开区间<spanclass="math inline">\((a,b)\)</span>中的每一点可导，则称函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上可导；如果函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上可导，且在点<spanclass="math inline">\(a\)</span>处有右导数，在点<spanclass="math inline">\(b\)</span>处有左导数，则称函数<spanclass="math inline">\(f\)</span>在闭区间<spanclass="math inline">\([a,b]\)</span>上可导。类似地，可以定义函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b)\)</span>与<spanclass="math inline">\((a,b]\)</span>上可导。</p></blockquote><h4 id="定理3求导的四则运算">定理3：求导的四则运算</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>在点<spanclass="math inline">\(x\)</span>处可导，则<span class="math inline">\(f\pm g,fg\)</span>也在<spanclass="math inline">\(x\)</span>处可导，如果<spanclass="math inline">\(g(x)\ne 0\)</span>，那么函数<spanclass="math inline">\(f/g\)</span>也在<spanclass="math inline">\(x_0\)</span>处可导。精确地说，我们有以下公式：<br />（1）<span class="math inline">\((f \pm g)^\prime (x) = f^\prime(x) \pmg^\prime(x)\)</span><br />（2）<span class="math inline">\((fg)^\prime (x) = f^\prime(x)g(x) +f(x)g^\prime(x)\)</span><br />（3）<span class="math inline">\(\displaystyle (\frac{f}{g})^\prime(x) =\frac{f^\prime(x)g(x) - f(x)g^\prime(x)}{g^2(x)}\)</span></p></blockquote><p>证：（1）有<br /><span class="math display">\[    \frac{(f \pm g) (x + h) - (f \pm g) (x)}{h} = \frac{f(x+h) -f(x)}{h} \pm \frac{g(x+h) - g(x)}{h}\]</span><br />令<span class="math inline">\(h \to 0\)</span>，从而得到（1）式；<br />（2） 有<br /><span class="math display">\[    \begin{aligned}    \frac{f(x+h)g(x+h) - f(x)g(x)}{h} &amp; = \frac{f(x+h)g(x+h) -f(x)g(x+h) + f(x)g(x+h) - f(x)g(x)}{h} \\    &amp; = \frac{f(x+h) - f(x)}{h} \cdot g(x+h) + \frac{g(x+h) -g(x)}{h} \cdot f(x)    \end{aligned}\]</span><br />上式中令<span class="math inline">\(h \to0\)</span>，即可得到（2）式；<br />（3）有<br /><span class="math display">\[    \begin{aligned}        \frac{1}{h}\left(\frac{f(x+h)}{g(x+h)} - \frac{f(x)}{g(x)}\right) &amp; = \frac{1}{h}\left( \frac{f(x+h)g(x) -f(x)g(x+h)}{g(x+h)g(x)} \right) \\        &amp; = \frac{1}{g(x+h)g(x)} \left( \frac{f(x+h) - f(x)}{h}g(x)- \frac{g(x+h) - g(x)}{h} f(x) \right)    \end{aligned}\]</span><br />令<span class="math inline">\(h \to 0\)</span>，即可得（3）式。</p><p>Q.E.D.</p><h4 id="定理4链式法则">定理4：链式法则</h4><blockquote><p>设函数<span class="math inline">\(\varphi\)</span>在点<spanclass="math inline">\(t_0\)</span>处可导，函数<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0=\varphi(t_0)\)</span>处可导，那么复合函数<spanclass="math inline">\(f\circ \varphi\)</span>在点<spanclass="math inline">\(t_0\)</span>处可导，且<br /><span class="math display">\[    (f \circ g)^\prime (t_0) = f^\prime(\varphi(t_0))\varphi^\prime(t_0)\]</span></p></blockquote><p>证：记函数<br /><span class="math display">\[        g(x) = \left\{             \begin{aligned}                &amp; \frac{f(x) - f(x_0)}{x - x_0}  \quad &amp;x \nex_0\\                &amp; f^\prime(x_0) \quad &amp; x = x_0             \end{aligned}             \right.\]</span><br />可知<br /><span class="math display">\[    \lim \limits_{x \to x_0} g(x) = \lim \limits_{x \to x_0} \frac{f(x)- f(x_0)}{x - x_0} = f^\prime(x_0) = g(x_0)\]</span><br />所以<span class="math inline">\(g(x)\)</span>在<spanclass="math inline">\(x_0\)</span>处连续。<br />（1）当<span class="math inline">\(\varphi(t) \ne\varphi(t_0)\)</span>时，有<br /><span class="math display">\[    \frac{f(\varphi(t)) - f(\varphi(t_0))}{t-t_0} = \frac{f(\varphi(t))- f(\varphi(t_0))}{\varphi(t)-\varphi(t_0)} \cdot \frac{\varphi(t) -\varphi(t_0)}{t - t_0} = g(\varphi(t)) \cdot \frac{\varphi(t) -\varphi(t_0)}{t - t_0}\]</span><br />（2）当<span class="math inline">\(\varphi(t) =\varphi(t_0)\)</span>时，有<br /><span class="math display">\[    0 = \frac{f(\varphi(t)) - f(\varphi(t_0))}{t-t_0} = g(\varphi(t))\cdot \frac{\varphi(t) - \varphi(t_0)}{t - t_0} = 0\]</span><br />从而有<br /><span class="math display">\[   \frac{f(\varphi(t)) - f(\varphi(t_0))}{t-t_0} = g(\varphi(t)) \cdot\frac{\varphi(t) - \varphi(t_0)}{t - t_0} \tag 1\]</span><br />又由于<br /><span class="math display">\[    \lim \limits_{t \to t_0} g(\varphi(t)) = g(\varphi(t_0)) = g(x_0) =f^\prime(x_0)\]</span><br />再令（1）式中<span class="math inline">\(t \to t_0\)</span>，可得<br /><span class="math display">\[    (f \circ g)^\prime (t) = f^\prime(x_0) \varphi^\prime(t_0) =f^\prime(\varphi(t_0))\varphi^\prime(t_0)\]</span></p><p>Q.E.D.</p><h4 id="定理5反函数的求导">定理5：反函数的求导</h4><blockquote><p>设<span class="math inline">\(y = f(x)\)</span>在包含<spanclass="math inline">\(x_0\)</span>的区间<spanclass="math inline">\(I\)</span>上连续且严格单调。如果它在<spanclass="math inline">\(x_0\)</span>处可导，且<spanclass="math inline">\(f^\prime(x_0) \ne 0\)</span>，那么它的反函数<spanclass="math inline">\(x = f^{-1}(y)\)</span>在<spanclass="math inline">\(y_0 = f(x_0)\)</span>处可导，且<br /><span class="math display">\[    (f^{-1})^\prime(y_0) = \frac{1}{f^\prime(x_0)}\]</span></p></blockquote><p>证：由于<br /><span class="math display">\[    \frac{f^{-1}(y) - f^{-1}(y_0)}{y - y_0} = \frac{x - x_0}{f(x) -f(x_0)} = \left(\frac{f(x) - f(x_0)}{x - x_0}\right)^{-1}\]</span><br />又因为<span class="math inline">\(f\)</span>单调连续，所以当<spanclass="math inline">\(y \to y_0\)</span>时，有<spanclass="math inline">\(x \to x_0\)</span>，令上式中<spanclass="math inline">\(y \to y_0\)</span>，可得<br /><span class="math display">\[    (f^{-1})^\prime(y_0) = (f^\prime(x_0))^{-1}\]</span></p><p>Q.E.D.</p><h4 id="定义4导函数与n阶导函数">定义4：导函数与<spanclass="math inline">\(n\)</span>阶导函数</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上可导，那么<spanclass="math inline">\(f^\prime(x)(x \in I)\)</span>在<spanclass="math inline">\(I\)</span>上定义了一个函数<spanclass="math inline">\(f^\prime\)</span>，称之为<spanclass="math inline">\(f\)</span>的导函数。如果<spanclass="math inline">\(f^\prime\)</span>在<spanclass="math inline">\(I\)</span>上可导，那么<spanclass="math inline">\((f^\prime)^\prime\)</span>称为<spanclass="math inline">\(f\)</span>的二阶导函数，记作<spanclass="math inline">\(f^{\prime\prime}\)</span>。由归纳可知，对任何正整数<spanclass="math inline">\(n\)</span>，可以定义<spanclass="math inline">\(f\)</span>的<spanclass="math inline">\(n\)</span>阶导函数<spanclass="math inline">\(f^{(n)}\)</span>。</p></blockquote><h4 id="定理6leibniz">定理6：Leibniz</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在区间<spanclass="math inline">\(I\)</span>上都有<spanclass="math inline">\(n\)</span>阶导数，那么乘积<spanclass="math inline">\(fg\)</span>在区间<spanclass="math inline">\(I\)</span>上也有<spanclass="math inline">\(n\)</span>阶导数，并且<br /><span class="math display">\[    (fg)^{(n)} = \sum_{k=0}^n \binom{n}{k} f^{(n-k)}g^{(k)}\]</span><br />这里<span class="math inline">\(f^{(0)} = f, g^{(0)} =g\)</span>，其中组合系数<br /><span class="math display">\[    \binom{n}{k} = \frac{n!}{(n-k)!k!} \quad (k = 0,1,2,\cdots)\]</span></p></blockquote><p>证：我们对<span class="math inline">\(n\)</span>进行归纳。当<spanclass="math inline">\(n = 1\)</span>时，命题显然成立。现假设<spanclass="math inline">\(m \ge 1\)</span>时，有<br /><span class="math display">\[    (fg)^{(m)} = \sum_{k=0}^m \binom{m}{k} f^{(m-k)}g^{(k)}\]</span><br />这时对上式两边求导，得<br /><span class="math display">\[    \begin{aligned}        (fg)^{(m+1)} &amp; = \sum_{k=0}^m \binom{m}{k}(f^{(m-k)}g^{(k)})^\prime \\        &amp; = \sum_{k=0}^m \binom{m}{k} (f^{(m-k+1)}g^{(k)} +f^{(m-k)}g^{(k+1)}) \\        &amp; = \binom{m}{0}f^{(m+1)}g^{(0)} + \sum_{k=1}^m\left(\binom{m}{k}  +\binom{m}{k-1}\right)  f^{(m-k+1)}g^{(k)} +\binom{m}{m}f^{(m+1)}g^{(0)}    \end{aligned}\]</span><br />而<br /><span class="math display">\[    \begin{aligned}        \binom{m}{k} + \binom{m}{k-1} &amp;= \frac{m!}{(m-k)!k!} +\frac{m!}{(m-k+1)!(k-1)!} \\        &amp; = \frac{m!(m-k+1+k)}{(m-k+1)!k!} =\frac{(m+1)!}{(m-k+1)!k!} = \binom{m+1}{k}    \end{aligned}\]</span><br />且<span class="math inline">\(\binom{m}{0} =\binom{m+1}{0}，\binom{m}{m} = \binom{m+1}{m+1}\)</span>，从而<br /><span class="math display">\[     (fg)^{(m+1)} = \sum_{k=0}^{m+1} \binom{m+1}{k} f^{(m+1-k)}g^{(k)}\]</span><br />即对<span class="math inline">\(m+1\)</span>命题也成立。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数导数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解15：三数之和</title>
      <link href="/2021/01/22/leetcode%E9%A2%98%E8%A7%A315/"/>
      <url>/2021/01/22/leetcode%E9%A2%98%E8%A7%A315/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/3sum">力扣第15题</a><br />给你一个包含<code>n</code>个整数的数组<code>nums</code>，判断<code>nums</code>中是否存在三个元素<code>a</code>，<code>b</code>，<code>c</code>，使得<code>a + b + c = 0</code>？请你找出所有和为<code>0</code>且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。<br /><span id="more"></span></p><p>示例 1：</p><blockquote><p>输入：nums = [-1,0,1,2,-1,-4]<br />输出：[[-1,-1,2],[-1,0,1]]</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums = []<br />输出：[]</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums = [0]<br />输出：[]</p></blockquote><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="分析">分析</h2><p>思考关键点在于确定了第一个数后，相当于找到和为固定的其他两个数，就可以联想到两数之和的做法了。回顾下两数之和的做法：先对数组排序，然后使用双指针法。由于该题需要找出所有满足条件的三元组，那么就需要找到所有满足条件的两数。假设初始状态下，左右指针分别指向<code>1,4</code>，如下：</p><blockquote><p><font color='red'>1</font> 1 2 2 3 4 <font color='blue'>4</font></p></blockquote><p>这时使用双指针法有以下三种情况：</p><ul><li>左指针left指向的数与右指针指向的数之和大于目标值4，这时需要将右指针向左移动</li><li>左指针left指向的数与右指针指向的数之和小于目标值6，这时需要将左指针向右移动</li><li>左指针left指向的数与右指针指向的数之和等于目标值5，这时记录这个两数。为了找到所有满足条件的两个数（而且不能重复），需要继续遍历，这时显然将左指针向右移动直到所指向的值不是原来的值，将右指针向左移动直到所指向的值不是原来的值，此时左右指针分别指向<code>2,3</code></li></ul><blockquote><p>1 1 <font color='red'>2</font> 2 <font color='blue'>3</font> 4 4</p></blockquote><p>如此下去，直到左指针遇到右指针，就找到了所有满足条件的两个数了。</p><p>在遍历第一个数时，为了避免找到重复解，每到一个新数时可以和前面数比较，如果一样直接跳过，因为前面已经遍历过该数的情况了。</p><h2 id="算法">算法</h2><ol type="1"><li>对数组排序</li><li>遍历数组，下标<code>i</code>从<code>0</code>到<code>nums.length - 3</code>，如果<code>i&gt;0 &amp;&amp; nums[i]==nums[i-1]</code>，表示该数和前面一样，跳过该下标，遍历<code>i+1</code></li><li>进入循环，找到两数之和为<code>-nums[i]</code>，初始化左指针<code>left=i+1</code>，右指针<code>right=nums.length-1</code>，循环条件左指针比右指针小<code>left&lt;right</code></li><li>如果<code>nums[left]+nums[right]&gt;-nums[i]</code>，这时移动右指针<code>right--</code></li><li>如果<code>nums[left]+nums[right]&lt;-nums[i]</code>，这时移动右指针<code>left++</code></li><li>如果<code>nums[left]+nums[right]==-nums[i]</code>，记录三元组<code>[[nums[i], nums[left], nums[right]]</code>，并移动左指针直到<code>nums[left]!=nums[left+1]</code>，移动右指针直到<code>nums[right]!=nums[right-1]</code></li><li>回到3判断循环是否结束，如果结束回到2，否则继续4</li></ol><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums</span>):</span><br><span class="line">        nums.sort()</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = <span class="built_in">len</span>(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                <span class="keyword">if</span> nums[left] + nums[right] &gt; -nums[i]:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[left] + nums[right] &lt; -nums[i]:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i], nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left] == nums[left+<span class="number">1</span>]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[right] == nums[right-<span class="number">1</span>]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() &lt; <span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i]) right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i]) left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[left] == nums[left+<span class="number">1</span>])) left++;</span><br><span class="line">                    <span class="keyword">while</span> ((left &lt; right) &amp;&amp; (nums[right] == nums[right<span class="number">-1</span>])) right--;</span><br><span class="line">                    left++; right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] &gt; -nums[i])</span><br><span class="line">                    right--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; -nums[i])</span><br><span class="line">                    left++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    tmp.add(nums[i]);</span><br><span class="line">                    tmp.add(nums[left]);</span><br><span class="line">                    tmp.add(nums[right]);</span><br><span class="line">                    res.add(tmp);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限七：向量值函数的连续与一致连续</title>
      <link href="/2021/01/21/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%907/"/>
      <url>/2021/01/21/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%907/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1向量值函数">定义1：向量值函数</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^n\)</span>，定义<span class="math inline">\(\boldsymbol{f}: D\to \mathbb{R}^m\)</span>为向量值函数，其中<spanclass="math inline">\(D\)</span>称为<spanclass="math inline">\(\boldsymbol{f}\)</span>定义域，<spanclass="math inline">\(f(D)\)</span>称为值域。当用<spanclass="math inline">\(\boldsymbol{y} =\boldsymbol{f}(\boldsymbol{x})(\boldsymbol{x} \inD)\)</span>来表示这种映射时，<span class="math inline">\(\boldsymbol{x}\in \mathbb{R}^n, \boldsymbol{y} \in\mathbb{R}^m\)</span>。按分量形式写出<spanclass="math inline">\(\boldsymbol{x} = (x_1,x_2,\cdots,x_n),\boldsymbol{y}=(y_1,y_2,\cdots,y_m)\)</span>，那么该映射函数相当于给定了<spanclass="math inline">\(m\)</span>个<spanclass="math inline">\(n\)</span>元函数：<br /><span class="math display">\[\left\{    \begin{aligned}        &amp; y_1 = f_1(x_1,x_2,\cdots,x_n) \\        &amp; y_2 = f_2(x_1,x_2,\cdots,x_n) \quad (x_1,x_2,\cdots,x_n)\in D \subset \mathbb{R}^n \\        &amp; \cdots \\        &amp; y_m = f_m(x_1,x_2,\cdots,x_n)    \end{aligned}\right.\]</span><br />反过来也成立。也就是说，如果给定了<spanclass="math inline">\(m\)</span>个定义在<span class="math inline">\(D\subset \mathbb{R}^n\)</span>上的函数，就相当于给定了定义在<spanclass="math inline">\(D\)</span>上，映射到<spanclass="math inline">\(\mathbb{R}^m\)</span>中的一个映射，或者说在<spanclass="math inline">\(D\)</span>上定义了一个在<spanclass="math inline">\(\mathbb{R}^m\)</span>中取值的向量值函数。这一事实表示为<br /><span class="math display">\[    \boldsymbol{f} = (f_1,f_2,\cdots,f_m)\]</span><br />其中<span class="math inline">\(f_i: D \to \mathbb{R}\)</span>称为<spanclass="math inline">\(\boldsymbol{f}\)</span>的第<spanclass="math inline">\(i\)</span>个分量函数<spanclass="math inline">\((i=1,2,\cdots,m)\)</span></p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^m\)</span>，又设<span class="math inline">\(\boldsymbol{a}\in D^\prime, \boldsymbol{p}\in \mathbb{R}^m\)</span>。如果<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x} \in D\)</span>且<spanclass="math inline">\(0 &lt; \Vert \boldsymbol{x} - \boldsymbol{a} \Vert&lt; \delta\)</span>时，有<br /><span class="math display">\[    \Vert \boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{p} \Vert &lt;\varepsilon\]</span><br />则称映射<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{a}\)</span>处有极限<spanclass="math inline">\(p\)</span>，记为<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}}\boldsymbol{f}(\boldsymbol{x}) = \boldsymbol{p}\]</span><br />也可以简记为<br /><span class="math display">\[    \boldsymbol{f}(\boldsymbol{x}) \to \boldsymbol{p} \quad(\boldsymbol{x} \to \boldsymbol{a})\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m,\boldsymbol{a}\in D^\prime, \boldsymbol{p}=(p_1,p_2,\cdots,p_m)\in \mathbb{R}^m,\boldsymbol{f} = (f_1,f_2,\cdots,f_m)\)</span>。那么<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}}\boldsymbol{f}(\boldsymbol{x}) = \boldsymbol{p}\]</span><br />当且仅当<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}} f_i(\boldsymbol{x})= p_i \quad (i=1,2,\cdots,m)\]</span></p></blockquote><p>证：必要性。因为<span class="math inline">\(\Vert f_i(\boldsymbol{x})- p_i \Vert \le \Vert \boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{p}\Vert \quad (i=1,2,\cdots,m)\)</span>，所以<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x} \in D\)</span>且<spanclass="math inline">\(0 &lt; \Vert \boldsymbol{x} - \boldsymbol{a} \Vert&lt; \delta\)</span>时，有<br /><span class="math display">\[    | f_i(\boldsymbol{x}) - p_i | \le \Vert\boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{p} \Vert &lt; \varepsilon\]</span><br />这就表明<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}} f_i(\boldsymbol{x})= p_i \quad (i=1,2,\cdots,m)\]</span></p><p>充分性。因为<br /><span class="math display">\[    \Vert \boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{p} \Vert \le\sum_{i=1}^m |f_i(\boldsymbol{x}) - p_i|\]</span><br />对<span class="math inline">\(\varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(0 &lt; \Vert \boldsymbol{x} - \boldsymbol{a} \Vert&lt; \delta\)</span>时，有<spanclass="math inline">\(|f(\boldsymbol{x}_i) - p_i| &lt; \varepsilon / m\quad(i=1,2,\cdots,m)\)</span>，所以<br /><span class="math display">\[    \Vert \boldsymbol{f}(\boldsymbol{x}) - \boldsymbol{p} \Vert \le\sum_{i=1}^m |f_i(\boldsymbol{x}) - p_i| &lt; m \cdot\frac{\varepsilon}{m} = \varepsilon\]</span></p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f},\boldsymbol{g}: D \to\mathbb{R}^m,\boldsymbol{a} \in D^\prime\)</span>，并且<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}}\boldsymbol{f}(\boldsymbol{x}) = \boldsymbol{p}，\lim\limits_{\boldsymbol{x} \to \boldsymbol{a}}\boldsymbol{g}(\boldsymbol{x}) = \boldsymbol{q}\]</span><br />于是我们有：<br />（1）对任何<span class="math inline">\(\lambda \in\mathbb{R}\)</span>，可以得出<span class="math inline">\(\lim\limits_{\boldsymbol{x} \to \boldsymbol{a}}(\lambda\boldsymbol{f}(\boldsymbol{a})) = \lambda\boldsymbol{p}\)</span>。<br />（2）<span class="math inline">\(\lim \limits_{\boldsymbol{x} \to\boldsymbol{a}} (\boldsymbol{f}(\boldsymbol{x}) +\boldsymbol{g}(\boldsymbol{x})) = \boldsymbol{p} +\boldsymbol{q}\)</span></p></blockquote><p>证：利用不等式很容易证明。</p><p>Q.E.D.</p><h4 id="定义3连续映射">定义3：连续映射</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m,\boldsymbol{a}\in D\)</span>。如果<span class="math inline">\(\forall \varepsilon &gt;0\)</span>，<span class="math inline">\(\exists \delta &gt;0\)</span>，使得当<span class="math inline">\(\boldsymbol{x} \in D \capB_\delta(\boldsymbol{a})\)</span>时，有<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x}) \inB_\varepsilon(\boldsymbol{f}(\boldsymbol{a}))\)</span>，则称映射<spanclass="math inline">\(\boldsymbol{f}\)</span>在点<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续。当<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>中的每一点都连续，称映射<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(D\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的开集，<spanclass="math inline">\(\boldsymbol{f}:D \to \mathbb{R}^m\)</span>，<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>上连续的充分必要条件是，对任意的<spanclass="math inline">\(\mathbb{R}^m\)</span>上的开集<spanclass="math inline">\(G\)</span>，<spanclass="math inline">\(\boldsymbol{f}^{-1}(G)\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的开集。这里<br /><span class="math display">\[  \boldsymbol{f}^{-1}(G) = \{ \boldsymbol{x} \in D :\boldsymbol{f}(\boldsymbol{x}) \in G \}\]</span></p></blockquote><p>证：必要性。如果<spanclass="math inline">\(\boldsymbol{f}^{-1}(G)\)</span>是空集，自然是开集；如果非空，任取<spanclass="math inline">\(\boldsymbol{x}_0 \in\boldsymbol{f}^{-1}(G)\)</span>，则<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x_0}) \inG\)</span>，由于<spanclass="math inline">\(G\)</span>是开集，从而存在<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，使得<spanclass="math inline">\(B_\varepsilon(\boldsymbol{f}(\boldsymbol{x}_0))\subset G\)</span>。又因为<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处连续，从而存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x} \inB_\delta(\boldsymbol{x}_0)\)</span>时，有<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x}) \inB_\varepsilon(\boldsymbol{f}(\boldsymbol{x}_0)) \subsetG\)</span>，即<span class="math inline">\(\boldsymbol{x} \in\boldsymbol{f}^{-1}(G)\)</span>，从而<spanclass="math inline">\(B_\delta(\boldsymbol{x}_0) \subset\boldsymbol{f}^{-1}(G)\)</span>。这就说明<spanclass="math inline">\(\boldsymbol{f}^{-1}(G)\)</span>是开集。</p><p>充分性。任取<span class="math inline">\(\boldsymbol{x}_0 \inD\)</span>，对任意小的<span class="math inline">\(\varepsilon &gt;0\)</span>，取<spanclass="math inline">\(G=B_\varepsilon(\boldsymbol{f}(\boldsymbol{x}_0))\)</span>，可知<spanclass="math inline">\(G\)</span>是开集，利用条件知<spanclass="math inline">\(\boldsymbol{f}^{-1}(G)\)</span>也是开集。因为<spanclass="math inline">\(\boldsymbol{x}_0 \in\boldsymbol{f}^{-1}(G)\)</span>，从而存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得<spanclass="math inline">\(B_\delta(\boldsymbol{x}_0) \subset\boldsymbol{f}^{-1}(G)\)</span>。即对任意的<spanclass="math inline">\(\boldsymbol{x} \inB_\delta(\boldsymbol{x}_0)\)</span>，有<spanclass="math inline">\(\boldsymbol{f}(\boldsymbol{x}) \in G =B_\varepsilon(\boldsymbol{f}(\boldsymbol{x}_0))\)</span>。从而<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(\boldsymbol{x}_0\)</span>处连续。由于<spanclass="math inline">\(\boldsymbol{x}_0\)</span>是任取的，所以<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>上连续。</p><h4 id="定义4一致连续映射">定义4：一致连续映射</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to\mathbb{R}^m\)</span>，如果<span class="math inline">\(\forall\varepsilon &gt; 0\)</span>，<span class="math inline">\(\exists\delta&gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x},\boldsymbol{y} \inD\)</span>且<span class="math inline">\(\Vert \boldsymbol{x} -\boldsymbol{y} \Vert &lt; \delta\)</span>时，有<spanclass="math inline">\(\Vert \boldsymbol{f}(\boldsymbol{x}) -\boldsymbol{f}(\boldsymbol{y}) \Vert &lt;\varepsilon\)</span>，则称<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>上一致连续。</p></blockquote><h4 id="定理4">定理4</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m\)</span>是<spanclass="math inline">\(D\)</span>上一致连续当且仅当<spanclass="math inline">\(\boldsymbol{f}\)</span>的每一个分量函数在<spanclass="math inline">\(D\)</span>上一致连续。</p></blockquote><p>证：利用<span class="math inline">\(|f_i(\boldsymbol{x}) -f_i(\boldsymbol{y})| \le \Vert \boldsymbol{f}(\boldsymbol{x}) -\boldsymbol{f}(\boldsymbol{y}) \Vert\)</span>，很容易证明。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m\)</span>是<spanclass="math inline">\(D\)</span>上的连续映射。如果<spanclass="math inline">\(D\)</span>是紧致集，那么<spanclass="math inline">\(\boldsymbol{f}\)</span>在<spanclass="math inline">\(D\)</span>上是一致连续的。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/01/20/函数极限6/#定理1">函数极限六的定理1</a>证法一样。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m\)</span>是<spanclass="math inline">\(D\)</span>上的连续映射。如果<spanclass="math inline">\(D\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的连通集，那么<spanclass="math inline">\(\boldsymbol{f}(D)\)</span>是<spanclass="math inline">\(\mathbb{R}^m\)</span>中的连通集。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/01/20/函数极限6/#定理4">函数极限六的定理4</a>证法一样。</p><h4 id="定理7">定理7</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{f}: D \to \mathbb{R}^m\)</span>是<spanclass="math inline">\(D\)</span>上的连续映射。如果<spanclass="math inline">\(D\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中紧致集，那么<spanclass="math inline">\(\boldsymbol{f}(D)\)</span>是<spanclass="math inline">\(\mathbb{R}^m\)</span>中的紧致集。</p></blockquote><p>证：与<ahref="https://gamersover.github.io/2021/01/20/函数极限6/#定理2">函数极限六的定理2</a>证法一样。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 映射 </tag>
            
            <tag> 函数极限 </tag>
            
            <tag> 向量值函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限六：多变量函数的一致连续性</title>
      <link href="/2021/01/20/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%906/"/>
      <url>/2021/01/20/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%906/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1多变量函数的一致连续性">定义1：多变量函数的一致连续性</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>。如果<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x},\boldsymbol{y} \inD\)</span>，且<span class="math inline">\(\Vert \boldsymbol{x} -\boldsymbol{y} \Vert &lt; \delta\)</span>时，有<spanclass="math inline">\(|f(\boldsymbol{x}) - f(\boldsymbol{y})| &lt;\varepsilon\)</span>，则称<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上一致连续。</p></blockquote><span id="more"></span><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，且<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续，如果<spanclass="math inline">\(D\)</span>是紧致集，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上一致连续。</p></blockquote><p>证：反证法。如果<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上不一致连续，则存在一个<spanclass="math inline">\(\varepsilon_0 &gt; 0\)</span>，使得对任何<spanclass="math inline">\(i \in \mathbb{N}^*\)</span>，在<spanclass="math inline">\(D\)</span>中总可以找到两个点<spanclass="math inline">\(\boldsymbol{x}_i,\boldsymbol{y}_i\)</span>，当<spanclass="math inline">\(\Vert \boldsymbol{x}_i - \boldsymbol{y}_i \Vert&lt; 1/i\)</span>，有<br /><span class="math display">\[    |f(\boldsymbol{x}_i) - f(\boldsymbol{y}_i)| \ge \varepsilon_0\]</span><br />由于<spanclass="math inline">\(D\)</span>是紧致集，也是列紧集，从而在点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>中可以找出子列<spanclass="math inline">\(\{\boldsymbol{x}_{k_i}\}\)</span>收敛于点<spanclass="math inline">\(\boldsymbol{x} \in D\)</span>，此时有<br /><span class="math display">\[    \Vert \boldsymbol{y}_{k_i} - \boldsymbol{x} \Vert \le \Vert\boldsymbol{y}_{k_i} - \boldsymbol{x}_{k_i} \Vert + \Vert\boldsymbol{x}_{k_i} - \boldsymbol{x} \Vert \le \frac{1}{k_i} + \Vert\boldsymbol{x}_{k_i} - \boldsymbol{x} \Vert \le \frac{1}{i} + \Vert\boldsymbol{x}_{k_i} - \boldsymbol{x} \Vert\]</span><br />从而，当<span class="math inline">\(i \to \infty\)</span>，<spanclass="math inline">\(\boldsymbol{y}_{k_i} \to\boldsymbol{x}\)</span>，而<br /><span class="math display">\[    |f(\boldsymbol{x}_{k_i}) - f(\boldsymbol{y}_{k_i})| \ge\varepsilon_0\]</span><br />成立，在上式中，令<span class="math inline">\(i \to\infty\)</span>并由<spanclass="math inline">\(f\)</span>的连续性可知<br /><span class="math display">\[    0 = \Vert f(\boldsymbol{x}) - f(\boldsymbol{x}) \Vert \ge\varepsilon_0 &gt; 0\]</span><br />矛盾。</p><p>Q.E.D.</p><h4 id="定理2"><span id='theorem2'> 定理2<span></h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，且<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续，如果<spanclass="math inline">\(D\)</span>是紧致集，那么<spanclass="math inline">\(f\)</span>的值域<spanclass="math inline">\(f(D)\)</span>也是紧致集。</p></blockquote><p>证：任取<span class="math inline">\(f(D)\)</span>中的一个点列<spanclass="math inline">\(\{y_i\}\)</span>，那么在<spanclass="math inline">\(D\)</span>中存在一个点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>，使得<spanclass="math inline">\(f(\boldsymbol{x}_i) = y_i(i=1,2,\cdots)\)</span>，由于<spanclass="math inline">\(D\)</span>是列紧集，从而点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>存在一个子列<spanclass="math inline">\(\{\boldsymbol{x}_{k_i}\}\)</span>收敛于<spanclass="math inline">\(D\)</span>中的一点<spanclass="math inline">\(\boldsymbol{x}\)</span>，又由于<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(D\)</span>上的连续函数，所以<br /><span class="math display">\[    \lim \limits_{i \to \infty} f(\boldsymbol{x}_{k_i}) =f(\boldsymbol{x}) \in f(D)\]</span><br />这就表明从点列<spanclass="math inline">\(\{y_i\}\)</span>中找到了一个子列<spanclass="math inline">\(\{y_{k_i}\}\)</span>，有<br /><span class="math display">\[    \lim \limits_{i \to \infty} y_{k_i} = \lim \limits_{i \to \infty}f(\boldsymbol{x}_{k_i}) = f(\boldsymbol{x}) \in f(D)\]</span><br />即子列<span class="math inline">\(\{y_{k_i}\}\)</span>收敛于<spanclass="math inline">\(f(D)\)</span>中的点。因为点列<spanclass="math inline">\(\{y_i\}\)</span>是任取的，所以<spanclass="math inline">\(f(D)\)</span>是紧致集。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，且<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续，如果<spanclass="math inline">\(D\)</span>是紧致集，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上能取到它的最小值和最大值。</p></blockquote><p>证：由<a href="#theorem2">定理2</a>可知，<spanclass="math inline">\(f(D)\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>上的紧致集，即有界闭集，从而<spanclass="math inline">\(f(D)\)</span>有上确界和下确界。设<br /><span class="math display">\[    M = \sup f(D)， \qquad m = \inf f(D)\]</span><br />由上确界的定义可知，对任意的<span class="math inline">\(i \in\mathbb{N}^*\)</span>，存在<span class="math inline">\(\boldsymbol{x}_i\in D\)</span>，使得<br /><span class="math display">\[    M - \frac{1}{i} &lt; f(\boldsymbol{x}_i) &lt; M\]</span><br />令<span class="math inline">\(i \to \infty\)</span>，可得<spanclass="math inline">\(\lim \limits_{i \to \infty} f(\boldsymbol{x}_{i})= M\)</span>，由于<span class="math inline">\(f(\boldsymbol{x}_{i}) \inD\)</span>，且<span class="math inline">\(f(D)\)</span>是闭集，可知<spanclass="math inline">\(M \in f(D)\)</span>，同理可证<spanclass="math inline">\(m \in f(D)\)</span>。</p><p>Q.E.D.</p><h4 id="定理4"><span id="theorem4">定理4</span></h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^n\)</span>是一连通集，函数<span class="math inline">\(f: D\to \mathbb{R}\)</span>是连续的，那么<spanclass="math inline">\(f(D)\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>中的连通集。</p></blockquote><p>证：设有分解式<span class="math inline">\(f(D) = A \cupB\)</span>，其中<spanclass="math inline">\(A,B\)</span>是不相交的非空集，从而<br /><span class="math display">\[    D = f^{-1}(A) \cup f^{-1}(B)\]</span><br />利用映射的概念易证<span class="math inline">\(f^{-1}(A)\)</span>和<spanclass="math inline">\(f^{-1}(B)\)</span>是非空集且不相交。利用<spanclass="math inline">\(D\)</span>是连通集的性质，不妨设<spanclass="math inline">\(f^{-1}(A)\)</span>中包含<spanclass="math inline">\(f^{-1}(B)\)</span>中的凝聚点，即<spanclass="math inline">\(f^{-1}(B)\)</span>中有点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于<spanclass="math inline">\(f^{-1}(A)\)</span>中的点<spanclass="math inline">\(\boldsymbol{x}\)</span>。由于函数<spanclass="math inline">\(f\)</span>是连续函数，所以<spanclass="math inline">\(f(\boldsymbol{x}_i) \to f(\boldsymbol{x}) (i \to\infty)\)</span>，而<span class="math inline">\(\{f(\boldsymbol{x}_i)\}\subset B\)</span>，<span class="math inline">\(f(\boldsymbol{x}) \inA\)</span>，这就表明$A B^{} $。</p><p>Q.E.D.</p><h4 id="定理5介值定理">定理5：介值定理</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R}^n\)</span>是一连通集，函数<span class="math inline">\(f: D\to \mathbb{R}\)</span>是连续的，如果<spanclass="math inline">\(\boldsymbol{a},\boldsymbol{b} \inD\)</span>和<span class="math inline">\(r \in\mathbb{R}\)</span>使得<br /><span class="math display">\[    f(\boldsymbol{a}) &lt; r &lt; f(\boldsymbol{b})\]</span><br />那么存在<span class="math inline">\(\boldsymbol{c} \inD\)</span>，使得<span class="math inline">\(f(\boldsymbol{c}) =r\)</span>。</p></blockquote><p>证：由<a href="#theorem4">定理4</a>可知，<spanclass="math inline">\(f(D)\)</span>是<spanclass="math inline">\(\mathbb{R}\)</span>连通集，再由<ahref="https://gamersover.github.io/2020/11/10/点列极限6/#定理4">点列极限六的定理4</a>可知<spanclass="math inline">\(f(D)\)</span>是区间。从而区间<spanclass="math inline">\([f(\boldsymbol{a}), f(\boldsymbol{b})] \subsetf(D)\)</span>，可得<span class="math inline">\(r \inf(D)\)</span>，所以存在点<span class="math inline">\(\boldsymbol{c} \inD\)</span>，使得<span class="math inline">\(f(\boldsymbol{c}) =r\)</span>。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 多变量函数 </tag>
            
            <tag> 函数极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限五：多变量函数的极限与连续性</title>
      <link href="/2021/01/18/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%905/"/>
      <url>/2021/01/18/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%905/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1">定义1</h4><blockquote><p>设<span class="math inline">\(D \subset\mathbb{R^n}\)</span>，那么映射<span class="math inline">\(f: D \to\mathbb{R}\)</span>称为一个<spanclass="math inline">\(n\)</span>元函数，其中<spanclass="math inline">\(D\)</span>称为函数<spanclass="math inline">\(f\)</span>的定义域，而<spanclass="math inline">\(f(D) \subset \mathbb{R}\)</span>称为<spanclass="math inline">\(f\)</span>的值域。</p></blockquote><span id="more"></span><h4 id="定义2">定义2</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R^n}\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，点<spanclass="math inline">\(\boldsymbol{a} \in \mathbb{R^n}\)</span>是<spanclass="math inline">\(D\)</span>的一个凝聚点（即<spanclass="math inline">\(\boldsymbol{a} \in D^\prime\)</span>），又设<spanclass="math inline">\(l\)</span>是一个实数。如果对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，当<spanclass="math inline">\(0 &lt; \Vert \boldsymbol{x} - \boldsymbol{a} \Vert&lt; \delta\)</span>时，有<br /><span class="math display">\[    |f(\boldsymbol{x}) - l| &lt; \varepsilon\]</span><br />我们称函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{a}\)</span>处有极限<spanclass="math inline">\(l\)</span>，也就是说当<spanclass="math inline">\(\boldsymbol{x}\)</span>趋向于<spanclass="math inline">\(\boldsymbol{a}\)</span>时，<spanclass="math inline">\(f(\boldsymbol{x})\)</span>趋向于<spanclass="math inline">\(l\)</span>，记作<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}} f(\boldsymbol{x}) =l\]</span><br />也可记作<br /><span class="math display">\[    f(\boldsymbol{x}) \to l \quad (\boldsymbol{x} \to \boldsymbol{a})\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R^n}\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，点<spanclass="math inline">\(\boldsymbol{a} \inD^\prime\)</span>。函数极限<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}} f(\boldsymbol{x}) =l\]</span><br />的充分必要条件是，对任何的点列<spanclass="math inline">\(\{\boldsymbol{x}_i\} \subset D\)</span>，<spanclass="math inline">\(\boldsymbol{x}_i \ne \boldsymbol{a}(i=1,2,3,\cdots)\)</span>且<span class="math inline">\(\boldsymbol{x}_i\to \boldsymbol{a} (i \to \infty)\)</span>，数列极限<br /><span class="math display">\[    \lim \limits_{i \to \infty} f(\boldsymbol{x}_i) = l\]</span></p></blockquote><p>证：必要性。有函数极限定义可知，对<span class="math inline">\(\forall\varepsilon &gt; 0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，使得当<span class="math inline">\(0 &lt; \Vert\boldsymbol{x} - \boldsymbol{a} \Vert &lt; \delta\)</span>时，有<spanclass="math inline">\(|f(\boldsymbol{x}) - f(\boldsymbol{a})| &lt;\varepsilon\)</span>；由于<span class="math inline">\(\boldsymbol{x}_i\to \boldsymbol{a} (i \to \infty)\)</span>，从而对于给定的<spanclass="math inline">\(\delta\)</span>，存在<span class="math inline">\(N\in \mathbb{N^+}\)</span>，使得当<span class="math inline">\(i &gt;N\)</span>时，有<span class="math inline">\(0 &lt; \Vert\boldsymbol{x}_i - \boldsymbol{a}| &lt; \delta\)</span>，从而<spanclass="math inline">\(|f(\boldsymbol{x}_i) - f(\boldsymbol{a})| &lt;\varepsilon\)</span>，即<span class="math inline">\(\lim \limits_{i \to\infty} f(\boldsymbol{x}_i) = l\)</span></p><p>充分性。反证法。假设<span class="math inline">\(f\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处不以<spanclass="math inline">\(l\)</span>为极限，则存在<spanclass="math inline">\(\varepsilon_0 &gt; 0\)</span>，使得对任意的<spanclass="math inline">\(i \in \mathbb{N^+}\)</span>，可以取出一个点<spanclass="math inline">\(\boldsymbol{x}_i \in D\)</span>，使得当<spanclass="math inline">\(|\boldsymbol{x}_i - \boldsymbol{a}| &lt;1/i\)</span>时，有<span class="math inline">\(|f(\boldsymbol{x}_i) -f(\boldsymbol{a})| \ge \varepsilon_0\)</span>，这时点列<spanclass="math inline">\(\{\boldsymbol{x}_i\} \subset D\)</span>，且<spanclass="math inline">\(\boldsymbol{x}_i \to \boldsymbol{a} (i \to\infty)\)</span>，但是数列<spanclass="math inline">\(\{f(\boldsymbol{x}_i)\}\)</span>显然不以<spanclass="math inline">\(l\)</span>为极限，矛盾。</p><p>Q.E.D.</p><h4 id="定理2函数极限的四则运算">定理2：函数极限的四则运算</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R^n}\)</span>，<spanclass="math inline">\(f,g: D \to \mathbb{R}\)</span>，点<spanclass="math inline">\(\boldsymbol{a} \in D^\prime\)</span>。如果<spanclass="math inline">\(f,g\)</span>存在着有限的极限：<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}} f(\boldsymbol{x}) =l, \qquad \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}}g(\boldsymbol{x}) = m\]</span><br />那么有：<br />（1）<span class="math inline">\(\lim \limits_{\boldsymbol{x} \to\boldsymbol{a}} (f \pm g)(\boldsymbol{x}) = l \pm m\)</span>；<br />（2）<span class="math inline">\(\lim \limits_{\boldsymbol{x} \to\boldsymbol{a}} fg(\boldsymbol{x}) = lm\)</span>；<br />（3）<span class="math inline">\(\lim \limits_{\boldsymbol{x} \to\boldsymbol{a}} (\frac{f}{g})(\boldsymbol{x}) =\frac{l}{m}\)</span>，其中<span class="math inline">\(m \ne0\)</span>。</p></blockquote><p>证：证明方法与单变量极限四则运算几乎一样。参考<ahref="https://gamersover.github.io/2020/11/17/函数极限1/#定理4：函数极限四则运算">函数极限一的定理4</a>。</p><p>Q.E.D.</p><h4 id="定理3复合函数极限">定理3：复合函数极限</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在以<spanclass="math inline">\(\boldsymbol{a} \in\mathbb{R}^n\)</span>为球心，<spanclass="math inline">\(\boldsymbol{r}\)</span>为半径的某个空心球<spanclass="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{\checka})\)</span>上有定义，且<span class="math inline">\(\lim\limits_{\boldsymbol{x} \to \boldsymbol{a}} f(\boldsymbol{x}) =l\)</span>；一元函数<spanclass="math inline">\(\varphi\)</span>在以<spanclass="math inline">\(l\)</span>为球心的空心球<spanclass="math inline">\(U = \{t: 0&lt;|t - l| &lt; \delta\}\)</span>上有定义，且<span class="math inline">\(\lim \limits_{t \tol} \varphi(t) = m\)</span>。再设<br /><span class="math display">\[    f(B_{\boldsymbol{r}}(\boldsymbol{\check a})) \in U\]</span><br />那么就有<br /><span class="math display">\[    \lim \limits_{\boldsymbol{x} \to \boldsymbol{a}}\varphi(f(\boldsymbol{x})) = m\]</span></p></blockquote><p>证：与单变量复合函数极限证明方法一样。参考<ahref="https://gamersover.github.io/2020/11/17/函数极限1/#定理8">函数极限一的定理8</a>。</p><p>Q.E.D.</p><h4 id="定理4cauchy收敛原理">定理4：Cauchy收敛原理</h4><blockquote><p>设<span class="math inline">\(D \in \mathbb{R}^n\)</span>，<spanclass="math inline">\(\boldsymbol{a} \in D^\prime\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>。那么极限<spanclass="math inline">\(\lim \limits_{\boldsymbol{x} \to\boldsymbol{a}}f(\boldsymbol{x})\)</span>存在的充分必要条件是，对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x}^\prime,\boldsymbol{x}^{\prime\prime}\in D\)</span>且<br /><span class="math display">\[    0 &lt; \Vert \boldsymbol{x}^\prime - \boldsymbol{a} \Vert &lt;\delta \quad 0 &lt; \Vert \boldsymbol{x}^{\prime\prime} - \boldsymbol{a}\Vert &lt; \delta\]</span><br />同时成立时，一定有<span class="math inline">\(|f(\boldsymbol{x}^\prime)- f(\boldsymbol{x}^{\prime\prime})| &lt; \varepsilon\)</span>。</p></blockquote><p>证：与证明单变量的Cauchy收敛原理类似。参考<ahref="https://gamersover.github.io/2020/11/17/函数极限1/#定理7：Cauchy收敛原理">函数极限一定理7</a>。</p><p>Q.E.D.</p><h4 id="定义3多变量连续函数">定义3：多变量连续函数</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R}^n\)</span>，<spanclass="math inline">\(f: D \to \mathbb{R}\)</span>，<spanclass="math inline">\(\boldsymbol{a} \in D\)</span>。如果对<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(\boldsymbol{x} \in D \capB_\delta(\boldsymbol{a})\)</span>，有<br /><span class="math display">\[    |f(\boldsymbol{x}) - f(\boldsymbol{a})| &lt; \varepsilon\]</span><br />则称函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续，<spanclass="math inline">\(\boldsymbol{a}\)</span>称为<spanclass="math inline">\(f\)</span>的一个连续点，<spanclass="math inline">\(D\)</span>中<spanclass="math inline">\(f\)</span>的非连续点称为<spanclass="math inline">\(f\)</span>的间断点。如果<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>中的每个点上都连续，则称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续。</p></blockquote><p>注：设<spanclass="math inline">\(D=\{\boldsymbol{p}_1,\boldsymbol{p}_2,\cdots,\boldsymbol{p}_m\}\)</span>，定义函数<span class="math inline">\(f: D \to\mathbb{R}\)</span>为<span class="math inline">\(f(\boldsymbol{p}_i) =\lambda_i (i=1,2,\cdots,m)\)</span>，这里<spanclass="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_m\)</span>是任意给定的数，那么根据定义3，<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>上连续。对于单变量函数也成立，比如定义域<spanclass="math inline">\(D=\{a\}\)</span>，且<spanclass="math inline">\(f(a)\)</span>存在，这时<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(D\)</span>内连续。这与<ahref="https://gamersover.github.io/2020/12/08/函数极限3/#定义1：某点连续">函数极限三的定义1</a>不矛盾，单变量点连续定义的时候<spanclass="math inline">\(D\)</span>为非单点闭区间，且极限值等于函数值，这种定义不包含孤立点的情况，所以单变量连续函数的真正定义也囊括在本章的定义3中。</p><h4id="定理5多变量连续函数的四则运算">定理5：多变量连续函数的四则运算</h4><blockquote><p>设<span class="math inline">\(D \subset \mathbb{R^n}\)</span>，<spanclass="math inline">\(f,g: D \to \mathbb{R}\)</span>，点<spanclass="math inline">\(\boldsymbol{a} \in D\)</span>。如果<spanclass="math inline">\(f,g\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续，那么<spanclass="math inline">\(f \pm g\)</span>和<spanclass="math inline">\(fg\)</span>都在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续，如果<spanclass="math inline">\(g(\boldsymbol{a}) \ne 0\)</span>，那么<spanclass="math inline">\(f/g\)</span>也在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续。</p></blockquote><p>证：类似单变量极限的四则运算证明，这里以证明<spanclass="math inline">\(f+g\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续为例，其他类似证明方法。由题意可知，<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta_1 &gt; 0\)</span>，使得当<spanclass="math inline">\(x \in D \capB_{\delta_1}(\boldsymbol{a})\)</span>时，有<spanclass="math inline">\(|f(\boldsymbol{x}) - f(\boldsymbol{a})| &lt;\varepsilon / 2\)</span>；<span class="math inline">\(\exists \delta_2&gt; 0\)</span>，使得当<span class="math inline">\(x \in D \capB_{\delta_2}(\boldsymbol{a})\)</span>时，有<spanclass="math inline">\(|g(\boldsymbol{x}) - g(\boldsymbol{a})| &lt;\varepsilon / 2\)</span>。令<span class="math inline">\(\delta =\min(\delta_1, \delta_2)\)</span>，从而当<span class="math inline">\(x\in D \cap B_{\delta}(\boldsymbol{a})\)</span>时，有<br /><span class="math display">\[    |f(\boldsymbol{x}) + g(\boldsymbol{x}) - (f(\boldsymbol{a}) +g(\boldsymbol{a}))| \le |f(\boldsymbol{x}) - f(\boldsymbol{a})| +|g(\boldsymbol{x}) - g(\boldsymbol{a})| &lt; \frac{\varepsilon}{2} +\frac{\varepsilon}{2} = \varepsilon\]</span><br />这就表明<span class="math inline">\(f+g\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在以<spanclass="math inline">\(\boldsymbol{a} \in\mathbb{R}^n\)</span>为球心，<spanclass="math inline">\(\boldsymbol{r}\)</span>为半径的某个球<spanclass="math inline">\(B_{\boldsymbol{r}}(\boldsymbol{a})\)</span>上有定义，且在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续；一元函数<spanclass="math inline">\(\varphi\)</span>在<span class="math inline">\(U =\{t: 0&lt;|t - l| &lt; \delta \}\)</span>上有定义，且且在<spanclass="math inline">\(l\)</span>处连续，则函数<spanclass="math inline">\(\varphi(f(\boldsymbol{x}))\)</span>在<spanclass="math inline">\(\boldsymbol{a}\)</span>处连续。</p></blockquote><p>证：与单变量复合函数极限证明方法类似。参考<ahref="https://gamersover.github.io/2020/11/17/函数极限1/#定理8">函数极限一的定理8</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 多变量函数 </tag>
            
            <tag> 函数极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限四：初等连续函数与函数的上下极限</title>
      <link href="/2021/01/11/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%904/"/>
      <url>/2021/01/11/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%904/</url>
      
        <content type="html"><![CDATA[<p>基本连续函数有哪些？这章来解答。</p><h4 id="定理1">定理1</h4><blockquote><p>如果函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，那么<spanclass="math inline">\(f \pm g\)</span>与<spanclass="math inline">\(fg\)</span>都在<spanclass="math inline">\(x_0\)</span>处连续，如果<spanclass="math inline">\(g(x_0) \ne 0\)</span>，那么<spanclass="math inline">\(f/g\)</span>也在<spanclass="math inline">\(x_0\)</span>处连续。</p></blockquote><span id="more"></span><p>证：利用极限的四则运算性质，易证。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设函数<span class="math inline">\(g\)</span>在<spanclass="math inline">\(t_0\)</span>处连续，记<spanclass="math inline">\(g(t_0)\)</span>为<spanclass="math inline">\(x_0\)</span>，如果函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，那么复合函数<spanclass="math inline">\(f \circ g\)</span>在<spanclass="math inline">\(t_0\)</span>处连续。</p></blockquote><p>证：由题意可知，<span class="math inline">\(\lim \limits_{x \to x_0}f(x) = f(x_0)\)</span>，<span class="math inline">\(\lim \limits_{t \tot_0} g(t) = g(t_0) = x_0\)</span>；</p><p>从而对任意<span class="math inline">\(\varepsilon &gt;0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，使得当<span class="math inline">\(0 &lt; |x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span>；</p><p>当<span class="math inline">\(x = x_0\)</span>时，<spanclass="math inline">\(|f(x_0) - f(x_0)| = 0 &lt;\varepsilon\)</span>，从而上述描述可以修改为当<spanclass="math inline">\(|x - x_0| &lt; \delta\)</span>时，有<spanclass="math inline">\(|f(x) - f(x_0)| &lt;\varepsilon\)</span>；对于给定的<span class="math inline">\(\delta &gt;0\)</span>，存在<span class="math inline">\(\eta &gt;0\)</span>，使得当<span class="math inline">\(0 &lt;|t - t_0| &lt;\eta\)</span>时，有<span class="math inline">\(|g(t) - x_0| &lt;\delta\)</span>，从而有<span class="math inline">\(|f(g(t)) - f(x_0)|&lt; \varepsilon\)</span>，所以<span class="math inline">\(\lim\limits_{t \to t_0} f(g(t)) = f(x_0) = f(g(t_0))\)</span>。</p><p>Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(f\)</span>是在区间<spanclass="math inline">\(I\)</span>上严格递增（减）的连续函数，那么<spanclass="math inline">\(f^{-1}\)</span>是<spanclass="math inline">\(f(I)\)</span>上的严格递增（减）的连续函数。</p></blockquote><p>证：由<ahref="https://gamersover.github.io/2020/12/08/函数极限3/#定理10">函数极限三的定理10</a>可知，<spanclass="math inline">\(J=f(I)\)</span>也是一个区间。不妨假设<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>严格递增，任取<spanclass="math inline">\(y_0 \in J\)</span>，令<spanclass="math inline">\(x_0 = f^{-1}(y_0)\)</span>，即<spanclass="math inline">\(f(x_0) = y_0\)</span>，任意给定<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，使得<spanclass="math inline">\(x_0 - \varepsilon，x_0+\varepsilon \inI\)</span>，记<br /><span class="math display">\[    \begin{aligned}    \delta_1 &amp; = y_0 - f(x_0 - \varepsilon) &gt; 0 \\    \delta_2 &amp; = f(x_0 + \varepsilon) - y_0 &gt; 0 \\    \delta &amp; = \min(\delta_1, \delta_2)    \end{aligned}\]</span><br />当<span class="math inline">\(|y - y_0| &lt; \delta\)</span>时，有<br /><span class="math display">\[    y_0 - \delta_1 \le y_0 - \delta &lt; y &lt; y_0 + \delta \le y_0 +\delta_2\]</span><br />由<span class="math inline">\(f^{-1}\)</span>严格递增的性质，可知<br /><span class="math display">\[    f^{-1}(y_0 - \delta_1) \le f^{-1}(y_0 - \delta) &lt; f^{-1}(y) &lt;f^{-1}(y_0 + \delta) \le f^{-1}(y_0 + \delta_2)\]</span><br />即<br /><span class="math display">\[    x_0 - \varepsilon &lt; f^{-1}(y) &lt; x_0 + \varepsilon \Rightarrow|f^{-1}(y) - f^{-1}(y_0)| &lt; \varepsilon\]</span><br />所以<span class="math inline">\(f^{-1}\)</span>在<spanclass="math inline">\(y_0\)</span>处连续。由于<spanclass="math inline">\(y_0\)</span>是在<spanclass="math inline">\(J\)</span>上任取的，从而<spanclass="math inline">\(f^{-1}\)</span>在<spanclass="math inline">\(J\)</span>上连续。</p><p>Q.E.D.</p><h4id="定理4初等函数在它们各自的定义域上都是连续的">定理4：初等函数在它们各自的定义域上都是连续的。</h4><p>证：在已证明定理1，2，3后；由于<span class="math inline">\(f(x) =x\)</span>是连续函数，所以多项式函数也是连续函数；由于<spanclass="math inline">\(f(x) = \sinx\)</span>是连续函数，从而三角函数是连续函数，反三角函数也是连续函数；由于<spanclass="math inline">\(f(x)=x^n\)</span>是多项式，也是连续函数，所以<spanclass="math inline">\(f^{-1}(x)=x^{1/n}\)</span>也是连续函数，从而对任何的有理数<spanclass="math inline">\(r\)</span>，<spanclass="math inline">\(x^r\)</span>在<span class="math inline">\([0,+\infty)\)</span>上是连续的；指数函数<spanclass="math inline">\(a^x\)</span>，当<spanclass="math inline">\(a&gt;1\)</span>时，是连续函数，其反函数<spanclass="math inline">\(\log_a x\)</span>是<spanclass="math inline">\((0,+\infty)\)</span>上的连续函数，从而指数函数和对数函数都是连续函数；对幂函数<spanclass="math inline">\(f(x) = x^\mu (x&gt;0, \mu为任意实数)\)</span>，该函数可等价为<span class="math inline">\(f(x) =e^{\mu \ln x}\)</span>指数函数，自然也是连续的。</p><p>将多项式函数、幂函数、指数函数、对数函数、三角函数与反三角函数以及由它们经过有限次的四则运算、有限次复合所形成的函数统称为初等函数。由上可知初等函数在其各自的定义域上都是连续函数。</p><p>Q.E.D.</p><h4 id="定义1">定义1</h4><blockquote><p>记<span class="math inline">\(\mathbb{R}_{\infty} = \mathbb{R} \cup\{-\infty, +\infty\}\)</span>；设函数<spanclass="math inline">\(f\)</span>定义在<spanclass="math inline">\(B_{\delta}(\check x_0)\)</span>上，令<br /><span class="math display">\[    E = \{ l \in \mathbb{R}_{\infty}: 存在数列x_n \in B_{\delta}(\checkx_0), x_n \to x_0, 使得f(x_n) \to l \}\]</span><br />这是一个非空的集合。设<span class="math inline">\(a^* = \sup E, a_* =\inf E\)</span>，分别称它们为<spanclass="math inline">\(f\)</span>当<span class="math inline">\(x \tox_0\)</span>时的上极限和下极限，分别记作<br /><span class="math display">\[    \limsup_{x \to x_0} f(x), \qquad \liminf_{x \to x_0} f(x)\]</span><br />对其他极限过程，例如<span class="math inline">\(x \to x_0^{+}，x \tox_0^{-}，x \to -\infty， x \to +\infty\)</span>以及<spanclass="math inline">\(x \to \infty\)</span>都可以类似的定义函数<spanclass="math inline">\(f\)</span>的上极限和下极限。</p></blockquote><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>定义在<spanclass="math inline">\(I\)</span>上，那么：<br />（1）<span class="math inline">\(a^* \in E\)</span>；<br />（2）若<span class="math inline">\(y &gt; a^*\)</span>，则存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>时，有<spanclass="math inline">\(f(x) &lt; y\)</span>；<br />（3）<spanclass="math inline">\(a^*\)</span>是满足前述两条性质的唯一的数。</p></blockquote><p>证：（1）若<span class="math inline">\(a^* =+\infty\)</span>，则任何<span class="math inline">\(n \in\mathbb{N}^*\)</span>，存在<span class="math inline">\(l_n \inE\)</span>，使得<span class="math inline">\(l_n &gt;n\)</span>；由于<span class="math inline">\(l_n\)</span>在<spanclass="math inline">\(E\)</span>中，从而存在<spanclass="math inline">\(x_n\)</span>，使得当<span class="math inline">\(0&lt; |x_n - x_0| &lt; 1/n\)</span>，有<span class="math inline">\(f(x_n)&gt; n\)</span>，这表明<span class="math inline">\(x_n \inI\)</span>，<span class="math inline">\(x_n \to x_0\)</span>时，<spanclass="math inline">\(f(x_n) \to +\infty\)</span>，即<spanclass="math inline">\(a^*=+\infty \in E\)</span>；</p><p>若<span class="math inline">\(a^* = -\infty\)</span>，则<spanclass="math inline">\(E = \{-\infty\}\)</span>，自然有<spanclass="math inline">\(a^* \in E\)</span>；</p><p>若<span class="math inline">\(a^*\)</span>为有限数，对任何<spanclass="math inline">\(n \in \mathbb{N}^*\)</span>，存在<spanclass="math inline">\(l_n \in E\)</span>，使得<br /><span class="math display">\[    a^* - \frac{1}{n} &lt; l_n &lt; a^* + \frac{1}{n}\]</span><br />从而存在<span class="math inline">\(x_n\)</span>满足<spanclass="math inline">\(0&lt; |x_n - x_0| &lt; 1/n\)</span>使得<br /><span class="math display">\[   a^* - \frac{1}{n} &lt; f(x_n) &lt; a^*+\frac{1}{n}\]</span><br />从而<span class="math inline">\(x_n \in I\)</span>且<spanclass="math inline">\(x_n \to x_0\)</span>时有<spanclass="math inline">\(f(x_n) \to a^*\)</span>，即<spanclass="math inline">\(a^* \in E\)</span></p><p>（2）反证法。假设对任意的<span class="math inline">\(n \in\mathbb{N}^*\)</span>，存在<spanclass="math inline">\(x_n\)</span>，使得<spanclass="math inline">\(0&lt; |x_n - x_0| &lt; 1/n\)</span>时，有<spanclass="math inline">\(f(x_n)\ge y\)</span>，从而存在子列<spanclass="math inline">\(\{k_n\}\)</span>，使得<spanclass="math inline">\(f(x_{k_n}) \to y_1 (n \to\infty)\)</span>，此时有<span class="math inline">\(y_1 \ge y &gt;a^*\)</span>，且<span class="math inline">\(y_1 \inE\)</span>，从而与<spanclass="math inline">\(a^*\)</span>的定义矛盾。</p><p>（3）反证法。假设存在两个数<spanclass="math inline">\(p\)</span>和<spanclass="math inline">\(q\)</span>同时满足（1）与（2），不妨设<spanclass="math inline">\(p &lt; q\)</span>，选取<spanclass="math inline">\(y\)</span>，满足<span class="math inline">\(p &lt;y &lt; q\)</span>，由于<spanclass="math inline">\(p\)</span>满足（2），从而存在<spanclass="math inline">\(\delta &gt; 0\)</span>，当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>，有<spanclass="math inline">\(f(x) &lt; y\)</span>，此时<spanclass="math inline">\(q\)</span>不能满足（1）。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>定义在<spanclass="math inline">\(I\)</span>上，那么：<br />（1）<span class="math inline">\(a_* \in E\)</span>；<br />（2）若<span class="math inline">\(y &lt; a_*\)</span>，则存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>时，有<spanclass="math inline">\(y &lt; f(x)\)</span>；<br />（3）<spanclass="math inline">\(a_*\)</span>是满足前述两条性质的唯一的数。</p></blockquote><p>证：与定理5的证明几乎一样。</p><p>Q.E.D.</p><h4 id="定理7">定理7</h4><blockquote><p>设<span class="math inline">\(f,g\)</span>在<spanclass="math inline">\(I\)</span>上有定义，<spanclass="math inline">\(x_0 \in I\)</span>，那么：<br />（1）<span class="math inline">\(\liminf \limits_{x \to x_0} f(x) \le\limsup \limits_{x \to x_0} f(x)\)</span><br />（2）<span class="math inline">\(\lim \limits_{x \to x_0} f(x) =a\)</span>当且仅当<span class="math inline">\(\liminf \limits_{x \tox_0} f(x) = \limsup \limits_{x \to x_0} f(x) = a\)</span>；<br />（3）若当<span class="math inline">\(x \in I\)</span>时，有<spanclass="math inline">\(f(x) \le g(x)\)</span>成立，则<br /><span class="math display">\[    \liminf_{x \to x_0} f(x) \le \liminf_{x \to x_0} g(x)，\qquad\limsup_{x \to x_0} f(x) \le \limsup_{x \to x_0} g(x)\]</span></p></blockquote><p>证：（1）（2）有上极限与下极限的定义易证。下面只证明（3）中的第二个不等式，第一个不等式是类似的证明。<br />令<br /><span class="math display">\[    a^* = \limsup_{x \to x_0} f(x), \qquad b^* = \limsup_{x \to x_0}g(x)\]</span><br />存在子数列<span class="math inline">\(x_n \in I\)</span>，且<spanclass="math inline">\(x_n \to x_0\)</span>，使得<spanclass="math inline">\(\lim \limits_{n \to \infty} f(x_n) =a^*\)</span>，由于<span class="math inline">\(f(x_n) \leg(x_n)\)</span>，从<spanclass="math inline">\(\{x_n\}\)</span>中可以选取子列<spanclass="math inline">\(\{x_{k_n}\}\)</span>，使得<br /><span class="math display">\[    \lim \limits_{n \to \infty} g(x_{k_n}) = b \ge a^* = \lim \limits_{n\to \infty} f(x_{k_n})\]</span><br />从而有<span class="math inline">\(b^* \ge b \ge a^*\)</span>，即<spanclass="math inline">\(b^* \ge a^*\)</span>。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数极限 </tag>
            
            <tag> 连续函数 </tag>
            
            <tag> 上极限与下极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解11：盛最多水的容器</title>
      <link href="/2021/01/11/leetcode%E9%A2%98%E8%A7%A311/"/>
      <url>/2021/01/11/leetcode%E9%A2%98%E8%A7%A311/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于力扣<ahref="https://leetcode-cn.com/problems/container-with-most-water/">第11题</a></p><p>给你<code>n</code>个非负整数<code>a1，a2，...，an</code>，每个数代表坐标中的一个点<code>(i, ai)</code>。在坐标内画<code>n</code>条垂直线，垂直线<code>i</code>的两个端点分别为<code>(i, ai)</code>和<code>(i, 0)</code>。找出其中的两条线，使得它们与<code>x</code>轴共同构成的容器可以容纳最多的水。</p><span id="more"></span><p>说明：你不能倾斜容器。</p><p>示例 1：</p><blockquote><p>输入：[1,8,6,2,5,4,8,3,7]<br />输出：49<br />解释：图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</p></blockquote><p>示例 2：</p><blockquote><p>输入：height = [1,1]<br />输出：1</p></blockquote><p>示例 3：</p><blockquote><p>输入：height = [4,3,2,1,4]<br />输出：16</p></blockquote><p>示例 4：</p><blockquote><p>输入：height = [1,2,1]<br />输出：2</p></blockquote><p>提示：</p><ul><li><code>n = height.length</code></li><li><code>2 &lt;= n &lt;= 3 * 104</code></li><li><code>0 &lt;= height[i] &lt;= 3 * 104</code></li></ul><h2 id="分析">分析</h2><p>给定横坐标<code>i,j</code>，则<code>(i,height[i])</code>与<code>(j,height[j])</code>构成的容器能容纳水的量为<code>min(height[i],height[j])*(j-i+1)</code>，记<code>k = min(height[i], height[j])</code>，<code>l = j-i+1</code>，目标使得<code>k * l</code>最大；<code>k</code>物理意义就是两个端点的小的那个，<code>l</code>的物理意义就是两个端点的距离，所以如果距离<code>l</code>减少的同时，<code>k</code>也在减少，那么目标值肯定变少了。根据该现象优化：<br />1. 首先选取最左与最右两个端点，此时<code>l</code>是最大的<br />2.比较两个端点的高度，如果比较高的那个往内移动，这时<code>k</code>要么不改变，要么减少，而<code>l</code>也再减少，所以<code>k*l</code>只会变少<br />3.由第2点可知，比较高的端点移动只会减少目标值，所以只需要移动低的那个端点即可</p><h3 id="算法">算法</h3><p>显然采用双指针法，一个初始为指向最左，一个初始为指向最右：<br />1.初始化<code>i=0,j=n-1</code>，及目标最大值为<code>m=min(height[i],height[j])*(j-i+1)</code><br />2.如果<code>height[i] &lt; height[j]</code>，则左端点向内移动即<code>i++</code>；<br />3. 否则，右端点向内移动即<code>j--</code><br />4.重新计算当前容纳水的值<code>cm</code>，如果<code>cm &gt; m</code>，更新目标最大值<code>m = cm</code><br />5. 重复步骤2</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxArea</span>(<span class="params">self, height</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        i, j = <span class="number">0</span>, n-<span class="number">1</span></span><br><span class="line">        m = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            m = <span class="built_in">max</span>(m, <span class="built_in">min</span>(height[j], height[i]) * (j - i))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; height[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> m</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="type">int</span> cm = <span class="built_in">min</span>(height[i], height[j]) * (j - i);</span><br><span class="line">            m = cm &gt; m ? cm : m;</span><br><span class="line">            <span class="keyword">if</span> (height[i] &lt; height[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            m = Math.max(m, Math.min(height[i], height[j]) * (j - i));</span><br><span class="line">            <span class="keyword">if</span>(height[i] &lt; height[j]) i++;</span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限三：连续函数与一致连续函数</title>
      <link href="/2020/12/08/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%903/"/>
      <url>/2020/12/08/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%903/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1某点连续">定义1：某点连续</h4><blockquote><p>设<span class="math inline">\(f: [a,b] \to \mathbb{R} \quad(b&gt;a)\)</span>. 若有<br /><span class="math display">\[    \lim \limits_{x \to x_0} f(x) = f(x_0)\]</span><br />则称函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0 \in (a,b)\)</span>内连续。</p></blockquote><span id="more"></span><h4 id="定义2左连续与右连续">定义2：左连续与右连续</h4><blockquote><p>如果<span class="math inline">\(f(x_0+) =f(x_0)\)</span>，则称函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处右连续；如果<spanclass="math inline">\(f(x_0-)=f(x_0)\)</span>，则称函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处左连续。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>如果函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，那么<spanclass="math inline">\(f\pm g\)</span>与<spanclass="math inline">\(fg\)</span>都在<spanclass="math inline">\(x_0\)</span>处连续，进一步，如果<spanclass="math inline">\(g(x_0)\ne 0\)</span>，则<spanclass="math inline">\(f/g\)</span>在<spanclass="math inline">\(x_0\)</span>处也连续。</p></blockquote><p>证：利用函数极限的四则运算显然可得。<br />Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设函数<span class="math inline">\(g\)</span>在<spanclass="math inline">\(t_0\)</span>处连续，记<spanclass="math inline">\(g(t_0)\)</span>为<spanclass="math inline">\(x_0\)</span>，如果<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，那么复合函数<spanclass="math inline">\(f \circ g\)</span>在<spanclass="math inline">\(t_0\)</span>处连续。</p></blockquote><p>证：利用复合函数的极限定理可证。<br />Q.E.D.</p><h4 id="定义3连续函数">定义3：连续函数</h4><blockquote><p>设<span class="math inline">\(I\)</span>是一个开区间，如果函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的每一点处都连续，则称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上连续；设<spanclass="math inline">\(I=[a,b]\)</span>，称<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上连续是指<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上连续，且在<spanclass="math inline">\(a\)</span>处右连续，在<spanclass="math inline">\(b\)</span>处左连续。也称<spanclass="math inline">\(f\)</span>是<spanclass="math inline">\(I\)</span>上的连续函数。记<spanclass="math inline">\(C(I)\)</span>为<spanclass="math inline">\(I\)</span>上连续函数的全体。</p></blockquote><h4 id="定义4间断点">定义4：间断点</h4><blockquote><p>设<span class="math inline">\(x_0\)</span>是函数<spanclass="math inline">\(f\)</span>定义域中的一点，如果<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处连续，则称<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的连续点，否则称<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的间断点。<br />间断点的类型有：<br />（1）如果<span class="math inline">\(f(x_0-)\)</span>与<spanclass="math inline">\(f(x_0+)\)</span>存在且有限，但<spanclass="math inline">\(f(x_0-) \ne f(x_0+)\)</span>，则称<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的跳跃点，差<spanclass="math inline">\(|f(x_0+)-f(x_0-)|\)</span>称为<spanclass="math inline">\(f\)</span>在这一点的跳跃；<br />（2）如果<span class="math inline">\(f(x_0-)\)</span>与<spanclass="math inline">\(f(x_0+)\)</span>存在且有限，且<spanclass="math inline">\(f(x_0-)= f(x_0+)\)</span>，但不等于<spanclass="math inline">\(f(x_0)\)</span>，则称<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的可去间断点；<br />（3）如果<span class="math inline">\(f(x_0-)\)</span>与<spanclass="math inline">\(f(x_0+)\)</span>至少有一个不存在或不是有限的数，则称<spanclass="math inline">\(x_0\)</span>是<spanclass="math inline">\(f\)</span>的第二类间断点。<br />跳跃点和可去间断点统称为第一类间断点。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设<span class="math inline">\(f\)</span>是区间<spanclass="math inline">\((a,b)\)</span>上的递增（减）函数，则<spanclass="math inline">\(f\)</span>的间断点一定是跳跃点，而且跳跃点集是至多可数的。</p></blockquote><p>证：不妨设<span class="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>递增，任取<spanclass="math inline">\(x \in (a,b)\)</span>，集合<spanclass="math inline">\(\{f(t)：t \in (a,x) \}\)</span>有上界，因为<spanclass="math inline">\(f(x)\)</span>就是一个上界，从而集合必有上确界（记作<spanclass="math inline">\(A\)</span>），显然有<span class="math inline">\(A\le f(x)\)</span>，下面证明<spanclass="math inline">\(f(x-)=A\)</span>。</p><p>对任意给定的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，且<spanclass="math inline">\(A\)</span>又是上确界，从而存在一个<spanclass="math inline">\(\delta&gt;0\)</span>，使得<spanclass="math inline">\(a &lt; x-\delta\)</span>，并且有<spanclass="math inline">\(A - \varepsilon &lt; f(x -\delta)\)</span>，又由于<spanclass="math inline">\(f\)</span>是递增函数，从而<br /><span class="math display">\[    A - \varepsilon &lt; f(x - \delta) \le f(t) \le A\]</span><br />对<span class="math inline">\(t \in (x-\delta,x)\)</span>都成立，从而得出<span class="math inline">\(\forall\varepsilon &gt; 0\)</span>，<span class="math inline">\(\exists \delta&gt; 0\)</span>，使得<span class="math inline">\(|f(t) - A| &lt;\varepsilon\)</span>对<span class="math inline">\(t \in (x-\delta,x)\)</span>成立，因此<spanclass="math inline">\(f(x-)=A\)</span>；同理可以证明<spanclass="math inline">\(f(x+)\)</span>存在且有限，存在<br /><span class="math display">\[    f(x-) \le f(x) \le f(x+)\]</span><br />所以若<span class="math inline">\(f(x-)=f(x+)\)</span>，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x\)</span>处连续，否则当<spanclass="math inline">\(f(x+) &gt;f(x-)\)</span>时，必是跳跃间断点。<br />设<span class="math inline">\(E\)</span>表示函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\((a,b)\)</span>上的间断点的全体，任取<spanclass="math inline">\(x \in E\)</span>，有<spanclass="math inline">\(f(x-) &lt; f(x+)\)</span>，在<spanclass="math inline">\((f(x-),f(x+))\)</span>内任取一个有理点记作<spanclass="math inline">\(r(x)\)</span>，则区间<spanclass="math inline">\(E\)</span>中的元素<spanclass="math inline">\(x\)</span>与<spanclass="math inline">\(r(x)\)</span>一一对应，而<spanclass="math inline">\(r(x)\)</span>是有理数的一个子集，从而<spanclass="math inline">\(E\)</span>是可数的。</p><p>Q.E.D.</p><h4 id="定义5一致连续">定义5：一致连续</h4><blockquote><p><span class="math inline">\(I\)</span>是一个区间，设<spanclass="math inline">\(f: I \to \mathbb{R}\)</span>，如果对<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(x_1,x_2 \in I\)</span>且<spanclass="math inline">\(|x_1-x_2|&lt;\delta\)</span>时，有<spanclass="math inline">\(|f(x_1) - f(x_2)| &lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f\)</span>在区间<spanclass="math inline">\(I\)</span>上是一致连续的。</p></blockquote><h4 id="定理4一致连续的函数必定连续">定理4：一致连续的函数必定连续</h4><blockquote><p>设<span class="math inline">\(f: I \to\mathbb{R}\)</span>在其定义域<spanclass="math inline">\(I\)</span>上一致连续，则函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(I\)</span>上的连续。</p></blockquote><p>证：由一致连续的定义可知，任取<span class="math inline">\(x \in(x_1,x_2)\)</span>，如果<spanclass="math inline">\(|x_1-x_2|&lt;\delta\)</span>，则<spanclass="math inline">\(x_1,x_2 \in (x-\delta,x+\delta)\)</span>，从而由Cauchy收敛原理知<spanclass="math inline">\(\lim \limits_{t \to x}f(t)\)</span>存在，又有<span class="math inline">\(|f(t) - f(x)| &lt;\varepsilon\)</span>对<span class="math inline">\(t \in (x-\delta,x+\delta)\)</span>成立，从而<span class="math inline">\(\lim \limits_{t\to x} f(t) = f(x)\)</span>，所以函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x\)</span>处连续。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，那么<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上一致连续。</p></blockquote><p>证：反证法。假设<span class="math inline">\(f\)</span>不在<spanclass="math inline">\([a,b]\)</span>上一致连续，则存在一个<spanclass="math inline">\(\varepsilon_0 &gt; 0\)</span>，对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，总能找到<spanclass="math inline">\(s_n,t_n\in [a,b]\)</span>，使得当<spanclass="math inline">\(|s_n-t_n| &lt; 1/n\)</span>时，有<br /><span class="math display">\[    |f(s_n)-f(t_n)| \ge \varepsilon_0 \tag 1\]</span><br />由于<span class="math inline">\(\{s_n\}\)</span>是一个在<spanclass="math inline">\([a,b]\)</span>内的数列，从而由列紧性定理可知，存在一个子列<spanclass="math inline">\(\{s_{k_n}\}\)</span>，使得<br /><span class="math display">\[    s_{k_n} \to s^* \in [a,b]  \quad (n \to \infty)\]</span><br />由（1）可知<br /><span class="math display">\[    |f(s_{k_n}) - f(t_{k_n})| \ge \varepsilon_0 \tag 2\]</span><br />而<span class="math inline">\(|s_{k_n} - t_{k_n}| &lt;1/n\)</span>，令<span class="math inline">\(n \to\infty\)</span>，可知<span class="math inline">\(t_{k_n} \tos^*\)</span>，从而由函数<spanclass="math inline">\(f\)</span>的连续性，令（2）式中<spanclass="math inline">\(n \to \infty\)</span>，可得<br /><span class="math display">\[    0=|f(s^*)-f(s^*)| = |\lim \limits_{n \to \infty}f(s_{k_n}) - \lim\limits_{n \to \infty}f(t_{k_n})| = \lim \limits_{n \to\infty}|f(s_{k_n}) - f(t_{k_n})| \ge \varepsilon_0 &gt; 0\]</span><br />矛盾。</p><p>Q.E.D.</p><h4 id="定理6"><span id="theorem6">定理6</span></h4><blockquote><p>有界闭区间上的连续函数必在该区间上有界。</p></blockquote><p>证：反证法。设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续且无上界，那么对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，存在<spanclass="math inline">\(x_n \in [a,b]\)</span>，使得<spanclass="math inline">\(f(x_n) &gt; n\)</span>，又由于<spanclass="math inline">\(x_n \in [a,b]\)</span>，从而存在一个子列<spanclass="math inline">\(\{x_{k_n}\}\)</span>使得<br /><span class="math display">\[    x_{k_n} \to \xi \in [a,b] \quad (n \to \infty)\]</span><br />由函数<span class="math inline">\(f\)</span>的连续性可知<br /><span class="math display">\[    \lim \limits_{n \to \infty} f(x_{k_n}) = f(\xi)\]</span><br />而<spanclass="math inline">\(f(\xi)\)</span>是给定点的函数值，在连续函数中必有界，另一方面<br /><span class="math display">\[    f(x_{k_n}) &gt; k_n \ge n\]</span><br />得到<span class="math inline">\(\lim \limits_{n \to \infty} f(x_{k_n}) =\infty\)</span>，这与上面结论<spanclass="math inline">\(f(\xi)\)</span>是有界矛盾。所以<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>有上界。<br />同理，可证<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>有下界。</p><p>Q.E.D.</p><h4 id="定理7"><span id="theorem7">定理7</span></h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，记<br /><span class="math display">\[    M = \sup_{x \in [a,b]} f(x), \quad  m = \inf_{x \in [a,b]} f(x)\]</span><br />则必存在<span class="math inline">\(x^*, x_* \in[a,b]\)</span>，使得<br /><span class="math display">\[    f(x^*) = M, \quad f(x_*) = m\]</span><br />即有界闭区间上的连续函数必能取到它在此区间上的最大值和最小值。</p></blockquote><p>证：由<a href="#theorem6">定理6</a>可知<spanclass="math inline">\(m,M\)</span>是有限数，由上确界的定义可知，对任意的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，必存在<spanclass="math inline">\(x_n \in [a,b]\)</span>，使得<br /><span class="math display">\[    M - \frac{1}{n} &lt; f(x_n) \le M\]</span><br />从数列<spanclass="math inline">\(\{x_n\}\)</span>中选出一个收敛子列<spanclass="math inline">\(\{x_{k_n}\}\)</span>，不妨令<spanclass="math inline">\(x_{k_n} \to x^* \in[a,b]\)</span>，而且有不等式<br /><span class="math display">\[    M - \frac{1}{k_n} &lt; f(x_{k_n}) \le M\]</span><br />上式中令<span class="math inline">\(n \to \infty\)</span>，由函数<spanclass="math inline">\(f\)</span>的连续性可知<br /><span class="math display">\[    f(x_*) = \lim \limits_{x \to x^*} f(x) = M\]</span></p><p>同理，可证存在<span class="math inline">\(x_* \in[a,b]\)</span>使得<span class="math inline">\(f(x_*) = m\)</span>。</p><p>Q.E.D.</p><h4 id="定理8零值定理"><span id="theorem8">定理8：零值定理</span></h4><blockquote><p>设<span class="math inline">\(f\)</span>在<spanclass="math inline">\([a,b]\)</span>上连续，如果<spanclass="math inline">\(f(a)f(b) &lt; 0\)</span>，则必存在一点<spanclass="math inline">\(c \in [a,b]\)</span>，使得<spanclass="math inline">\(f(c) = 0\)</span>。</p></blockquote><p>证：不妨设<span class="math inline">\(f(a) &lt; 0 &lt;f(b)\)</span>，将区间<spanclass="math inline">\([a,b]\)</span>而等分，如果<spanclass="math inline">\(f((a+b)/2)=0\)</span>，则<spanclass="math inline">\(c=(a+b)/2\)</span>，如果<spanclass="math inline">\(f((a+b)/2)&gt;0\)</span>，则令<spanclass="math inline">\(a_1=a,b_1=(a+b)/2\)</span>，否则令<spanclass="math inline">\(a_1=(a+b)/2,b_1=b\)</span>，可知<spanclass="math inline">\([a_1,b_1]\)</span>两端取值异号，对<spanclass="math inline">\([a_1,b_1]\)</span>重复上述过程，一直下去，可以得到一列闭区间<spanclass="math inline">\([a_k, b_k] (k=1,2,\cdots)\)</span>，满足<br />（1）<span class="math inline">\([a,b] \supset [a_1,b_1] \supset[a_2,b_2] \supset \cdots \supset [a_k,b_k] \supset\cdots\)</span>；<br />（2）<span class="math inline">\(0 &lt; b_k - a_k =\frac{1}{2^k}(b-a)\)</span>；<br />（3）<span class="math inline">\(f(a_k) &lt; 0 &lt; f(b_k)\)</span></p><p>如果对某个<span class="math inline">\(k\)</span>，有<spanclass="math inline">\(f((a_k+b_k)/2)=0\)</span>，则<spanclass="math inline">\(c=(a_k+b_k)/2\)</span>，否则由闭区间套定理可知，存在<spanclass="math inline">\(c \in [a_k, b_k](k=1,2,\cdots)\)</span>，使得<span class="math inline">\(\lim\limits_{k\to \infty} a_k = \lim \limits_{k \to \infty} b_k =c\)</span>，由函数的连续性可知，令（3）式中的<spanclass="math inline">\(k \to \infty\)</span>，得<spanclass="math inline">\(f(c) \le 0 \le f(c)\)</span>，从而<spanclass="math inline">\(f(c)=0\)</span>。</p><p>Q.E.D.</p><h4 id="定理9介值定理">定理9：介值定理</h4><blockquote><p>设<span class="math inline">\(f\)</span>是区间<spanclass="math inline">\([a,b]\)</span>上得非常值连续函数，<spanclass="math inline">\(\gamma\)</span>是介于<spanclass="math inline">\(f(a),f(b)\)</span>之间得任何实数，则必存在<spanclass="math inline">\(c \in [a,b]\)</span>，使得<spanclass="math inline">\(f(c)=\gamma\)</span>。</p></blockquote><p>证：令<span class="math inline">\(g(x) = f(x) -\gamma\)</span>，再由<a href="#theorem8">定理8</a>可证。</p><p>Q.E.D.</p><h4 id="定理10">定理10</h4><blockquote><p>设非常值函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(I=[a,b]\)</span>上连续，那么<spanclass="math inline">\(f\)</span>的值域<spanclass="math inline">\(f(I)\)</span>是一个闭区间。</p></blockquote><p>证：由<a href="#theorem7">定理7</a>可知，<spanclass="math inline">\(m\)</span>和<spanclass="math inline">\(M\)</span>分别是<spanclass="math inline">\(f(I)\)</span>的最小值和最大值，再由介值定理可知，<spanclass="math inline">\(f(I)=[m,M]\)</span>。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数极限 </tag>
            
            <tag> 连续函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解10：正则表达式匹配</title>
      <link href="/2020/12/05/leetcode%E9%A2%98%E8%A7%A310/"/>
      <url>/2020/12/05/leetcode%E9%A2%98%E8%A7%A310/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于力扣<ahref="https://leetcode-cn.com/problems/regular-expression-matching">第10题</a></p><p>给你一个字符串<code>s</code>和一个字符规律<code>p</code>，请你来实现一个支持<code>'.'</code>和<code>'*'</code>的正则表达式匹配。</p><p><code>'.'</code>匹配任意单个字符<br /><code>'*'</code>匹配零个或多个前面的那一个元素<br />所谓匹配，是要涵盖<strong>整个</strong>字符串<code>s</code>的，而不是部分字符串。</p><span id="more"></span><p> <br />示例 1:</p><blockquote><p>输入：s = "aa" p = "a"<br />输出：false<br />解释："a" 无法匹配 "aa" 整个字符串。</p></blockquote><p>示例 2:</p><blockquote><p>输入：s = "aa" p = "a<em>"<br />输出：true<br />解释：因为 '</em>' 代表可以匹配零个或多个前面的那一个元素,在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a'重复了一次。</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = "ab" p = ".*"<br />输出：true<br />解释：".<em>" 表示可匹配零个或多个（'</em>'）任意字符（'.'）。</p></blockquote><p>示例 4：</p><blockquote><p>输入：s = "aab" p = "c*a*b"<br />输出：true<br />解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a'被重复一次。因此可以匹配字符串 "aab"。</p></blockquote><p>示例 5:</p><blockquote><p>输入：s = "mississippi" p = "mis*is*p*."<br />输出：false</p></blockquote><p>提示：</p><ul><li><code>0 &lt;= s.length &lt;= 20</code></li><li><code>0 &lt;= p.length &lt;= 30</code></li><li><code>s</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母。</li><li><code>p</code> 可能为空，且只包含从 <code>a-z</code> 的小写字母，以及字符 <code>.</code> 和 <code>*</code>。</li><li>保证每次出现字符 <code>*</code> 时，前面都匹配到有效的字符</li></ul><h2 id="分析">分析</h2><ul><li>该题可以采用状态机来解，类似的已在leetcode题解8中介绍了；该题还有其他解法——动态规划，用<code>dp[i][j]</code>来表示<code>s</code>的前<code>i</code>个字符与<code>p</code>的前<code>j</code>个字符是否匹配，那么可以注意到:</li><li>先不考虑<code>*</code>，如果<code>p[j]</code>与<code>s[i]</code>匹配到了，即要么<code>s[i]=p[j]</code>，要么<code>p[j]='.'</code>，那么<code>dp[i][j]=dp[i-1][j-1]</code>，否则就为<code>false</code></li><li>再考虑<code>*</code>，即如果<code>p[j]='*'</code><ul><li>如果<code>s[i]</code>与<code>p[j-1]</code>匹配<ul><li>则<code>*</code>前面的字符<code>p[j-1]</code>可能匹配<code>s</code>中多个，比如<code>s=aaa</code>，<code>p=a*</code>，这时<code>dp[i][j]=dp[i-1][j]</code></li><li>也可能<code>*</code>前面的字符不匹配<code>s</code>中的字符，比如<code>s=aa</code>，<code>p=aaa*</code>，这时<code>dp[i][j]=dp[i][j-2]</code></li></ul></li><li>如果<code>s[i]</code>与<code>p[j-1]</code>不匹配，那么<code>*</code>前面的字符不匹配<code>s</code>中的字符，这时<code>dp[i][j]=dp[i][j-2]</code></li></ul></li></ul><h2 id="算法">算法</h2><p>根据前面分析知道，麻烦在于<code>p[j]='*'</code>时的处理，实际上无论<code>s[i]</code>与<code>p[j-1]</code>是否匹配到了，<code>*</code>前面的字符都可能不匹配<code>s</code>中的字符，也就是说<code>dp[i][j] = dp[i][j-2]</code>或者<code>dp[i][j] = dp[i][j-2] | dp[i-1][j]</code>；<br />所以实现的时候可以让<code>dp[i][j]</code>初始化为<code>false</code>，按照<code>dp[i][j]</code>的定义，<code>i,j</code>都必须大于0，这时可以让<code>dp[i][j]</code>表示两个空字符串是否匹配，当然设为<code>true</code>了，最后按照方程进行状态转移就可以了</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">match</span>(<span class="params">self, schar, pchar</span>):</span><br><span class="line">        <span class="keyword">if</span> pchar == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> pchar == schar</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isMatch</span>(<span class="params">self, s, p</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(s), <span class="built_in">len</span>(p)</span><br><span class="line">        dp = [[<span class="literal">False</span>]*(n+<span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># 空字符比较设为匹配，最终结果为dp[m][n]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> p[j-<span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.match(s[i-<span class="number">1</span>], p[j-<span class="number">1</span>]):</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 末位是&#x27;*&#x27;，则先与上`*`前面的字符不匹配`s`中字符的情况，</span></span><br><span class="line">                    <span class="comment"># 比如s=aa p=aaa*或s=ab p=abc*</span></span><br><span class="line">                    dp[i][j] |= dp[i][j-<span class="number">2</span>]</span><br><span class="line">                    <span class="comment"># 然后判断`s[i]`与`p[j-1]`匹配且`*`前面的字符匹配`s`中多个的情况</span></span><br><span class="line">                    <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> self.match(s[i-<span class="number">1</span>], p[j-<span class="number">2</span>]):</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(<span class="type">char</span> ch1, <span class="type">char</span> ch2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ch2 == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> ch1 == ch2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>(), n = p.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">match</span>(s[i - <span class="number">1</span>], p[j - <span class="number">1</span>]))</span><br><span class="line">                        dp[i][j] |= dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] |= dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">match</span>(s[i - <span class="number">1</span>], p[j - <span class="number">2</span>]))</span><br><span class="line">                        dp[i][j] |= dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(<span class="type">char</span> ch1, <span class="type">char</span> ch2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ch2 == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">return</span> <span class="variable">ch1</span> <span class="operator">=</span>= ch2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n+<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; match(s.charAt(i-<span class="number">1</span>), p.charAt(j-<span class="number">1</span>)))</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] |= dp[i][j-<span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; match(s.charAt(i-<span class="number">1</span>), p.charAt(j-<span class="number">2</span>)))</span><br><span class="line">                        dp[i][j] |= dp[i-<span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解8：字符串转换整数 (atoi)</title>
      <link href="/2020/11/28/leetcode%E9%A2%98%E8%A7%A38/"/>
      <url>/2020/11/28/leetcode%E9%A2%98%E8%A7%A38/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/string-to-integer-atoi">力扣第八题</a></p><p>请你来实现一个<code>atoi</code>函数，使其能将字符串转换成整数。</p><span id="more"></span><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：</p><ul><li>如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。</li><li>假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。</li><li>该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。</li></ul><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回<code>0</code>。</p><p>提示：</p><ul><li>本题中的空白字符只包括空格字符<code>' '</code>。</li><li>假设我们的环境只能存储 32位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 −1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31)。<br /> </li></ul><p>示例 1:</p><blockquote><p>输入: "42"<br />输出: 42</p></blockquote><p>示例 2:</p><blockquote><p>输入: " -42"<br />输出: -42<br />解释: 第一个非空白字符为 '-', 它是一个负号。<br />  我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。</p></blockquote><p>示例 3:</p><blockquote><p>输入: "4193 with words"<br />输出: 4193<br />解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。</p></blockquote><p>示例 4:</p><blockquote><p>输入: "words and 987"<br />输出: 0<br />解释: 第一个非空字符是 'w', 但它不是数字或正、负号。<br />因此无法执行有效的转换。</p></blockquote><p>示例 5:</p><blockquote><p>输入: "-91283472332"<br />输出: -2147483648<br />解释: 数字 "-91283472332" 超过 32 位有符号整数范围。<br />  因此返回 INT_MIN (−231) 。</p></blockquote><h2 id="分析">分析</h2><p>思路是遍历字符串，对每个字符单独处理，字符类型一共有四种：空格(space)，+/-，数字(0-9)，其他(other)；根据这四种类型分别处理，然后判断边界即可。<br />这里采用另一种代码的写法，利用状态机，根据不同的字符输入进行不同的状态转换，从而获得结果，其本质和上面的思路道理是一样的，但是状态机在计算机邻域非常通用，比如说硬件verilog语言应用就很多，而且正则表达式匹配的原理也使用到的状态机，故此采用状态机的写法。<br />首先可以定义状态，分为开始状态（start）、符号状态（sign）、数字状态（number）和结束状态（end），根据输入字符的不同，各个状态的转移图如下：</p><pre class="mermaid">graph LR;S1[start]; S2[sign]; S3[number]; S4[end];S1 -- space --> S1;S1 -- +/- --> S2;S3 -- 0-9 --> S3;S3 -- space+/-other --> S4;S1 -- 0-9 --> S3;S2 -- 0-9 --> S3;S2 -- space +/- other --> S4;S1 -- other --> S4</pre><p>相应的状态转移表为：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">space</th><th style="text-align: center;">+/-</th><th style="text-align: center;">0-9</th><th style="text-align: center;">other</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">start</td><td style="text-align: center;">start</td><td style="text-align: center;">sign</td><td style="text-align: center;">number</td><td style="text-align: center;">end</td></tr><tr class="even"><td style="text-align: center;">sign</td><td style="text-align: center;">end</td><td style="text-align: center;">end</td><td style="text-align: center;">number</td><td style="text-align: center;">end</td></tr><tr class="odd"><td style="text-align: center;">number</td><td style="text-align: center;">end</td><td style="text-align: center;">end</td><td style="text-align: center;">number</td><td style="text-align: center;">end</td></tr><tr class="even"><td style="text-align: center;">end</td><td style="text-align: center;">end</td><td style="text-align: center;">end</td><td style="text-align: center;">end</td><td style="text-align: center;">end</td></tr></tbody></table><p>由状态转移表，根据输入的字符更换状态，并相应进行处理操作即可</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtoiFSM</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.state = <span class="string">&quot;start&quot;</span></span><br><span class="line">        self.sign = <span class="number">1</span></span><br><span class="line">        self.val = <span class="number">0</span></span><br><span class="line">        self.table = &#123;</span><br><span class="line">                      <span class="comment">#   space    +/-      0-9     other</span></span><br><span class="line">            <span class="string">&quot;start&quot;</span> :   [<span class="string">&quot;start&quot;</span>, <span class="string">&quot;sign&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>],</span><br><span class="line">            <span class="string">&quot;sign&quot;</span>  :   [<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>],</span><br><span class="line">            <span class="string">&quot;number&quot;</span>:   [<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>],</span><br><span class="line">            <span class="string">&quot;end&quot;</span>   :   [<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;end&quot;</span>,    <span class="string">&quot;end&quot;</span>],</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_state_transfer_id</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">&quot; &quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&quot;+&quot;</span> <span class="keyword">or</span> c == <span class="string">&quot;-&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c.isdigit():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, c</span>):</span><br><span class="line">        <span class="comment"># 状态转换</span></span><br><span class="line">        self.state = self.table[self.state][self._get_state_transfer_id(c)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.state == <span class="string">&quot;sign&quot;</span>:</span><br><span class="line">            self.sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">&quot;+&quot;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&quot;number&quot;</span>:</span><br><span class="line">            self.val = self.val * <span class="number">10</span> + <span class="built_in">int</span>(c)</span><br><span class="line">            self.val = <span class="built_in">min</span>(self.val, <span class="number">2</span>**<span class="number">31</span>-<span class="number">1</span>) <span class="keyword">if</span> self.sign == <span class="number">1</span> <span class="keyword">else</span> <span class="built_in">min</span>(self.val, <span class="number">2</span>**<span class="number">31</span>)</span><br><span class="line">        <span class="keyword">elif</span> self.state == <span class="string">&quot;end&quot;</span>:</span><br><span class="line">            <span class="keyword">return</span> self.sign * self.val</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">myAtoi</span>(<span class="params">self, s</span>):</span><br><span class="line">        fsm = AtoiFSM()</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            res = fsm.run(c)</span><br><span class="line">            <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> fsm.sign * fsm.val</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AtoiFSM</span> &#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string, vector&lt;string&gt;&gt; map = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>, &#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;sign&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125; &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;sign&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;number&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>, &#123;<span class="string">&quot;end&quot;</span>,   <span class="string">&quot;end&quot;</span>,  <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_state_transfer_id</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">        state = map[state][<span class="built_in">get_state_transfer_id</span>(c)];</span><br><span class="line">        <span class="keyword">if</span> (state == <span class="string">&quot;sign&quot;</span>) sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state == <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">            val = val * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            val = sign == <span class="number">1</span> ? <span class="built_in">min</span>(val, (<span class="type">long</span> <span class="type">long</span>) INT_MAX) : <span class="built_in">min</span>(val, - (<span class="type">long</span> <span class="type">long</span>) INT_MIN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        AtoiFSM fsm = <span class="built_in">AtoiFSM</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line">            fsm.<span class="built_in">run</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(fsm.sign * fsm.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AtoiFSM</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">state</span> <span class="operator">=</span> <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">sign</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">val</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String[]&gt; table = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AtoiFSM</span><span class="params">()</span> &#123;</span><br><span class="line">        table.put(<span class="string">&quot;start&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;sign&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;sign&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;number&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">        table.put(<span class="string">&quot;end&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getStateTransferID</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        state = table.get(state)[getStateTransferID(c)];</span><br><span class="line">        <span class="keyword">if</span> (state.equals(<span class="string">&quot;sign&quot;</span>)) &#123;</span><br><span class="line">            sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (state.equals(<span class="string">&quot;number&quot;</span>))&#123;</span><br><span class="line">            val = val * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            val = sign == <span class="number">1</span> ? Math.min(val, Integer.MAX_VALUE) : Math.min(val, - (<span class="type">long</span>) Integer.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtoiFSM</span> <span class="variable">fsm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtoiFSM</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">myAtoi</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            fsm.run(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (fsm.sign * fsm.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 状态机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限二：其它类型的函数极限</title>
      <link href="/2020/11/27/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%902/"/>
      <url>/2020/11/27/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%902/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1自变量趋于infty的极限">定义1：自变量趋于<spanclass="math inline">\(+\infty\)</span>的极限</h4><blockquote><p>若对<span class="math inline">\(\forall \varepsilon&gt;0, \exists A&gt; 0\)</span>，使得当<span class="math inline">\(x &gt;A\)</span>时，有<span class="math inline">\(|f(x) - l| &lt;\varepsilon\)</span>，此时称在正无穷处函数有极限<spanclass="math inline">\(l\)</span>，记为<br /><span class="math display">\[    f(+\infty) = \lim \limits_{x \to +\infty} f(x) = l\]</span><br />或简单记作<br /><span class="math display">\[    f(x) \to l (x \to +\infty)\]</span></p></blockquote><span id="more"></span><p>类似地可以定义<span class="math inline">\(f(-\infty) = \lim\limits_{x \to -\infty} f(x) = l\)</span></p><h4 id="定义2自变量趋于infty的极限">定义2：自变量趋于<spanclass="math inline">\(\infty\)</span>的极限</h4><blockquote><p>若对<span class="math inline">\(\forall \varepsilon&gt;0, \exists A&gt; 0\)</span>，使得当<span class="math inline">\(|x| &gt;A\)</span>时，有<span class="math inline">\(|f(x) - l| &lt;\varepsilon\)</span>，此时称当<spanclass="math inline">\(x\)</span>趋于无穷时，函数有极限<spanclass="math inline">\(l\)</span>，记为<br /><span class="math display">\[    f(\infty) = \lim \limits_{x \to \infty} f(x) = l\]</span><br />或简单记作<br /><span class="math display">\[    f(x) \to l (x \to \infty)\]</span></p></blockquote><h4 id="定理1">定理1</h4><blockquote><p><span class="math inline">\(\lim \limits_{x \to \infty} f(x) =l\)</span>当且仅当<br /><span class="math display">\[    f(-\infty) = f(+\infty) = l\]</span></p></blockquote><p>证：必要性和充分性都由定义显然。<br />Q.E.D.</p><h4 id="定义3无穷大">定义3：无穷大</h4><blockquote><p>设<span class="math inline">\(x_0\)</span>是一个实数，函数<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的一个近旁（可能除<spanclass="math inline">\(x_0\)</span>之外）有定义，若对<spanclass="math inline">\(\forall A&gt;0, \exists \delta &gt;0\)</span>，使得当<span class="math inline">\(0&lt; |x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x)| &gt;A\)</span>，则称函数<spanclass="math inline">\(f\)</span>趋向于无穷大，记作<br /><span class="math display">\[    \lim \limits_{x \to x_0} f(x) = \infty\]</span><br />或者<br /><span class="math display">\[    f(x) \to \infty (x \to x_0)\]</span></p></blockquote><p>类似地可以定义</p><blockquote><p><span class="math display">\[    \begin{aligned}    \lim \limits_{x \to x_0} f(x) = +\infty \quad \lim \limits_{x \tox_0} f(x) = -\infty \\    \lim \limits_{x \to -\infty} f(x) = \infty \quad \lim \limits_{x \to+\infty} f(x) = \infty    \end{aligned}\]</span></p></blockquote><p>等等</p><h4 id="定义4无穷小">定义4：无穷小</h4><blockquote><p>设<span class="math inline">\(x_0\)</span>是一个实数，函数<spanclass="math inline">\(f(x)\)</span>在<spanclass="math inline">\(x_0\)</span>的一个近旁（可能除<spanclass="math inline">\(x_0\)</span>之外）有定义，若对<spanclass="math inline">\(\forall \varepsilon&gt;0, \exists \delta &gt;0\)</span>，使得当<span class="math inline">\(0&lt; |x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x)| &lt;\varepsilon\)</span>，则称函数<spanclass="math inline">\(f\)</span>趋向于无穷小，记作<br /><span class="math display">\[    \lim \limits_{x \to x_0} f(x) = 0\]</span><br />或者<br /><span class="math display">\[    f(x) \to 0 (x \to x_0)\]</span></p></blockquote><p>类似地可以定义</p><blockquote><p><span class="math display">\[    \lim \limits_{x \to -\infty} f(x) = 0 \quad \lim \limits_{x \to+\infty} f(x) = 0\]</span></p></blockquote><p>等等</p><h4 id="定义5">定义5</h4><blockquote><p>设当<span class="math inline">\(x \to x_0\)</span>时，函数<spanclass="math inline">\(f\)</span>和<spanclass="math inline">\(g\)</span>都是无穷小，并且<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(x_0\)</span>的一个无穷小近旁（除<spanclass="math inline">\(x_0\)</span>外）不等于0<br />（1）如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = 0\)</span>，则称<spanclass="math inline">\(f\)</span>是比<spanclass="math inline">\(g\)</span>更高阶的无穷小；<br />（2） 如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = l \ne 0\)</span>，则称<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>是同阶的无穷小；<br />（3） 如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = 1\)</span>，则称<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>是等价的无穷小，记作<br /><span class="math display">\[    f \sim g \quad (x \to x_0)\]</span><br />（4） 当<span class="math inline">\(x \to x_0\)</span>时，如果<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\((x-x_0)^\alpha\)</span>是同阶无穷小，则称<spanclass="math inline">\(f\)</span>为<spanclass="math inline">\(\alpha\)</span>阶的无穷小</p></blockquote><p>类似地，可以定义，如果<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>都是无穷大</p><blockquote><p>（1） 如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = 0\)</span>，则称<spanclass="math inline">\(g\)</span>是比<spanclass="math inline">\(f\)</span>更高阶的无穷大；<br />（2） 如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = l \ne 0\)</span>，则称<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>是同阶的无穷大；<br />（3） 如果<span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{g(x)} = 1\)</span>，则称<spanclass="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>是等价的无穷大</p></blockquote><h4 id="定理2">定理2</h4><blockquote><p>如果当<span class="math inline">\(x \to x_0\)</span>（<spanclass="math inline">\(x_0\)</span>可以是<spanclass="math inline">\(\pm\infty\)</span>）时，<spanclass="math inline">\(f,g\)</span>是等价的无穷小或无穷大，则<br />（1） <span class="math inline">\(\lim \limits_{x \to x_0} f(x) h(x) =\lim \limits_{x \to x_0} g(x)h(x)\)</span><br />（2） <span class="math inline">\(\lim \limits_{x \to x_0}\frac{f(x)}{h(x)} = \lim \limits_{x \to x_0}\frac{g(x)}{h(x)}\)</span></p></blockquote><p>证：（1） <span class="math inline">\(\lim \limits_{x \to x_0} f(x)h(x) = \lim \limits_{x \to x_0} g(x) h(x) \frac{f(x)}{g(x)} = \lim\limits_{x \to x_0} g(x) h(x)\)</span>；<br />（2） 证明与（1）一样。</p><p>Q.E.D.</p><h4 id="定义6o与o表示法">定义6：<spanclass="math inline">\(O\)</span>与<spanclass="math inline">\(o\)</span>表示法</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(x_0\)</span>的近旁（<spanclass="math inline">\(x_0\)</span>除外）有定义，并且<spanclass="math inline">\(g(x)\ne 0\)</span><br />（1）当<span class="math inline">\(x \to x_0\)</span>，若比值<spanclass="math inline">\(f(x)/g(x)\)</span>保持有界，即存在一个正常数<spanclass="math inline">\(M\)</span>，使得<spanclass="math inline">\(|f(x)|\le M|g(x)|\)</span>，就用<spanclass="math inline">\(f(x) = O(g(x))(x\to x_0)\)</span>来表示；<br />（2）当<span class="math inline">\(x \to x_0\)</span>，若比值<spanclass="math inline">\(f(x)/g(x)\)</span>是一个无穷小，即<br /><span class="math display">\[    \lim \limits_{x \to x_0} \frac{f(x)}{g(x)} = 0\]</span><br />就用<span class="math inline">\(f(x) = o(g(x))(x\tox_0)\)</span>表示<br />特别地，<span class="math inline">\(f(x)=O(1)(x\tox_0)\)</span>表示有界的函数，<span class="math inline">\(g(x)=o(1)(x \tox_0)\)</span>表示一个无穷小。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解5：最长回文子串</title>
      <link href="/2020/11/21/leetcode%E9%A2%98%E8%A7%A35/"/>
      <url>/2020/11/21/leetcode%E9%A2%98%E8%A7%A35/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/longest-palindromic-substring">力扣第五题</a></p><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入: "babad"<br />输出: "bab"<br />注意: "aba" 也是一个有效答案。</p></blockquote><p>示例 2：</p><blockquote><p>输入: "cbbd"<br />输出: "bb"</p></blockquote><h2 id="分析">分析</h2><p>关键思路是如何尽量少的遍历？注意到要判断<spanclass="math inline">\(a_1a_2a_3 \cdots a_{n-1}a_n\)</span>是否是回文串，等价于判断<span class="math inline">\(a_2a_3\cdots a_{n-1}\)</span>是否是回文串，而且<spanclass="math inline">\(a_1=a_n\)</span>是否成立，如果两个都成立，那么原字符串是回文串，否则就不是；所以解法思路是动态规划，<br />状态：<code>dp[i][j]</code>表示下标从<code>i</code>到<code>j</code>构成的子串是否是回文串<br />状态转移方程：<code>dp[i][j] = dp[i+1][j-1] &amp;&amp; a[i]==a[j]</code></p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestPalindrome</span>(<span class="params">self, s</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        max_len = <span class="number">0</span></span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> i == j:</span><br><span class="line">                    dp[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">elif</span> s[i] == s[j]:</span><br><span class="line">                    <span class="keyword">if</span> j - i &gt; <span class="number">1</span>:</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> max_len &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                    start = i</span><br><span class="line">                    end = j + <span class="number">1</span></span><br><span class="line">                    max_len = j - i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s[start:end]</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((j - i) &gt; <span class="number">1</span>) dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; (j-i+<span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                    maxLen = <span class="built_in">max</span>(j - i + <span class="number">1</span>, maxLen);</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        Boolean[][] dp = <span class="keyword">new</span> <span class="title class_">Boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=n-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &gt; <span class="number">1</span>) dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; ((j - i + <span class="number">1</span>) &gt; maxLen))&#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    start = i;</span><br><span class="line">                    end = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, end+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数极限一：函数极限定义与基本性质</title>
      <link href="/2020/11/17/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%901/"/>
      <url>/2020/11/17/%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%901/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1函数在某点处极限">定义1：函数在某点处极限</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在点<spanclass="math inline">\(x_0\)</span>的近旁有定义，但<spanclass="math inline">\(x_0\)</span>这一点自身可以是例外，设<spanclass="math inline">\(l\)</span>是一个实数，如果对<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists\delta&gt;0\)</span>，使得对一切满足等式<span class="math inline">\(0&lt; |x-x_0| &lt; \delta\)</span>都有<br /><span class="math display">\[    |f(x) - l| &lt; \varepsilon\]</span><br />则称当<span class="math inline">\(x\)</span>趋于点<spanclass="math inline">\(x_0\)</span>时函数<spanclass="math inline">\(f\)</span>有极限<spanclass="math inline">\(l\)</span>，记作<br /><span class="math display">\[    \lim \limits_{x \to x_0} f(x) = l\]</span><br />也可以记作<br /><span class="math display">\[    f(x) \to l (x \to x_0)\]</span></p></blockquote><span id="more"></span><h4 id="定理1"><span id="theorem1">定理1</span></h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有极限<spanclass="math inline">\(l\)</span>的充分必要条件是，对任何一个收敛于<spanclass="math inline">\(x_0\)</span>的数列<spanclass="math inline">\(\{x_n \ne x_0 :n=1,2,3,\cdots\}\)</span>，有数列<spanclass="math inline">\(\{f(x_n)\}\)</span>有极限<spanclass="math inline">\(l\)</span>。</p></blockquote><p>证：<strong>必要性</strong>。设<span class="math inline">\(\lim\limits_{x \to x_0} f(x)= l\)</span>，则对任给的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在一个<spanclass="math inline">\(\delta &gt; 0\)</span>，使得当<spanclass="math inline">\(0 &lt; |x - x_0| &lt; \delta\)</span>，有<spanclass="math inline">\(|f(x) - l| &lt;\varepsilon\)</span>，对于取定的<spanclass="math inline">\(\delta\)</span>，由于<spanclass="math inline">\(\lim \limits_{n \to \infty} x_n =x_0\)</span>，所以存在<span class="math inline">\(N \in\mathbb{N^+}\)</span>，使得当<span class="math inline">\(n &gt;N\)</span>时，有<span class="math inline">\(0 &lt; |x_n - x_0| &lt;\delta\)</span>，从而有<br /><span class="math display">\[    |f(x_n) - l| &lt; \varepsilon\]</span><br />所以<span class="math inline">\(\lim \limits_{n \to \infty} f(x_n) =l\)</span>。<br /><strong>充分性</strong>。反证法，假设<span class="math inline">\(\lim\limits_{x \to x_0} f(x) = l\)</span>不成立，即存在<spanclass="math inline">\(\varepsilon_0 &gt;0\)</span>，使得对任意的正整数<spanclass="math inline">\(n\)</span>，存在点<spanclass="math inline">\(x_n\)</span>，使得当<span class="math inline">\(0&lt; |x_n - x_0| &lt; \frac{1}{n}\)</span>，有<spanclass="math inline">\(|f(x_n) - l| \ge \varepsilon_0 &gt;0\)</span>，从而找到了一个数列<span class="math inline">\(\{x_n \ne x_0:n=1,2,3,\cdots\}\)</span>，虽然它收敛于<spanclass="math inline">\(x_0\)</span>，但是<span class="math inline">\(\lim\limits_{n \to \infty} f(x_n) \ne l\)</span>。</p><h4 id="定理2函数极限唯一性">定理2：函数极限唯一性</h4><blockquote><p>若<span class="math inline">\(\lim \limits_{x \to x_0}f(x)\)</span>存在，则它是唯一的</p></blockquote><p>证：若<span class="math inline">\(\lim \limits_{x \to x_0}f(x)\)</span>存在，可知对任意收敛于<spanclass="math inline">\(x_0\)</span>的数列<spanclass="math inline">\(\{x_n \ne x_0 :n=1,2,3,\cdots\}\)</span>，有<br /><span class="math display">\[    \lim \limits_{n\to\infty} f(x_n) = \lim \limits_{x \to x_0} f(x)\]</span><br />而数列极限是唯一的，所以函数极限也是唯一的。<br />Q.E.D.</p><h4 id="定理3">定理3</h4><blockquote><p>若<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有极限，则<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>的近旁是有界的，也就是说存在整数<spanclass="math inline">\(M\)</span>，实数<span class="math inline">\(\delta&gt; 0\)</span>，使得当<span class="math inline">\(0 &lt; |x - x_0| &lt;\delta\)</span>时，有<span class="math inline">\(|f(x)| &lt;M\)</span>。</p></blockquote><p>证：设<span class="math inline">\(\lim \limits_{x \to x_0} f(x) =l\)</span>。由函数极限定义可知，对<span class="math inline">\(1 &gt;0\)</span>，存在<span class="math inline">\(\delta &gt;0\)</span>，使得当<span class="math inline">\(0 &lt; |x - x_0| &lt;\delta\)</span>时，有<br /><span class="math display">\[    |f(x) - l| &lt; 1\]</span><br />从而有<br /><span class="math display">\[    |f(x)| \le |l| + |f(x) - l| &lt; 1 + |l|\]</span><br />从而令<span class="math inline">\(M = 1 +|l|\)</span>就满足条件了。<br />Q.E.D.</p><h4 id="定理4函数极限四则运算">定理4：函数极限四则运算</h4><blockquote><p>设<span class="math inline">\(\lim \limits_{x \to x_0}f(x)\)</span>与<span class="math inline">\(\lim \limits_{x \tox_0}g(x)\)</span>存在，那么<br />（1）<span class="math inline">\(\lim \limits_{x \to x_0} (f \pm g)(x) =\lim \limits_{x \to x_0} f(x) \pm \lim \limits_{x \to x_0}g(x)\)</span><br />（2）<span class="math inline">\(\lim \limits_{x \to x_0} fg(x) = \lim\limits_{x \to x_0} f(x) \cdot \lim \limits_{x \to x_0}g(x)\)</span><br />（3）<span class="math inline">\(\lim \limits_{x \to x_0} \frac{f}{g}(x)= \frac{\lim \limits_{x \to x_0} f(x)}{\lim \limits_{x \to x_0}g(x)}\)</span>，其中<span class="math inline">\(\lim \limits_{x \to x_0}g(x) \ne 0\)</span></p></blockquote><p>证：由<ahref="#theorem1">定理1</a>和数列极限的四则运算很容易证明<br />Q.E.D.</p><h4 id="定理5夹逼原理">定理5：夹逼原理</h4><blockquote><p>设函数<span class="math inline">\(f,g\)</span>与<spanclass="math inline">\(h\)</span>在点<spanclass="math inline">\(x_0\)</span>的近旁（点<spanclass="math inline">\(x_0\)</span>自身可能是例外）满足不等式<br /><span class="math display">\[    f(x) \le h(x) \le g(x)\]</span><br />如果<span class="math inline">\(f\)</span>与<spanclass="math inline">\(g\)</span>在<spanclass="math inline">\(x_0\)</span>处有相同的极限<spanclass="math inline">\(l\)</span>，那么函数<spanclass="math inline">\(h\)</span>在<spanclass="math inline">\(x_0\)</span>处也有极限<spanclass="math inline">\(l\)</span>。</p></blockquote><p>证：由<a href="#theorem1">定理1</a>和数列极限夹逼原理很容易证明<br />Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p>设存在<span class="math inline">\(r&gt;0\)</span>，使得当<spanclass="math inline">\(0&lt;|x-x_0|&lt;r\)</span>时，有不等式<spanclass="math inline">\(f(x) \le g(x)\)</span>恒成立，又设这两个函数<spanclass="math inline">\(x_0\)</span>处都有极限，那么<br /><span class="math display">\[    \lim \limits_{x \to x_0} f(x) \le \lim \limits_{x \to x_0} g(x)\]</span></p></blockquote><p>证：由<a href="#theorem1">定理1</a>和数列极限大小关系很容易证明<br />Q.E.D.</p><h4 id="定理7cauchy收敛原理">定理7：Cauchy收敛原理</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处有极限当且仅当对<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得对<spanclass="math inline">\(\forall x_1,x_2 \in B_\delta(\checkx_0)\)</span>，有<span class="math inline">\(|f(x_1) - f(x_2)| &lt;\varepsilon\)</span>。</p></blockquote><p>证：<strong>必要性</strong>。设<span class="math inline">\(\lim\limits_{x \to x_0} f(x) = l\)</span>，可知对<spanclass="math inline">\(\forall \varepsilon &gt; 0\)</span>，<spanclass="math inline">\(\exists \delta &gt; 0\)</span>，使得当<spanclass="math inline">\(x \in B_\delta(\check x_0)\)</span>时，有<br /><span class="math display">\[    |f(x) - l| &lt; \frac{\varepsilon}{2}\]</span><br />所以任取<span class="math inline">\(x_1,x_2 \in B_\delta(\checkx_0)\)</span>，有<br /><span class="math display">\[    \begin{aligned}    |f(x_1) - l| &lt; \frac{\varepsilon}{2} \\    |f(x_2) - 1| &lt; \frac{\varepsilon}{2}    \end{aligned}\]</span><br />显然有<br /><span class="math display">\[    |f(x_1) - f(x_2)| &lt; |f(x_1) - l| + |l - f(x_2)| &lt; \varepsilon\]</span><br /><strong>充分性</strong>。设<span class="math inline">\(\{x_n \ne x_0, n\in \mathbb{N^{*}}\}\)</span>是任意一个收敛于<spanclass="math inline">\(x_0\)</span>的数列，可知对取定的<spanclass="math inline">\(\delta\)</span>，存在<span class="math inline">\(N\in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(m,n&gt;N\)</span>时，有<spanclass="math inline">\(0&lt;|x_n - x_0| &lt; \delta, 0&lt;|x_m - x_0|&lt; \delta\)</span>，此时有<br /><span class="math display">\[    |f(x_n) - f(x_m)| &lt; \varepsilon\]</span><br />可知<spanclass="math inline">\(\{f(x_n)\}\)</span>是基本列，由数列的Cauchy收敛原理可知，数列<spanclass="math inline">\(\{f(x_n)\}\)</span>收敛，不妨设该数列收敛于<spanclass="math inline">\(l_x\)</span>；<br />若能证明无论<spanclass="math inline">\(\{x_n\}\)</span>怎么取，数列<spanclass="math inline">\(\{f(x_n)\}\)</span>收敛于相同的点，则再由<ahref="#theorem1">定理1</a>可知，函数<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>出也收敛。不妨设<spanclass="math inline">\(\{y_n\}\)</span>是另一个收敛于<spanclass="math inline">\(x_0\)</span>的数列，自然数列<spanclass="math inline">\(\{f(y_n)\}\)</span>也收敛，不妨设收敛于<spanclass="math inline">\(l_y\)</span>，构造数列<spanclass="math inline">\(\{z_n\}\)</span>：<br /><span class="math display">\[    x_1,y_1,x_2,y_2,\cdots,x_n,y_n,\cdots\]</span><br />可知<span class="math inline">\(z_n \ne x_0(n \in\mathbb{N^+})\)</span>，且<span class="math inline">\(z_n \to x_0( n \to\infty)\)</span>，可知数列<spanclass="math inline">\(\{f(z_n)\}\)</span>也有极限，记为<spanclass="math inline">\(l\)</span>，又因为<spanclass="math inline">\(\{f(x_n)\}\)</span>和<spanclass="math inline">\(\{f(y_n)\}\)</span>都是<spanclass="math inline">\(\{f(z_n)\}\)</span>的子列，所以有<br /><span class="math display">\[    l_x = l_y = l\]</span><br />Q.E.D.</p><h4 id="定理8">定理8</h4><blockquote><p>设<span class="math inline">\(\lim \limits_{x \to x_0} f(x) = l,\lim\limits_{t \to t_0} g(t) = x_0\)</span>，如果在<spanclass="math inline">\(t_0\)</span>的某个邻域<spanclass="math inline">\(B_\eta(t_0)\)</span>内有<spanclass="math inline">\(g(t) \ne x_0\)</span>，则<br /><span class="math display">\[    \lim \limits_{t \to t_0} f(g(t)) = l\]</span></p></blockquote><p>证。由<span class="math inline">\(\lim \limits_{x \to x_0} f(x) =l\)</span>，可知对<span class="math inline">\(\forall \varepsilon &gt;0, \exists \delta &gt; 0\)</span>，使得<span class="math inline">\(0&lt; |x-x_0| &lt; \delta\)</span>，有<span class="math inline">\(|f(x) -l| &lt; \varepsilon\)</span>；对给定的<spanclass="math inline">\(\delta&gt;0\)</span>，由<spanclass="math inline">\(\lim \limits_{t \to t_0} g(t) =x_0\)</span>，可知存在<span class="math inline">\(\eta_1 &gt;0\)</span>，使得<span class="math inline">\(0&lt;|t - t_0| &lt;\eta_1\)</span>时，有<span class="math inline">\(0&lt; |g(t) - x_0| &lt;\delta\)</span>，从而有<span class="math inline">\(|f(g(t)) - l| &lt;\varepsilon\)</span>，取<span class="math inline">\(\sigma = \min(\eta,\eta_1)\)</span>，即对<span class="math inline">\(\forall \varepsilon&gt; 0, \exists \sigma &gt; 0\)</span>，使得<spanclass="math inline">\(0&lt; |t-t_0| &lt; \sigma\)</span>时，有<spanclass="math inline">\(|f(g(t)) - l| &lt; \varepsilon\)</span>。</p><p>Q.E.D.</p><h4 id="定义2单边极限">定义2：单边极限</h4><blockquote><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\((x_0,x_0+r)\)</span>（<spanclass="math inline">\(r\)</span>是一个确定的正数）上有定义，若<spanclass="math inline">\(\forall \varepsilon &gt; 0, \exists \delta \in (0,r)\)</span>，使得当<span class="math inline">\(0 &lt; x - x_0 &lt;\delta\)</span>时，有<br /><span class="math display">\[    |f(x) - l| &lt; \varepsilon\]</span><br />则称<span class="math inline">\(l\)</span>为<spanclass="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的右极限，表示为<br /><span class="math display">\[    l = \lim \limits_{x \to x_0^+} f(x) = l\]</span><br />在右极限存在的情况下，也将右极限记为<spanclass="math inline">\(f(x_0+)\)</span></p></blockquote><p>类似地，可以定义<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>处的左极限<spanclass="math inline">\(f(x_0-) = \lim \limits_{x \to x_0^-}f(x)\)</span>；左右极限统称为单边极限。</p><h4 id="定理9">定理9</h4><blockquote><p>函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(x_0\)</span>的某个去心邻域内处有定义，则<spanclass="math inline">\(\lim \limits_{x \to x_0}f(x)\)</span>存在的充分必要条件是<br /><span class="math display">\[    f(x_0+) = f(x_0-)\]</span></p></blockquote><p>证明有极限与左右极限的定义显然。</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 函数极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解4：寻找两个正序数组的中位数</title>
      <link href="/2020/11/14/leetcode%E9%A2%98%E8%A7%A34/"/>
      <url>/2020/11/14/leetcode%E9%A2%98%E8%A7%A34/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">力扣第四题</a></p><p>给定两个大小为 m 和 n 的正序（从小到大）数组 <code>nums1</code>和 <code>nums2</code>。请你找出并返回这两个正序数组的中位数。<br />进阶：你能设计一个时间复杂度为 <code>O(log(m+n))</code>的算法解决此问题吗？</p><span id="more"></span><p>示例 1：</p><blockquote><p>输入：nums1 = [1,3], nums2 = [2]<br />输出：2.00000<br />解释：合并数组 = [1,2,3] ，中位数 2</p></blockquote><p>示例 2：</p><blockquote><p>输入：nums1 = [1,2], nums2 = [3,4]<br />输出：2.50000<br />解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</p></blockquote><p>示例 3：</p><blockquote><p>输入：nums1 = [0,0], nums2 = [0,0]<br />输出：0.00000</p></blockquote><p>示例 4：</p><blockquote><p>输入：nums1 = [], nums2 = [1]<br />输出：1.00000</p></blockquote><p>示例 5：</p><blockquote><p>输入：nums1 = [2], nums2 = []<br />输出：2.00000<br /> </p></blockquote><p>提示：</p><blockquote><ul><li>nums1.length == m</li><li>nums2.length == n</li><li>0 &lt;= m &lt;= 1000</li><li>0 &lt;= n &lt;= 1000</li><li>1 &lt;= m + n &lt;= 2000</li><li>-106 &lt;= nums1[i], nums2[i] &lt;= 106</li></ul></blockquote><h2 id="分析">分析</h2><p>时间复杂度需达<spanclass="math inline">\(O(\log(n))\)</span>级别，首先想到的是二分法，但该题如何使用二分求解，还需仔细分析。</p><h3 id="中位数特点">中位数特点</h3><p>中位数的特点是比它小的数和比它大的数一样多，如下面例子</p><blockquote><p>1 2 3 4 <font color='blue'>5</font> 6 7 8 9</p></blockquote><p><code>5</code>的前面有四个数<code>1 2 3 4</code>，后面有四个数<code>6 7 8 9</code>，从而<code>5</code>是中位数</p><blockquote><p>1 2 3 4 <font color='blue'>5 6</font> 7 8 9 10</p></blockquote><p><code>5 6</code>的前面有四个数<code>1 2 3 4</code>，后面有四个数<code>6 7 8 9</code>，从而<code>(5+6)/2=5.5</code>是中位数</p><p>所以想找到中位数就需要找到一个分割使得以下两点满足：<br />1. 该分割的左边元素比右边元素至多多出一个<br />2. 该分割的右边元素都要大于左边的元素</p><h3 id="两个排序数组的中位数寻找">两个排序数组的中位数寻找</h3><p>对于两个排序数组，比如</p><blockquote><p>1 4 5 7 8 9<br />2 3 6</p></blockquote><p>这时分割应该是</p><blockquote><p><font color='red'>1 4 5</font> <font color='blue'>7 8 9</font><br /><font color='red'>2 3</font> <font color='blue'>6</font></p></blockquote><p>可以看到分割的左边为<code>1 4 5 2 3</code>，右边为<code>6 7 8 9</code>，满足上述两点。</p><p>所以基本想法是首先遍历所有满足第一点的分割，然后判断该分割是否满足第二点即可。</p><ul><li><p>满足第1点的分割</p><p>找分割无非就是如何划分，使得左边有5个数罢了，而这5个数来自于上面数组和下面数组，从而以<code>2 3 6</code>作为基准，如果<code>2 3 6</code>中没有划分到左边的，那么左边5个数都是来自上面数组的<code>1 4 5 7 8</code>；如果<code>2 3 6</code>中只有<code>2</code>划分到左边，那显然是上面数组的<code>1 4 5 7</code>划分到左边。<br />所有分割情况如下四种：<br />（1）</p><blockquote><p><font color='red'>1 4 5 7 8</font> <font color='blue'>9</font><br /><font color='blue'>2 3 6</font></p></blockquote><p>（2）</p><blockquote><p><font color='red'>1 4 5 7</font> <font color='blue'>8 9</font><br /><font color='red'>2</font> <font color='blue'>3 6</font></p></blockquote><p>（3）</p><blockquote><p><font color='red'>1 4 5</font> <font color='blue'>7 8 9</font><br /><font color='red'>2 3</font> <font color='blue'>6</font></p></blockquote><p>（4）</p><blockquote><p><font color='red'>1 4</font> <font color='blue'>5 7 8 9</font><br /><font color='red'>2 3 6</font></p></blockquote></li><li><p>满足第2点的分割</p><p>以下面分割为例</p><blockquote><p><font color='red'>1 4 5 7</font> <font color='blue'>8 9</font><br /><font color='red'>2</font> <font color='blue'>3 6</font></p></blockquote><p>要判断右边元素是否都要大于左边，只需判断<code>8 3</code>是否都要大于<code>7 2</code>，由于上下两个数组已经排好序了，表示<spanclass="math inline">\((8,7),(3,2)\)</span>已经满足条件了，所以只需比较<spanclass="math inline">\((8,2),(3,7)\)</span>是否满足条件，显然<spanclass="math inline">\(3 &lt;7\)</span>，所以该分割不满足第2点。</p></li></ul><h3 id="最终算法">最终算法</h3><p>经过以上例子的分析，下面解释一般的情况，比如两个数组</p><blockquote><p><span class="math inline">\(a_0 a_1 a_2 a_3 a_4 a_5\)</span><br /><span class="math inline">\(b_0 b_1 b_2\)</span></p></blockquote><p>假设任取分割<spanclass="math inline">\((4,1)\)</span>，表示分割点分别在<spanclass="math inline">\(a_4\)</span>的左边和<spanclass="math inline">\(b_1\)</span>的左边</p><blockquote><p><font color="red"><span class="math inline">\(a_0 a_1 a_2a_3\)</span></font> <span class="math inline">\(a_4 a_5a_6\)</span><br /><font color="red"><span class="math inline">\(b_0\)</span></font> <spanclass="math inline">\(b_1 b_2\)</span></p></blockquote><p>这时根据<span class="math inline">\(a_4,b_0\)</span>的大小关系和<spanclass="math inline">\(b_1,a_3\)</span>的大小关系分成三种情况<br />1. <span class="math inline">\(a_4 \ge b_0\)</span>且<spanclass="math inline">\(b_1 \ge a_3\)</span><br />这时分割已经找到了<br />2. <span class="math inline">\(b_1 &lt; a_3\)</span>，可以推出<spanclass="math inline">\(b_0 \le b_1 &lt; a_3 \le a_4 \Rightarrow b_0 &lt;a_4\)</span><br />这时比<span class="math inline">\(b_1\)</span>大的数至少有<spanclass="math inline">\(a_3,a_4,a_5,a_6,b_2\)</span>这5个数，显然比<spanclass="math inline">\(b_1\)</span>还小的数不可能是中位数，所以分割点必然在<spanclass="math inline">\(b_1\)</span>的右边<br />3. <span class="math inline">\(a_4 &lt; b_0\)</span>，可以推出<spanclass="math inline">\(a_3 \le a_4 &lt; b_0 \le b_1 \Rightarrow a_3 &lt;b_1\)</span><br />这时比<span class="math inline">\(b_1\)</span>小的数至少有<spanclass="math inline">\(a_0,a_1,a_2,a_3,b_0\)</span>这5个数，显然比<spanclass="math inline">\(b_1\)</span>还大的数不可能是中位数，所以分割点必然在<spanclass="math inline">\(b_1\)</span>的左边</p><p>如此才出现了二分的样子了。所以假设<code>nums2</code>是短的那个数组，且长度为<code>n</code>，取<code>0&lt;=j&lt;=n</code>作为<code>nums2</code>的分割点，如果<code>j=n</code>表示<code>nums2</code>的所有元素都归左边，若<code>j&lt;n</code>，则<code>nums2[j]</code>左边的元素归左边。</p><p>由于二分法每次可以筛选掉一半，所以初始化<code>jleft=0,jright=n</code>，然后执行</p><ol type="1"><li><p><code>j = (jleft+jright) // 2</code>，显然此时<code>nums1</code>的分割点<code>i = (m+n+1)//2 - j</code>，如下</p><blockquote><p>... <code>nums1[i-1], nums1[i]</code>, ...<br />... <code>nums2[j-1], nums2[j]</code>, ...</p></blockquote><p>这时需比较<code>nums1[i],nums2[j-1]</code>的大小以及<code>nums2[j],nums1[i-1]</code>的大小关系了，</p></li><li><p>若<code>nums1[i] &gt;= nums2[j-1] &amp;&amp; nums2[j] &gt;= nums1[i-1]</code>表示找到了分割点，此时若<code>m+n</code>是奇数，表示中位数只有一个，而分割的左边比右边多一个元素，所以中位数必然是<code>max(nums1[i-1], num2[j-1])</code>；如果<code>m+n</code>是偶数，中位数取两个的均值，此时取<code>max(nums1[i-1], num2[j-1])</code>和<code>min(nums1[i], num2[j])</code>的均值就是中位数了。<strong>也就是说中位数要么是左边数的最大值，要么是左边数的最大值与右边数的最小值的均值。</strong></p></li><li><p>若<code>nums2[j] &lt; nums1[i-1]</code>，这时分割点在<code>j</code>的右边，所以令<code>jleft=j+1</code>，然后回到第1步</p></li><li><p>若<code>nums1[i] &lt; nums2[j-1]</code>，这时分给点在<code>j</code>的左边，所以令<code>jright=j-1</code>，然后回到第1步</p></li></ol><p>按照上述步骤下去，就可以找到最终解了，记左边最大值为<code>max_left</code>，右边最小值为<code>min_right</code>；<br />最后注意边界:</p><p>边界1：若<code>j=0,i&lt;m</code>，此时如下</p><blockquote><p>...,<code>nums1[i-1],nums1[i]</code>,...<br /><code>nums2[0],nums2[1]</code>,...</p></blockquote><p>可知左边只有<code>nums1[i-1]</code>，所以<code>max_left=nums1[i-1]</code>；而<code>min_right=min(nums[i],nums2[k])</code>；</p><p>边界2：若<code>j=0,i=m</code>，此时如下</p><blockquote><p>...,<code>nums1[m-1]</code><br /><code>nums2[0],nums2[1]</code>,...</p></blockquote><p>可知<code>max_left=nums1[m-1]</code>，<code>min_right=nums2[0]</code>;</p><p>边界3：若<code>j=n,i&gt;0</code>，此时如下</p><blockquote><p>...,<code>nums1[i-1],nums1[i]</code>,...<br />...,<code>nums2[n-2],nums2[n-1]</code></p></blockquote><p><code>max_left=max(nums1[i-1],nums2[n-1])</code>；<code>min_right=nums1[i]</code>;</p><p>边界3：若<code>j=n,i=0</code>，此时如下</p><blockquote><p><code>nums1[0],nums1[1]</code>,...<br />...,<code>nums2[n-2],nums2[n-1]</code></p></blockquote><p><code>max_left=nums2[n-1]</code>；<code>min_right=nums1[0]</code>。</p><p>由于每次都是对最短的数组进行二分，所以时间复杂度为<spanclass="math inline">\(O(\log(\min(m, n)))\)</span>。</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMedianSortedArrays</span>(<span class="params">self, nums1, nums2</span>):</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="keyword">if</span> m &lt; n:</span><br><span class="line">            m, n, nums1, nums2 = n, m, nums2, nums1</span><br><span class="line"></span><br><span class="line">        half_len = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span></span><br><span class="line">        jleft, jright = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> jleft &lt;= jright:</span><br><span class="line">            j = (jleft + jright) &gt;&gt; <span class="number">1</span></span><br><span class="line">            i = half_len - j</span><br><span class="line">            <span class="keyword">if</span> j &lt; n <span class="keyword">and</span> nums2[j] &lt; nums1[i-<span class="number">1</span>]:</span><br><span class="line">                jleft = j + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> nums1[i] &lt; nums2[j-<span class="number">1</span>]:</span><br><span class="line">                jright = j - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">            max_left = nums1[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">elif</span> j == n <span class="keyword">and</span> i == <span class="number">0</span>:</span><br><span class="line">            max_left = nums2[j-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            max_left = <span class="built_in">max</span>(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> max_left</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> j == n:</span><br><span class="line">            min_right = nums1[i]</span><br><span class="line">        <span class="keyword">elif</span> j == <span class="number">0</span> <span class="keyword">and</span> i == m:</span><br><span class="line">            min_right = nums2[j]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            min_right = <span class="built_in">min</span>(nums1[i], nums2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (max_left + min_right) / <span class="number">2</span></span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &lt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">findMedianSortedArrays</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> halfLen = (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> jleft = <span class="number">0</span>, jright = n;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span> (jleft &lt;= jright) &#123;</span><br><span class="line">            j = (jleft + jright) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            i = halfLen - j;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; nums2[j] &lt; nums1[i - <span class="number">1</span>])</span><br><span class="line">                jleft = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; nums1[i] &lt; nums2[j - <span class="number">1</span>])</span><br><span class="line">                jright = j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> max_left = <span class="number">0</span>, min_right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) max_left = nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == n &amp;&amp; i == <span class="number">0</span>) max_left = nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> max_left = <span class="built_in">max</span>(nums1[i - <span class="number">1</span>], nums2[j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> max_left;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == n) min_right = nums1[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span> &amp;&amp; i == m) min_right = nums2[j];</span><br><span class="line">        <span class="keyword">else</span> min_right = <span class="built_in">min</span>(nums1[i], nums2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (min_right + max_left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.length &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length, n = nums2.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">halfLen</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">jleft</span> <span class="operator">=</span> <span class="number">0</span>, jright = n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(jleft &lt;= jright) &#123;</span><br><span class="line">            j = (jleft + jright) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            i = halfLen - j;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; nums2[j] &lt; nums1[i-<span class="number">1</span>]) jleft = j + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; <span class="number">0</span> &amp;&amp; nums1[i] &lt; nums2[j-<span class="number">1</span>]) jright =  j - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> maxLeft, minRight;</span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span>) maxLeft = nums1[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == n &amp;&amp; i==<span class="number">0</span>) maxLeft = nums2[j-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> maxLeft = Math.max(nums1[i-<span class="number">1</span>], nums2[j-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> maxLeft;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == n) minRight = nums1[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span> &amp;&amp; i == m) minRight = nums2[j];</span><br><span class="line">        <span class="keyword">else</span> minRight = Math.min(nums1[i], nums2[j]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (maxLeft + minRight) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限六：拓扑学基础之列紧集、紧致集、连通集</title>
      <link href="/2020/11/10/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%906/"/>
      <url>/2020/11/10/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%906/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1列紧集">定义1：列紧集</h4><blockquote><p>设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，如果<spanclass="math inline">\(E\)</span>中的任一点列都有一个子列收敛于<spanclass="math inline">\(E\)</span>中的一个点，则称<spanclass="math inline">\(E\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>中的一个列紧集。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p><span class="math inline">\(\mathbb{R^n}\)</span>中的集合<spanclass="math inline">\(E\)</span>为列紧集的充分必要条件是<spanclass="math inline">\(E\)</span>是有界闭集。</p></blockquote><span id="more"></span><p>证：必要性。如果<spanclass="math inline">\(E\)</span>是无界的，那么必可以找到一个子列<spanclass="math inline">\(\{\boldsymbol{x}_i\} \subset E\)</span>，满足<spanclass="math inline">\(\Vert \boldsymbol{x}_i \Vert &gt;i(i=1,2,3,\cdots)\)</span>，显然<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>不收敛，从而<spanclass="math inline">\(E\)</span>不可能是列紧集。如果<spanclass="math inline">\(E\)</span>不是闭集，则<spanclass="math inline">\(E^{\prime} \not\subsetE\)</span>，则必可以找到一个收敛点列<spanclass="math inline">\(\{\boldsymbol{x}_i\} \subset E\)</span>有极限<spanclass="math inline">\(\boldsymbol{a}\)</span>，且<spanclass="math inline">\(\boldsymbol{a} \notinE\)</span>，从而找不到一个<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>的子列，使得该子列收敛于<spanclass="math inline">\(E\)</span>中的点，从而<spanclass="math inline">\(E\)</span>不是列紧集。矛盾。<br />充分性。任取点列<span class="math inline">\(\{\boldsymbol{x}_i\} \subsetE\)</span>，由于<spanclass="math inline">\(E\)</span>是有界集，从而<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>有界，由Bolzano-Weierstrass定理可知，存在一个收敛子列<spanclass="math inline">\(\{\boldsymbol{x}_{k_i}\}\)</span>收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>，又因为<spanclass="math inline">\(E\)</span>是闭集，可知<spanclass="math inline">\(\boldsymbol{a} \in E\)</span>，所以<spanclass="math inline">\(E\)</span>是列紧集。</p><p>Q.E.D.</p><h4 id="定义2开覆盖">定义2：开覆盖</h4><blockquote><p>设<span class="math inline">\(E \subset \mathbb{R^n}\)</span>，<spanclass="math inline">\(\mathscr{J} = \{G_\alpha\}\)</span>是<spanclass="math inline">\(\mathbb{R}^n\)</span>中的一个开集族，如果<br /><span class="math display">\[    E \subset \bigcup \limits_\alpha G_\alpha\]</span><br />则称开集族<span class="math inline">\(\mathscr{J}\)</span>覆盖了<spanclass="math inline">\(E\)</span>，或称<spanclass="math inline">\(\mathscr{J}\)</span>是<spanclass="math inline">\(E\)</span>的一个开覆盖。</p></blockquote><h4 id="定义3紧致集">定义3：紧致集</h4><blockquote><p>设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，若能从<spanclass="math inline">\(E\)</span>的任意一个开覆盖中选出有限个开集，它们仍然能组成<spanclass="math inline">\(E\)</span>的开覆盖，则称<spanclass="math inline">\(E\)</span>为一个紧致集。</p></blockquote><h4 id="定理2">定理2</h4><blockquote><p><span class="math inline">\(E \subset\mathbb{R^n}\)</span>为紧致集的一个充分必要条件是<spanclass="math inline">\(E\)</span>为有界闭集。</p></blockquote><p>证：<strong>必要性</strong>。设<spanclass="math inline">\(E\)</span>为紧致集，考虑以原点<spanclass="math inline">\(\boldsymbol{0}=(0,0,\cdots,0)\)</span>为球心，<spanclass="math inline">\(m \in \mathbb{N^+}\)</span>为半径的球<spanclass="math inline">\(B_m(\boldsymbol{0})\)</span>。有<br /><span class="math display">\[    E \subset \mathbb{R^n} = \bigcup \limits_{m=1}^\inftyB_m(\boldsymbol{0})\]</span><br />从而<span class="math inline">\(\mathscr{J}=\{B_m(\boldsymbol{0}):m \in\mathbb{N^+}\}\)</span>是<spanclass="math inline">\(E\)</span>的一个开覆盖，所以可从<spanclass="math inline">\(\mathscr{J}\)</span>中选取有限个元素，记作<br /><span class="math display">\[    B_{k_1}(\boldsymbol{0}), B_{k_2}(\boldsymbol{0}), \cdots,B_{k_t}(\boldsymbol{0})\]</span><br />它们仍然组成<span class="math inline">\(E\)</span>的一个开覆盖，令<br /><span class="math display">\[    s = \max(k_1,k_2,\cdots,k_t)\]</span><br />可知<span class="math inline">\(E \subsetB_s(\boldsymbol{0})\)</span>，因此<spanclass="math inline">\(E\)</span>是有界的。<br />再证<span class="math inline">\(E\)</span>闭集。即证<spanclass="math inline">\(E^c\)</span>是开集，任取<spanclass="math inline">\(\boldsymbol{q} \in E^c\)</span>，对<spanclass="math inline">\(\forall \boldsymbol{q} \inE\)</span>，存在充分小的球<spanclass="math inline">\(B_r(\boldsymbol{q})\)</span>，使得<spanclass="math inline">\(B_r(\boldsymbol{q}) \cap B_r(\boldsymbol{p}) =\varnothing\)</span>，这里半径<spanclass="math inline">\(r&gt;0\)</span>且于<spanclass="math inline">\(\boldsymbol{q}\)</span>有关，所有的<spanclass="math inline">\(B_{r}(\boldsymbol{q})\)</span>全体构成<spanclass="math inline">\(E\)</span>的一个开覆盖，从而可以取出有限个球<br /><span class="math display">\[    B_{r_1}(\boldsymbol{q_1}),B_{r_2}(\boldsymbol{q_2}),\cdots,B_{r_m}(\boldsymbol{q_m})\]</span><br />仍然构成<span class="math inline">\(E\)</span>的一个开覆盖，可知<br /><span class="math display">\[    B_{r_i}(\boldsymbol{q_i}) \cap B_{r_i}(\boldsymbol{p}) = \varnothing\quad (i=1,2,\cdots,m)\]</span><br />令<br /><span class="math display">\[    s = \min(r_1,r_2,\cdots,r_m)\]</span><br />可知球<span class="math inline">\(B_s(\boldsymbol{p}) \cap E =\varnothing\)</span>，所以<spanclass="math inline">\(B_s(\boldsymbol{p}) \subsetE^c\)</span>，从而<span class="math inline">\(E^c\)</span>是开集。<br /><strong>充分性</strong>。反证法，假设<spanclass="math inline">\(E\)</span>不是紧致集，则存在开集族<spanclass="math inline">\(\{G_{\alpha}\}\)</span>，它是<spanclass="math inline">\(E\)</span>的一个开覆盖，但它的任意有限子族不能覆盖<spanclass="math inline">\(E\)</span>，由于<spanclass="math inline">\(E\)</span>是有界闭集，从而从在一个超立方体<spanclass="math inline">\(I^n\)</span>，使得<span class="math inline">\(E\subset I\)</span>，将<spanclass="math inline">\(I\)</span>分成相等的<spanclass="math inline">\(2^n\)</span>个闭超立方体<spanclass="math inline">\(K_1,K_2,\cdots,K_{2^n}\)</span>，可知<br /><span class="math display">\[    I^n = K_1 \cup K_2 \cup \cdots \cup K_{2^n}\]</span><br />且<br /><span class="math display">\[    diam (K_i) = \frac{1}{2} diam(I^n) (i=1,2,\cdots,2^n)\]</span><br />由于<span class="math inline">\(E\)</span>不能被<spanclass="math inline">\(\{G_{\alpha}\}\)</span>的任意有限子族覆盖，所以存在某个<spanclass="math inline">\(K_i\)</span>使得，不妨记为<spanclass="math inline">\(F_1\)</span>，使得<br /><span class="math display">\[    H_1 = F_1 \cap E\]</span><br />不能被<spanclass="math inline">\(\{G_{\alpha}\}\)</span>的任意有限子族覆盖，且<spanclass="math inline">\(diam(H_1) \le diam(F_1) = \frac{1}{2}diam(I^n)\)</span>，继续对<spanclass="math inline">\(F_1\)</span>做上述划分和分析，可知必存在闭超立方体<spanclass="math inline">\(F_2\)</span>，使得<br /><span class="math display">\[    H_2 = F_2 \cap E\]</span><br />不能被<spanclass="math inline">\(\{G_{\alpha}\}\)</span>的任意有限子族覆盖，且<spanclass="math inline">\(diam(H_2) \le diam(F_2) = \frac{1}{2} diam(F_1) =\frac{1}{2^2} diam(I^n)\)</span>，一直进行下去，从而得到一列闭集<spanclass="math inline">\(H_k = F_k \capE(k=1,2,\cdots)\)</span>，它们满足<br />(a) <span class="math inline">\(H_1 \supset H_2 \supset\cdots\)</span><br />(b) <span class="math inline">\(diam(H_k) \le \frac{1}{2^k} diam(I) \to0 (k \to \infty)\)</span><br />(c) 每个<span class="math inline">\(H_k\)</span>都不能被<spanclass="math inline">\(\{G_{\alpha}\}\)</span>的任意有限子族覆盖<br />由(a)和(b)可知，<spanclass="math inline">\(\{H_k\}\)</span>满足闭区间套的条件，从而存在唯一的点<spanclass="math inline">\(\boldsymbol{\xi} \in \bigcap\limits_{k=1}^\infty\boldsymbol{H}_k\)</span>，由因为<spanclass="math inline">\(\boldsymbol{\xi} \in E\)</span>，而<spanclass="math inline">\(\{G_{\alpha}\}\)</span>是<spanclass="math inline">\(E\)</span>的一个开覆盖，所以存在某个开集<spanclass="math inline">\(G_{\beta} \in \{G_{\alpha}\}\)</span>，使得<spanclass="math inline">\(\boldsymbol{\xi} \inG_{\beta}\)</span>，从而存在<span class="math inline">\(r &gt;0\)</span>，使得<span class="math inline">\(B_r(\boldsymbol{\xi})\subset G_{\beta}\)</span>，又由(b)可知，存在充分大的<spanclass="math inline">\(k\)</span>，使得<spanclass="math inline">\(diam(H_k) &lt; r\)</span>。<br />此时对任意的<span class="math inline">\(\boldsymbol{x} \inH_k\)</span>，因为<span class="math inline">\(\boldsymbol{\xi} \inH_k\)</span>，从而有<br /><span class="math display">\[    \Vert \boldsymbol{x} - \boldsymbol{\xi} \Vert \le diam(H_k) &lt; r\]</span><br />即有<span class="math inline">\(\boldsymbol{x} \in B_r(\boldsymbol{\xi})\subset G_{\beta}\)</span>，所以<span class="math inline">\(H_k \subsetG_{\beta}\)</span>，这与(c)矛盾。</p><p>Q.E.D.</p><h4 id="定义4连通集">定义4：连通集</h4><blockquote><p>设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，如果<spanclass="math inline">\(E\)</span>的任一分解式<spanclass="math inline">\(E=A \cup B\)</span>满足条件<spanclass="math inline">\(A \ne \varnothing,B \ne\varnothing\)</span>，并且<span class="math inline">\(A \cap B =\varnothing\)</span>，便可使得以下两式：<br /><span class="math display">\[    A \cap B^{\prime} \ne \varnothing \quad A^{\prime} \cap B \ne\varnothing\]</span><br />中至少有一个成立，那么称<span class="math inline">\(E\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>中的一个连通集，或者称<spanclass="math inline">\(E\)</span>是连通的。</p></blockquote><h4 id="定义5区域和闭区域">定义5：区域和闭区域</h4><blockquote><p>在<spanclass="math inline">\(\mathbb{R^n}\)</span>中，连通的开集称为区域，区域的闭包称为闭区域。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>开集<span class="math inline">\(E \subset\mathbb{R^n}\)</span>为连通集的充分必要条件是<spanclass="math inline">\(E\)</span>不能分解成两个不相交的非空开集之并。</p></blockquote><p>证：<strong>必要性</strong>。假设有分解式<spanclass="math inline">\(E=A \cup B\)</span>，其中<spanclass="math inline">\(A\)</span>与<spanclass="math inline">\(B\)</span>是非空开集，并且<spanclass="math inline">\(A \cap B = \varnothing\)</span>，由于<spanclass="math inline">\(B\)</span>是开集，从而对<spanclass="math inline">\(\forall \boldsymbol{b} \inB\)</span>，都存在球对于<span class="math inline">\(B_r(\boldsymbol{b})\subset B\)</span>，即有<span class="math inline">\(B_r(\boldsymbol{b})\cap A = \varnothing\)</span>，从而<spanclass="math inline">\(\boldsymbol{b}\)</span>不可能是<spanclass="math inline">\(A\)</span>的凝聚点，即<spanclass="math inline">\(B \cap A^{\prime} =\varnothing\)</span>，同理<span class="math inline">\(A \cap B^{\prime}= \varnothing\)</span>，从而<spanclass="math inline">\(E\)</span>不是连通集，矛盾。<br /><strong>充分性</strong>。如果<spanclass="math inline">\(E\)</span>不连通，那么存在两个互不相交的非空集<spanclass="math inline">\(A\)</span>和<spanclass="math inline">\(B\)</span>，使得<span class="math inline">\(E = A\cup B\)</span>，且<span class="math inline">\(A \cap B^{\prime} =\varnothing,A^{\prime} \cap B = \varnothing\)</span>，任取<spanclass="math inline">\(\boldsymbol{a} \in A\)</span>，可知<spanclass="math inline">\(\boldsymbol{a} \in E\)</span>，由于<spanclass="math inline">\(E\)</span>是开集，从而存在球<spanclass="math inline">\(B_r(\boldsymbol{a}) \in E\)</span>；又因<spanclass="math inline">\(\boldsymbol{a}\)</span>不是<spanclass="math inline">\(B\)</span>的凝聚点，即存在球<spanclass="math inline">\(B_s(\boldsymbol{a})\)</span>不含<spanclass="math inline">\(B\)</span>中的点，从而取<spanclass="math inline">\(m = \min(r, s)\)</span>，可知球<spanclass="math inline">\(B_m(\boldsymbol{a})\)</span>满足<br /><span class="math display">\[    B_m(\boldsymbol{a}) \subset E, \quad B_m(\boldsymbol{a}) \cap B =\varnothing\]</span><br />自然有<span class="math inline">\(B_m(\boldsymbol{a}) \subsetA\)</span>，从而<span class="math inline">\(A\)</span>是开集，同理<spanclass="math inline">\(B\)</span>是开集，矛盾。所以<spanclass="math inline">\(E\)</span>是连通集。</p><p>Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>在<span class="math inline">\(\mathbb{R}\)</span>上，集合<spanclass="math inline">\(E\)</span>是连通的充分必要条件是<spanclass="math inline">\(E\)</span>为区间。</p></blockquote><p>证：<strong>必要性</strong>。假设<span class="math inline">\(E\subset \mathbb{R}\)</span>是连通集，要证<spanclass="math inline">\(E\)</span>是区间，即证任取<spanclass="math inline">\(a,b \in E\)</span>，不妨设<spanclass="math inline">\(a &lt; b\)</span>，有<spanclass="math inline">\([a, b] \subset E\)</span>。反证法，假设存在<spanclass="math inline">\(c \in [a,b]\)</span>，使得<spanclass="math inline">\(c \notin E\)</span>，作集合<br /><span class="math display">\[    A = \{ x \in E: x&lt;c \} \quad B=\{x \in E: x &gt; c\}\]</span><br />可知<span class="math inline">\(A,B\)</span>非空，<spanclass="math inline">\(E = A \cup B\)</span>，而且<spanclass="math inline">\(A^{\prime} \cap B = \varnothing,A \cap B^{\prime}= \varnothing\)</span>，可知<spanclass="math inline">\(E\)</span>不连通，矛盾。<br /><strong>充分性</strong>。任取分解式<span class="math inline">\(E=A \cupB\)</span>，其中<span class="math inline">\(A,B\)</span>非空，且<spanclass="math inline">\(A \cap B = \varnothing\)</span>，存在<spanclass="math inline">\(a \in A, b \in B\)</span>，不妨设<spanclass="math inline">\(a &lt; b\)</span>，从而有<spanclass="math inline">\([a, b] \subset E\)</span>，取<spanclass="math inline">\(c_1 = \frac{a+b}{2}\)</span>，若<spanclass="math inline">\(c_1 \in A\)</span>，则令<spanclass="math inline">\(a_1=c_1,b_1=b\)</span>，或则令<spanclass="math inline">\(a_1=a,b_1=c_1\)</span>，若此下去可作出闭区间套<spanclass="math inline">\([a_k,b_k]\)</span>，其中<spanclass="math inline">\(a_k \in A, b_k \in B(k \in\mathbb{N^+})\)</span>，可知存在一个<span class="math inline">\(c \in[a_k,b_k] (k\in \mathbb{N^+})\)</span>，且<spanclass="math inline">\(a_k \to c, b_k \to c(k \to\infty)\)</span>；所以如果<span class="math inline">\(c \inA\)</span>，那么<span class="math inline">\(c \notinB\)</span>，从而<span class="math inline">\(c \inB^{\prime}\)</span>，从而<span class="math inline">\(A \cap B^{\prime}\ne \varnothing\)</span>，同理若<span class="math inline">\(c \inB\)</span>，有<span class="math inline">\(A^{\prime} \cap B \ne\varnothing\)</span>，所以<spanclass="math inline">\(E\)</span>是连通的。</p><p>Q.E.D.</p><h4 id="定义6道路连通集">定义6：道路连通集</h4><blockquote><p>设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，如果对任意的两点<spanclass="math inline">\(\boldsymbol{p},\boldsymbol{q} \inE\)</span>，都有一条连续曲线<span class="math inline">\(l \subsetE\)</span>将<spanclass="math inline">\(\boldsymbol{p},\boldsymbol{q}\)</span>连接起来，则称<spanclass="math inline">\(E\)</span>是道路连通的。所谓<spanclass="math inline">\(\mathbb{R^n}\)</span>中的连续曲线<spanclass="math inline">\(l\)</span>，是指可以表示为参数分成：<br /><span class="math display">\[    x_i = \varphi_i(t) \quad (i=1,2,\cdots,n)\]</span><br />其中<spanclass="math inline">\(\varphi_i(i=1,2,\cdots,n)\)</span>是区间<spanclass="math inline">\([a,b]\)</span>上的连续函数，且<br /><span class="math display">\[    \begin{aligned}    \boldsymbol{p} = (\varphi_1(a), \varphi_2(a), \cdots, \varphi_n(a))\\    \boldsymbol{q} = (\varphi_1(b), \varphi_2(b), \cdots, \varphi_n(b))    \end{aligned}\]</span></p></blockquote><h4 id="定理5">定理5</h4><blockquote><p>道路连通集一定是连通集</p></blockquote><p>证：设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>是一个道路连通集，任取分解式<spanclass="math inline">\(E = A \cup B\)</span>，其中<spanclass="math inline">\(A,B\)</span>是互不相交的非空集，在<spanclass="math inline">\(A\)</span>中任取一点<spanclass="math inline">\(\boldsymbol{p}\)</span>，在<spanclass="math inline">\(B\)</span>中任取一点<spanclass="math inline">\(\boldsymbol{q}\)</span>，则存在一条连续曲线<spanclass="math inline">\(\Gamma \subset E\)</span>把<spanclass="math inline">\(\boldsymbol{p},\boldsymbol{q}\)</span>两点连接起来，令<br /><span class="math display">\[    \boldsymbol{\Phi}(t) =(\varphi_1(t),\varphi_2(t),\cdots,\varphi_n(t)) \quad (a \le t \le b)\]</span><br />为<span class="math inline">\(\Gamma\)</span>的参数方程，令<br /><span class="math display">\[    F = \{ t \in [a,b]: \boldsymbol{\Phi}(t) \in A \} \quad G = \{ t \in[a,b]: \boldsymbol{\Phi}(t) \in B \}\]</span><br />可知<spanclass="math inline">\(F,G\)</span>是互不相交的非空集合，且<spanclass="math inline">\(F \cup G = [a, b]\)</span>，又由于<spanclass="math inline">\([a,b]\)</span>是连通集，所以<spanclass="math inline">\(F \cap G^{\prime}\)</span>和<spanclass="math inline">\(F^{\prime} \capG\)</span>至少有一个非空，不妨设<span class="math inline">\(c \in F \capG^{\prime}\)</span>，由<span class="math inline">\(c \inG^{\prime}\)</span>，知有数列<span class="math inline">\(\{t_i\} \subsetG\)</span>，使得<span class="math inline">\(\lim \limits_{i \to \infty}t_i = c\)</span>，由于<spanclass="math inline">\(\varphi_i(i=1,2,\cdots,n)\)</span>是连续函数，可知<br /><span class="math display">\[    \lim \limits_{i \to \infty} \boldsymbol{\Phi}(t_i) =\boldsymbol{\Phi}(c)\]</span><br />由于<span class="math inline">\(\boldsymbol{\Phi}(t_i) \inB(i=1,2,\cdots,n)\)</span>且<spanclass="math inline">\(\boldsymbol{\Phi}(c) \in A\)</span>，可知<spanclass="math inline">\(\boldsymbol{\Phi}(c) \notin B\)</span>，从而<spanclass="math inline">\(\boldsymbol{\Phi}(c) \inB^{\prime}\)</span>，所以<spanclass="math inline">\(\boldsymbol{\Phi}(c) \in A \capB^{\prime}\)</span>，即<span class="math inline">\(A \cap B^{\prime} \ne\varnothing\)</span>，可得<spanclass="math inline">\(E\)</span>是连通集。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 点列极限 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode题解1：两数之和</title>
      <link href="/2020/11/07/leetcode%E9%A2%98%E8%A7%A31/"/>
      <url>/2020/11/07/leetcode%E9%A2%98%E8%A7%A31/</url>
      
        <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>该题来自于<ahref="https://leetcode-cn.com/problems/two-sum/">力扣第一题</a></p><p>给定一个整数数组<code>nums</code>和一个目标值<code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。<br />你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><span id="more"></span><p>示例:</p><blockquote><p>给定 nums = [2, 7, 11, 15], target = 9<br />因为 nums[0] + nums[1] = 2 + 7 = 9<br />所以返回 [0, 1]</p></blockquote><h2 id="分析">分析</h2><p>如果原数组已经排好了序，这时可以使用左右双指针法，空间复杂度为<spanclass="math inline">\(O(1)\)</span>，时间复杂度为<spanclass="math inline">\(O(n)\)</span>；<br />但这里原数组无序，要想依然达到<spanclass="math inline">\(O(n)\)</span>的时间复杂度，关键在于如何使用<spanclass="math inline">\(O(1)\)</span>的时间复杂度在数组中查找元素并获取下标，这时自然会想到使用hash存储。<br />所以基本思路为：将原始数组存储为HashMap，之后只需遍历数组元素并查询数组中是否存在(<strong>目标值</strong><spanclass="math inline">\(-\)</span><strong>元素值</strong>)的元素，如果存在取出相应下标即可。此时空间复杂度为<spanclass="math inline">\(O(n)\)</span>，时间复杂度为<spanclass="math inline">\(O(n)\)</span>。</p><h2 id="代码">代码</h2><details open><summary>python3</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums, target</span>):</span><br><span class="line">        item_idx_map = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment"># 获取另一个数的下标，如果不存在返回None</span></span><br><span class="line">            j = item_idx_map.get(target - nums[i], <span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [i, j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                item_idx_map[nums[i]] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure></details><details><summary>c++</summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> j = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;j-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></details><details><summary>java</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限五：拓扑学基础之开集、闭集</title>
      <link href="/2020/10/16/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%905/"/>
      <url>/2020/10/16/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%905/</url>
      
        <content type="html"><![CDATA[<p>本章的内容为接下来的函数极限做铺垫。欧几里得空间<spanclass="math inline">\(\mathbb{R^n}\)</span>中关于点<spanclass="math inline">\(\boldsymbol{a}\)</span>的邻域两个常用到的概念为<br /><span class="math display">\[    \begin{aligned}        &amp; B_r(\boldsymbol{a}) = \{ \boldsymbol{x} \in \mathbb{R^n} :\Vert \boldsymbol{x} - \boldsymbol{a} \Vert &lt; r \} \\        &amp; B_r(\boldsymbol{\check a}) = \{ \boldsymbol{x} \in\mathbb{R^n} : 0 &lt; \Vert \boldsymbol{x} - \boldsymbol{a} \Vert &lt; r\}    \end{aligned}\]</span><br />其中<span class="math inline">\(B_r(\boldsymbol{a})\)</span>称为以<spanclass="math inline">\(\boldsymbol{a}\)</span>为球心，<spanclass="math inline">\(r&gt;0\)</span>为半径的球，而<spanclass="math inline">\(B_r(\boldsymbol{\checka})\)</span>称为相应的空心球。</p><span id="more"></span><h4 id="定义1开集">定义1：开集</h4><blockquote><p>（1）设<span class="math inline">\(E \in\mathbb{R^n}\)</span>，如果点<span class="math inline">\(\boldsymbol{a}\in E\)</span>，并且存在<spanclass="math inline">\(r&gt;0\)</span>，使得<spanclass="math inline">\(B_r(\boldsymbol{a}) \subsetE\)</span>，那么称<spanclass="math inline">\(\boldsymbol{a}\)</span>为<spanclass="math inline">\(E\)</span>的一个内点；<br />（2）<span class="math inline">\(E\)</span>的全体内点构成的集合记作<spanclass="math inline">\(E°\)</span>，称为<spanclass="math inline">\(E\)</span>的内部<br />（3）若<span class="math inline">\(E°=E\)</span>，则称<spanclass="math inline">\(E\)</span>为开集。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>对任何集<span class="math inline">\(E\)</span>，<spanclass="math inline">\(E\)</span>的内部<spanclass="math inline">\(E°\)</span>是开集。</p></blockquote><p>证：若<span class="math inline">\(E°=\varnothing\)</span>，可知<spanclass="math inline">\(E°=(E°)°=\varnothing\)</span>，可知<spanclass="math inline">\(E°\)</span>是开集；若<spanclass="math inline">\(E° \ne \varnothing\)</span>，任取<spanclass="math inline">\(\boldsymbol{c} \in E°\)</span>，可知存在<spanclass="math inline">\(r&gt;0\)</span>，使得<spanclass="math inline">\(B_r(\boldsymbol{c}) \subsetE\)</span>；从而任取<span class="math inline">\(\boldsymbol{a} \inB_r(\boldsymbol{c})\)</span>，令<span class="math inline">\(d=r - \Vert\boldsymbol{a} - \boldsymbol{c} \Vert\)</span>，对于<spanclass="math inline">\(\boldsymbol{x} \inB_d(\boldsymbol{a})\)</span>，有<br /><span class="math display">\[    \Vert \boldsymbol{x} - \boldsymbol{c} \Vert \le \Vert \boldsymbol{x}- \boldsymbol{a} \Vert + \Vert \boldsymbol{a} - \boldsymbol{c} \Vert \led + \Vert \boldsymbol{a} - \boldsymbol{c} \Vert = r\]</span><br />从而有<span class="math inline">\(\boldsymbol{x} \inB_r(\boldsymbol{c})\)</span>，可得<spanclass="math inline">\(B_d(\boldsymbol{a}) \subset B_r(\boldsymbol{c})\subset E\)</span>，从而<span class="math inline">\(\boldsymbol{a} \inE°\)</span>，由于<span class="math inline">\(\boldsymbol{a} \inB_r(\boldsymbol{c})\)</span>，所以<spanclass="math inline">\(B_r(\boldsymbol{c}) \subset E°\)</span>，所以<spanclass="math inline">\(E°\)</span>是开集。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>在空间<span class="math inline">\(\mathbb{R^n}\)</span>中：<br />（1）<spanclass="math inline">\(\mathbb{R^n},\varnothing\)</span>是开集；<br />（2）设<span class="math inline">\(\{E_\alpha\}\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>的一个开子集族，其中指标<spanclass="math inline">\(\alpha\)</span>来自一个指标集<spanclass="math inline">\(I\)</span>，那么并集<spanclass="math inline">\(\bigcup \limits_{\alpha \inI}E_\alpha\)</span>是开集（任意多个开集的并是开集）<br />（3）设<spanclass="math inline">\(E_1,E_2,\cdots,E_m\)</span>是有限多个开集，那么交集<spanclass="math inline">\(\bigcap\limits_{i=1}^mE_i\)</span>是开集（有限个开集的交是开集）。</p></blockquote><p>证：（1）显然，下面证（2）（3）<br />（2）任取<span class="math inline">\(\boldsymbol{a} \in \bigcup\limits_{\alpha \in I} E_\alpha\)</span>，存在<spanclass="math inline">\(\beta \in I\)</span>，使得<spanclass="math inline">\(\boldsymbol{a} \in E_\beta\)</span>，由于<spanclass="math inline">\(E_\beta\)</span>是开集，从而存在球<spanclass="math inline">\(B_r(\boldsymbol{a}) \subset E_\beta \subset\bigcup \limits_{\alpha \in I} E_\alpha\)</span>，从而<spanclass="math inline">\(\boldsymbol{a}\)</span>是<spanclass="math inline">\(\bigcup \limits_{\alpha \in I}E_\alpha\)</span>的内点，所以<span class="math inline">\(\bigcup\limits_{\alpha \in I} E_\alpha\)</span>是开集。<br />（3）任取<span class="math inline">\(\boldsymbol{a} \in \bigcap\limits_{i=1}^mE_i\)</span>，即<spanclass="math inline">\(\boldsymbol{a} \in E_i(i=1,2,\cdots,m)\)</span>，则存在<spanclass="math inline">\(r_i&gt;0\)</span>，使得<br /><span class="math display">\[    B_{r_i}(\boldsymbol{a}) \in E_i (i=1,2,\cdots,m)\]</span><br />令<span class="math inline">\(r =\min(r_1,r_2,\cdots,r_m)\)</span>，可得<br /><span class="math display">\[    B_r(\boldsymbol{a}) \subset \bigcap \limits_{i=1}^mE_i\]</span><br />所以<span class="math inline">\(\boldsymbol{a}\)</span>是<spanclass="math inline">\(\bigcap\limits_{i=1}^mE_i\)</span>的内点，从而<spanclass="math inline">\(\bigcap \limits_{i=1}^mE_i\)</span>是开集。</p><p>Q.E.D.</p><h4 id="定义2闭集">定义2：闭集</h4><blockquote><p>设<span class="math inline">\(F \subset\mathbb{R^n}\)</span>，若<spanclass="math inline">\(F^c\)</span>是开集，则称<spanclass="math inline">\(F\)</span>是闭集。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>在空间<span class="math inline">\(\mathbb{R^n}\)</span>中：<br />（1）<spanclass="math inline">\(\mathbb{R^n},\varnothing\)</span>是闭集；<br />（2）设<span class="math inline">\(\{F_\alpha\}\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>的一个闭子集族，其中指标<spanclass="math inline">\(\alpha\)</span>来自一个指标集<spanclass="math inline">\(I\)</span>，那么交集<spanclass="math inline">\(\bigcap \limits_{\alpha \inI}F_\alpha\)</span>是闭集（任意多个闭集的并是闭集）<br />（3）设<spanclass="math inline">\(F_1,F_2,\cdots,F_m\)</span>是有限多个开集，那么交集<spanclass="math inline">\(\bigcup \limits_{i=1}^mF_i\)</span>是闭集（有限个闭集的交是闭集）。</p></blockquote><p>利用De Morgan对偶原理与定理7的结论容易证明，从略。</p><h4 id="定义3凝聚点或极限点">定义3：凝聚点或极限点</h4><blockquote><p>设<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，若<span class="math inline">\(\boldsymbol{a} \in\mathbb{R^n}\)</span>，并满足对任意的<spanclass="math inline">\(r&gt;0\)</span>，在空心球<spanclass="math inline">\(B_r(\boldsymbol{\check a})\)</span>内总有<spanclass="math inline">\(E\)</span>中的点，则称<spanclass="math inline">\(\boldsymbol{a}\)</span>为<spanclass="math inline">\(E\)</span>的凝聚点或极限点。</p></blockquote><h4 id="定义4导集和闭包">定义4：导集和闭包</h4><blockquote><p>点集<span class="math inline">\(E \subset\mathbb{R^n}\)</span>的凝聚点的全体称为<spanclass="math inline">\(E\)</span>的导集，记作<spanclass="math inline">\(E^{\prime}\)</span>，记<spanclass="math inline">\(\bar E = E \cup E^{\prime}\)</span>，称<spanclass="math inline">\(\bar E\)</span>为<spanclass="math inline">\(E\)</span>的闭包</p></blockquote><h4 id="定理4"><span id="theorem4">定理4</span></h4><blockquote><p><span class="math inline">\(E\)</span>是闭集的充分必要条件是<spanclass="math inline">\(E^{\prime} \subset E\)</span>，即<spanclass="math inline">\(\bar E = E\)</span>。</p></blockquote><p>证：必要性。反证法，假设存在<spanclass="math inline">\(\boldsymbol{a} \in E^{\prime}\)</span>，而<spanclass="math inline">\(\boldsymbol{a} \notin E\)</span>，可知<spanclass="math inline">\(\boldsymbol{a} \in E^{c}\)</span>，又由于<spanclass="math inline">\(E\)</span>是闭集，从而<spanclass="math inline">\(E^{c}\)</span>是开集，从而存在<spanclass="math inline">\(B_r(\boldsymbol{a}) \subsetE^c\)</span>，这时<spanclass="math inline">\(B_r(\boldsymbol{a})\)</span>中没有$E<br /><span class="math inline">\(中的点，结合\)</span> E<spanclass="math inline">\(，可知\)</span>B_r()<spanclass="math inline">\(中没有\)</span>E<spanclass="math inline">\(中的点，而这与\)</span><spanclass="math inline">\(是\)</span>E<spanclass="math inline">\(的凝聚点矛盾，从而得证。 充分性。任取\)</span>E^{c}<span class="math inline">\(，可知\)</span> E^{}<spanclass="math inline">\(，从而存在空心球\)</span>B_r() E^{c}<spanclass="math inline">\(，结合\)</span> E^c<spanclass="math inline">\(，可知\)</span>B_r() E<sup>c<spanclass="math inline">\(，所以\)</span>E</sup>c<spanclass="math inline">\(是开集，从而\)</span>E$是闭集。</p><p>Q.E.D.</p><h4 id="定理5"><span id="theorem5">定理5</span></h4><blockquote><p><span class="math inline">\(E\)</span>是闭集的充分必要条件是，<spanclass="math inline">\(E\)</span>中的任意收敛点列的极限必在<spanclass="math inline">\(E\)</span>中。</p></blockquote><p>证：必要性。设<span class="math inline">\(E\)</span>中的收敛点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>有极限<spanclass="math inline">\(\boldsymbol{a}\)</span>，则<spanclass="math inline">\(\boldsymbol{a} \in E\)</span>或<spanclass="math inline">\(\boldsymbol{a} \notin E\)</span>，如果<spanclass="math inline">\(\boldsymbol{a} \notinE\)</span>，由极限性质可知<span class="math inline">\(\boldsymbol{a} \inE^{\prime}\)</span>，又根据<a href="#theorem4">定理4</a>，可得<spanclass="math inline">\(\boldsymbol{a} \in E\)</span>，所以<spanclass="math inline">\(\boldsymbol{a}\)</span>必在<spanclass="math inline">\(E\)</span>中。<br />充分性。任取<span class="math inline">\(\boldsymbol{a} \inE^{\prime}\)</span>，可从<spanclass="math inline">\(E\)</span>中选出点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>，而<spanclass="math inline">\(\boldsymbol{a} \in E\)</span>，所以<spanclass="math inline">\(E^{\prime} \subset E\)</span>，从而<spanclass="math inline">\(E\)</span>是闭集。</p><p>Q.E.D.</p><h4 id="定理6">定理6</h4><blockquote><p><span class="math inline">\(E\)</span>的导集<spanclass="math inline">\(E^{\prime}\)</span>与<spanclass="math inline">\(\bar E\)</span>都是闭集。</p></blockquote><p>证：前一命题。任取<span class="math inline">\(\boldsymbol{a} \in(E^{\prime})^c\)</span>，可知<spanclass="math inline">\(\boldsymbol{a}\)</span>不是<spanclass="math inline">\(E\)</span>的极限点，则存在一个球<spanclass="math inline">\(B_r(\boldsymbol{a})\)</span>，其中至多只有<spanclass="math inline">\(E\)</span>中的一个点，且该点若存在只能是<spanclass="math inline">\(\boldsymbol{a}\)</span>，由因为<spanclass="math inline">\(B_r(\boldsymbol{a})\)</span>是开集，从而任取<spanclass="math inline">\(\boldsymbol{c} \inB_r(\boldsymbol{a})\)</span>，若<spanclass="math inline">\(\boldsymbol{c} =\boldsymbol{a}\)</span>，自然有<spanclass="math inline">\(\boldsymbol{c} \in(E^{\prime})^c\)</span>，若<span class="math inline">\(\boldsymbol{c}\ne \boldsymbol{a}\)</span>，则存在球<spanclass="math inline">\(B_s(\boldsymbol{c}) \subsetB_r(\boldsymbol{a})\)</span>，且<spanclass="math inline">\(B_s(\boldsymbol{c})\)</span>不包含<spanclass="math inline">\(E\)</span>中的点，可知此时<spanclass="math inline">\(\boldsymbol{c}\)</span>也不可能是<spanclass="math inline">\(E\)</span>的极限点；即<spanclass="math inline">\(B_r(\boldsymbol{a}) \subset(E^{\prime})^c\)</span>，所以<spanclass="math inline">\(E^{\prime}\)</span>是闭集。<br />后一命题。若<spanclass="math inline">\(E^{\prime}=\varnothing\)</span>，可知<spanclass="math inline">\(\bar{E} = E\)</span>，可知<spanclass="math inline">\(E\)</span>是闭集，从而<spanclass="math inline">\(\bar{E}\)</span>是闭集；若<spanclass="math inline">\(E^{\prime} \ne \varnothing\)</span>，则任取<spanclass="math inline">\(\bar{E}\)</span>中的一个收敛点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>有极限<spanclass="math inline">\(\boldsymbol{a}\)</span>，如果<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>中只有有限个点，显然有<spanclass="math inline">\(\boldsymbol{a} \in\bar{E}\)</span>中，否则其中必有一个子列的点全属于<spanclass="math inline">\(E\)</span>或者<spanclass="math inline">\(E^{\prime}\)</span>，若全属于<spanclass="math inline">\(E\)</span>，则有<spanclass="math inline">\(\boldsymbol{a} \in E^{\prime} \subset\bar{E}\)</span>，若全属于<spanclass="math inline">\(E^{\prime}\)</span>，由于前面已证得<spanclass="math inline">\(E^{\prime}\)</span>是闭集，从而<spanclass="math inline">\(\boldsymbol{a} \in E^{\prime} \subset\bar{E}\)</span>，所以<spanclass="math inline">\(\bar{E}\)</span>是闭集。</p><p>Q.E.D.</p><h4 id="定理7">定理7</h4><blockquote><p><span class="math inline">\(E°\)</span>是含于<spanclass="math inline">\(E\)</span>内的最大开集，<spanclass="math inline">\(\bar E\)</span>是包含<spanclass="math inline">\(E\)</span>的最小闭集。</p></blockquote><p>证：前一命题。设开集<span class="math inline">\(B \subsetE\)</span>，任取<span class="math inline">\(\boldsymbol{a} \in B \subsetE\)</span>，可知存在球<span class="math inline">\(B_r(\boldsymbol{a})\subset B \subset E\)</span>，可知<spanclass="math inline">\(\boldsymbol{a} \in E°\)</span>，所以<spanclass="math inline">\(B \subset E°\)</span>。<br />后一命题。设闭集<span class="math inline">\(F \supsetE\)</span>，任取<span class="math inline">\(\boldsymbol{b} \in \bar E =E^{\prime} \cup E\)</span>，若<span class="math inline">\(\boldsymbol{b}\in E\)</span>，则<span class="math inline">\(\boldsymbol{b} \inF\)</span>；若<span class="math inline">\(\boldsymbol{b} \inE^{\prime}\)</span>，则<spanclass="math inline">\(E\)</span>中有一个点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于<spanclass="math inline">\(\boldsymbol{b}\)</span>，而这个点列也可以看出是<spanclass="math inline">\(F\)</span>中的，再由<ahref="#theorem5">定理5</a>可知，<spanclass="math inline">\(\boldsymbol{b} \in F\)</span>，所以<spanclass="math inline">\(\bar E \subset F\)</span>。</p><p>Q.E.D.</p><h4 id="定义5边界">定义5：边界</h4><blockquote><p>（1）设点集<span class="math inline">\(E\subset\mathbb{R^n}\)</span>，<spanclass="math inline">\((E^c)^°\)</span>中的点称为<spanclass="math inline">\(E\)</span>的外点，外点的全体称为<spanclass="math inline">\(E\)</span>的外部；<br />（2）既不是<span class="math inline">\(E\)</span>的内点又不是<spanclass="math inline">\(E\)</span>的外点的点称为<spanclass="math inline">\(E\)</span>的边界点，边界点的全体称为<spanclass="math inline">\(E\)</span>的边界。</p></blockquote><h4 id="定义6直径">定义6：直径</h4><blockquote><p>设非空点集<span class="math inline">\(E \subset\mathbb{R^n}\)</span>，记<br /><span class="math display">\[    diam(E) = \sup \{ \Vert \boldsymbol{x} - \boldsymbol{y} \Vert:\boldsymbol{x}, \boldsymbol{y} \in E \}\]</span><br />称该数为集合<span class="math inline">\(E\)</span>的直径。</p></blockquote><h4 id="定理8闭区间套定理">定理8：闭区间套定理</h4><blockquote><p>设<span class="math inline">\(\{\boldsymbol{F}_i\}(\boldsymbol{F}_i\ne \varnothing, i=1,2,3,\cdots)\)</span>是一闭集列，并且<spanclass="math inline">\(\boldsymbol{F}_1 \supset \boldsymbol{F}_2 \supset\boldsymbol{F}_3 \supset \cdots\)</span>，若<br /><span class="math display">\[    \lim \limits_{i \to \infty} diam(\boldsymbol{F}_i) = 0\]</span><br />那么<span class="math inline">\(\bigcap \limits_{i=1}^\infty\boldsymbol{F}_i\)</span>只含唯一的点。</p></blockquote><p>证：因为<spanclass="math inline">\(\boldsymbol{F}_i\)</span>不是空集，因此对每个<spanclass="math inline">\(i \in \mathbb{N}^{*}\)</span>，都存在<spanclass="math inline">\(\boldsymbol{x}_i \in\boldsymbol{F}_i\)</span>，又由闭区间套的性质可知<br /><span class="math display">\[    \{\boldsymbol{x}_i, \boldsymbol{x}_{i+1}, \boldsymbol{x}_{i+2},\cdots\} \in \boldsymbol{F}_i \quad (i \in \mathbb{N}^{*})\]</span><br />所以当<span class="math inline">\(k,l &gt; i\)</span>时，<br /><span class="math display">\[    \Vert \boldsymbol{x}_k - \boldsymbol{x}_l \Vert \lediam(\boldsymbol{F}_i) \to 0 \quad (i \to \infty)\]</span><br />可知<span class="math inline">\(\{ \boldsymbol{x}_i\}\)</span>时基本点列，不妨设其收敛于点<spanclass="math inline">\(\boldsymbol{a}\)</span>，又由闭集的性质<ahref="#theorem5">定理5</a>可知，<spanclass="math inline">\(\boldsymbol{a} \in\boldsymbol{F}_i\)</span>对所有<span class="math inline">\(i \in\mathbb{N}^{*}\)</span>成立，因此<spanclass="math inline">\(\boldsymbol{a} \in \bigcap \limits_{i=1}^\infty\boldsymbol{F}_i\)</span>。<br />假设还有点<span class="math inline">\(\boldsymbol{b} \in \bigcap\limits_{i=1}^\infty \boldsymbol{F}_i\)</span>，从而<spanclass="math inline">\(\boldsymbol{a},\boldsymbol{b} \in\boldsymbol{F}_i\)</span>，可知<br /><span class="math display">\[    \Vert \boldsymbol{a} - \boldsymbol{b} \Vert \lediam(\boldsymbol{F_i}) = 0 \quad (i \to \infty)\]</span><br />可知<span class="math inline">\(\boldsymbol{a} =\boldsymbol{b}\)</span>。所以<spanclass="math inline">\(\boldsymbol{a}\)</span>唯一。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 点列极限 </tag>
            
            <tag> 拓扑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限四：欧式空间中的点列极限</title>
      <link href="/2020/10/09/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%904/"/>
      <url>/2020/10/09/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%904/</url>
      
        <content type="html"><![CDATA[<p>本篇主要讲多维空间中点列的极限，下面的讨论都会基于<spanclass="math inline">\(n\)</span>维欧式空间，通常用<spanclass="math inline">\(\mathbb{R^n}\)</span>表示；以下内容的前提是已知<spanclass="math inline">\(n\)</span>维Euclid空间以及各种名词的概念，比如向量，范数，内积等等，如有不理解的概念，建议查看高等代数中关于<strong>度量空间</strong>的内容。</p><span id="more"></span><h4 id="定义1点列收敛">定义1：点列收敛</h4><blockquote><p>设<span class="math inline">\(\boldsymbol{x}_i \in\mathbb{R^n}(i=1,2,\cdots)，称\{\boldsymbol{x}_i\}是\mathbb{R^n}\)</span>中的一个点列。<spanclass="math inline">\(\boldsymbol{a} \in\mathbb{R^n}\)</span>，如果对任意给定的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(N \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(i &gt; N\)</span>时，有<br /><span class="math display">\[    \Vert \boldsymbol{x}_i - \boldsymbol{a} \Vert &lt; \varepsilon\]</span><br />称点<span class="math inline">\(\boldsymbol{a}\)</span>是点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>的极限，记作<br /><span class="math display">\[    \lim \limits_{i\to\infty} \boldsymbol{x}_i = \boldsymbol{a} \quad 或\quad \boldsymbol{x}_i \to \boldsymbol{a}(i \to \infty)\]</span><br />也称点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于点<spanclass="math inline">\(\boldsymbol{a}\)</span>。</p></blockquote><h4 id="定理1">定理1</h4><blockquote><p>（1）如果点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛，那么它的极限必是唯一的；<br />（2）收敛点列必定是有界的。</p></blockquote><p>证明与数列极限的证明几乎一样，从略</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\lim \limits_{i \to\infty}\boldsymbol{x}_i = \boldsymbol{a}，\lim \limits_{i \to\infty}\boldsymbol{y}_i = \boldsymbol{b}\)</span>，那么<br />（1）<span class="math inline">\(\lim \limits_{i \to\infty}(\boldsymbol{x}_i \pm \boldsymbol{y}_i) = \boldsymbol{a} \pm\boldsymbol{b}\)</span><br />（2）对任意<span class="math inline">\(\lambda \in\mathbb{R}\)</span>，有<br /><span class="math display">\[    \lim \limits_{i \to \infty}(\lambda \boldsymbol{x}_i) = \lambda\boldsymbol{a}\]</span></p></blockquote><p>证明与数列极限的证明几乎一样，从略</p><h4 id="定义2">定义2</h4><blockquote><p>设<span class="math inline">\(\{\boldsymbol{x}_i\}\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>中的一个点列，并设<br /><span class="math display">\[    \boldsymbol{x}_i = (x_1^{(i)},x_2^{(i)},\cdots,x_n^{(i)}) \quad(i=1,2,\cdots)\]</span><br />如果对<span class="math inline">\(k=1,2,\cdots,n\)</span>，有<br /><span class="math display">\[    \lim \limits_{i \to \infty} x_k^{(i)} = a_k\]</span><br />则称点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{a}=(a_1,a_2,\cdots,a_n)\)</span>。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p><span class="math inline">\(\lim \limits_{i \to \infty}\boldsymbol{x}_i = \boldsymbol{a}\)</span>等价于点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>。</p></blockquote><p>证：（a）先证<span class="math inline">\(\boldsymbol{a} =\boldsymbol{0}\)</span>的情形，易知不等式<br /><span class="math display">\[    |x_k^{(i)}| \le \Vert \boldsymbol{x}_i \Vert \le |x_1^{(i)}| +|x_2^{(i)}| + \cdots + |x_n^{(i)}| \quad (k=1,2,\cdots,n)\]</span><br />对所有的<span class="math inline">\(i \in\mathbb{N^+}\)</span>都成立；所以当<span class="math inline">\(\lim\limits_{i \to \infty} \boldsymbol{x}_i =\boldsymbol{0}\)</span>，有<span class="math inline">\(\lim \limits_{i\to \infty} x_k^{(i)}=0 (k=1,2,\cdots,n)\)</span>，即<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{0}\)</span>。反之，若<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{0}\)</span>，则有<br /><span class="math display">\[    \lim \limits_{i \to \infty} |x_1^{(i)}| + |x_2^{(i)}| + \cdots +|x_n^{(i)}| = 0\]</span><br />由此可知<span class="math inline">\(\lim \limits_{i \to \infty} \Vert\boldsymbol{x}_i \Vert = 0\)</span>，即<span class="math inline">\(\lim\limits_{i \to \infty} \boldsymbol{x}_i =\boldsymbol{0}\)</span>。<br />（b）若<span class="math inline">\(\boldsymbol{a} \ne\boldsymbol{0}\)</span>，则考虑点列<spanclass="math inline">\(\{\boldsymbol{x}_i -\boldsymbol{a}\}\)</span>，再由（a）的结论就易证明 <spanclass="math inline">\(\lim \limits_{i \to \infty} \boldsymbol{x}_i =\boldsymbol{a}\)</span>等价于点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>。</p><p>Q.E.D.</p><h4 id="定义3基本点列">定义3：基本点列</h4><blockquote><p>设<span class="math inline">\(\{\boldsymbol{x}_i\}\)</span>是<spanclass="math inline">\(\mathbb{R^n}\)</span>中的一个点列，如果对任意的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(N \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(k,l&gt;N\)</span>时，有<spanclass="math inline">\(\Vert \boldsymbol{x}_k - \boldsymbol{x}_l \Vert&lt; \varepsilon\)</span>，则称<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>是一个基本（点）列。</p></blockquote><h4 id="定理4基本点列收敛">定理4：基本点列收敛</h4><blockquote><p><spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>是收敛点列的充分必要条件是<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>是基本点列。</p></blockquote><p>证：必要性。设<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>，可知对任意给定的<spanclass="math inline">\(\varepsilon &gt; 0\)</span>，存在<spanclass="math inline">\(N \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(i &gt; N\)</span>时，有<spanclass="math inline">\(\Vert \boldsymbol{x}_i - \boldsymbol{a}\Vert &lt;\frac{\varepsilon}{2}\)</span>，因此当<spanclass="math inline">\(k,l&gt;N\)</span>时，有<br /><span class="math display">\[    \Vert \boldsymbol{x}_k - \boldsymbol{a} \Vert &lt;\frac{\varepsilon}{2}, \quad \Vert \boldsymbol{x}_l - \boldsymbol{a}\Vert &lt; \frac{\varepsilon}{2}\]</span><br />从而有<br /><span class="math display">\[    \Vert \boldsymbol{x}_k - \boldsymbol{x}_l \Vert \le \Vert\boldsymbol{x}_k - \boldsymbol{a} \Vert + \Vert \boldsymbol{a} -\boldsymbol{x}_l \Vert &lt; \varepsilon\]</span><br />即<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>是基本列；<br />充分性。设<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>是基本列，由不等式<br /><span class="math display">\[    |x_j^{(k)} - x_j^{(l)}| \le \Vert \boldsymbol{x}_k -\boldsymbol{x}_l \Vert \quad (j=1,2,\cdots,n)\]</span><br />可知<spanclass="math inline">\(\{x_j^{(k)}\}(j=1,2,\cdots,n)\)</span>是基本列，所以它们是收敛数列，令<br /><span class="math display">\[    \lim \limits_{i \to \infty} x_j^{(i)} = a_j \quad (j = 1,2,\cdots,n)\]</span><br />从而有点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>按分量收敛于<spanclass="math inline">\(\boldsymbol{a} =(a_1,a_2,\cdots,a_n)\)</span>，也即<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>收敛于<spanclass="math inline">\(\boldsymbol{a}\)</span>。</p><p>Q.E.D.</p><h4 id="定理5">定理5</h4><blockquote><p>(Bolzano-Weierstrass) 从任一有界的点列可以选出收敛的子点列。</p></blockquote><p>证：设点列<spanclass="math inline">\(\{\boldsymbol{x}_i\}\)</span>有界，由不等式<spanclass="math inline">\(|x_k^{(i)}| \le \Vert \boldsymbol{x}_i\Vert\)</span>，易知数列<spanclass="math inline">\(\{x_k^{(i)}\}(k=1,2,\cdots,n)\)</span>是有界的，从而根据数列的Bolzano-Weierstrass定理，存在<spanclass="math inline">\(\{i\}\)</span>的子列<spanclass="math inline">\(\{i^{(1)}\} \subset \{i\}\)</span>，使得，<br /><span class="math display">\[\lim \limits_{l \to \infty} x_{1}^{(i^{(1)})} = a_1\]</span><br />而<spanclass="math inline">\(\{x_2^{(i^{(1)})}\}\)</span>也是一个有界数列，从而存在<spanclass="math inline">\(\{i^{(1)}\}\)</span>的一个子列${i^{(2)}} {i^{(1)}}$，使得<br /><span class="math display">\[\lim \limits_{l \to \infty} x_{k}^{(i^{(2)})} = a_2\]</span><br />依此下去，找到一串子列满足<span class="math inline">\(\{i^{(n)}\}\subset \{i^{(n-1)}\} \subset \cdots \subset \{i^{(2)}\} \subset\{i^{(1)}\}\)</span>，且有<br /><span class="math display">\[    \lim \limits_{l \to \infty} x_{k}^{(i^{(k)})} = a_k \quad(k=1,2,\cdots,n)\]</span><br />根据收敛数列的任意子列收敛于同一值，可知<br /><span class="math display">\[    \lim \limits_{l \to \infty} x_{k}^{(i^{(n)})} = a_k \quad(k=1,2,\cdots,n)\]</span><br />从而找到了<span class="math inline">\(\{i\}\)</span>的一个子列<spanclass="math inline">\(\{i^{(n)}\}\)</span>，使得<spanclass="math inline">\(\{\boldsymbol{x}_{i^{n)}}\}\)</span>按分量收敛于<spanclass="math inline">\((a_1,a_2,\cdots,a_n)\)</span>，即选出了一个收敛子点列。</p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 点列极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限三：数列极限的上极限与下极限，Stolz定理</title>
      <link href="/2020/09/28/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%903/"/>
      <url>/2020/09/28/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%903/</url>
      
        <content type="html"><![CDATA[<p>对于任意给定的数列<spanclass="math inline">\(\{a_n\}\)</span>，如果<spanclass="math inline">\(\{a_n\}\)</span>有界，由列紧性可知，必然存在收敛子列，如果<spanclass="math inline">\(\{a_n\}\)</span>无解，则总可以找到一个子列趋向于<spanclass="math inline">\(-\infty\)</span>或<spanclass="math inline">\(+\infty\)</span>。我们把数列<spanclass="math inline">\(\{a_n\}\)</span>的收敛子列的极限称为<spanclass="math inline">\(\{a_n\}\)</span>的一个极限点，若还有趋于<spanclass="math inline">\(-\infty\)</span>或<spanclass="math inline">\(+\infty\)</span>的子列，也将<spanclass="math inline">\(-\infty\)</span>或<spanclass="math inline">\(+\infty\)</span>称为<spanclass="math inline">\(\{a_n\}\)</span>的一个极限点。</p><span id="more"></span><h4id="定义1上极限与下极限"><span id="define1">定义1：上极限与下极限<span></h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>是一个数列，<spanclass="math inline">\(E\)</span>是由<spanclass="math inline">\(\{a_n\}\)</span>的全部极限点构成的集合，记<br /><span class="math display">\[    a^* = \sup E, \quad a_*=\inf E\]</span><br />则<span class="math inline">\(a^{*}\)</span>和<spanclass="math inline">\(a_{*}\)</span>分别称为数列<spanclass="math inline">\(\{a_n\}\)</span>的<strong>上极限</strong>和<strong>下极限</strong>，记为<br /><span class="math display">\[    a^* = \limsup \limits_{n\to\infty} a_n, \quad a_* = \liminf\limits_{n\to\infty} a_n\]</span></p></blockquote><h4 id="定理1"><span id="theorem1">定理1<span></h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>是一个数列，<spanclass="math inline">\(E\)</span>与<spanclass="math inline">\(a^*\)</span>的含义与<ahref="#define1">定义1</a>中一样，那么<br />（1）<span class="math inline">\(a^* \in E\)</span>;<br />（2）若<span class="math inline">\(x&gt;a^*\)</span>，则存在<spanclass="math inline">\(N&gt;\mathbb{N^{*}}\)</span>，当<spanclass="math inline">\(n \ge N\)</span>时，有<spanclass="math inline">\(a_n &lt; x\)</span>;<br />（3）<spanclass="math inline">\(a^*\)</span>是满足前两条性质的唯一的数。即由（1）（2）也可以定理上极限。</p></blockquote><p>证：（1）若<span class="math inline">\(a^*=+\infty\)</span>，则<spanclass="math inline">\(E\)</span>无上界，可知<spanclass="math inline">\(\{a_n\}\)</span>也没有上界，所以必然可以从<spanclass="math inline">\(\{a_n\}\)</span>中选取一个趋于<spanclass="math inline">\(+\infty\)</span>的子列，即<spanclass="math inline">\(a^* \in E\)</span>，<br />如果<span class="math inline">\(a^*=-\infty\)</span>，则<spanclass="math inline">\(E={-\infty}\)</span>，显然由<spanclass="math inline">\(a^* \in E\)</span><br />如果<span class="math inline">\(a^*\)</span>是一个有限数，由于<spanclass="math inline">\(a^*=\sup E\)</span>，从而必存在<spanclass="math inline">\(l_1\in E\)</span>，使得<br /><span class="math display">\[    a^* - 1 &lt; l_1 &lt; a^* + 1\]</span><br />又由于<span class="math inline">\(l_1\)</span>是<spanclass="math inline">\(\{a_n\}\)</span>某个子列的极限，则一定存在正整数<spanclass="math inline">\(k_1\)</span>，使得<br /><span class="math display">\[    a^* - 1 &lt; a_{k_1} &lt; a^* + 1\]</span><br />同理，存在<span class="math inline">\(l_2 \in E\)</span>，使得<br /><span class="math display">\[    a^* - \frac{1}{2} &lt; l_2 &lt; a^* + \frac{1}{2}\]</span><br /><span class="math inline">\(l_2\)</span>是<spanclass="math inline">\(\{a_n\}\)</span>的某个子列的极限，则一定存在正整数<spanclass="math inline">\(k_2 &gt; k_1\)</span>，使得<br /><span class="math display">\[    a^* - \frac{1}{2} &lt; a_{k_2} &lt; a^* + \frac{1}{2}\]</span><br />归纳可得，对任何<span class="math inline">\(n \in\mathbb{N^+}\)</span>，存在<spanclass="math inline">\(k_n\)</span>，满足<spanclass="math inline">\(k_n&gt;k_{n-1}&gt;\cdots&gt;k_1\)</span>，使得<br /><span class="math display">\[    a^* - \frac{1}{n} &lt; a_{k_n} &lt; a^* + \frac{1}{n}\]</span><br />所以有<span class="math inline">\(\lim \limits_{n \to \infty}a_{k_n} =a^*\)</span>，即找到了<spanclass="math inline">\(\{a_n\}\)</span>的一个子列收敛于<spanclass="math inline">\(a^*\)</span>，所以<span class="math inline">\(a^*\in E\)</span>。<br />（2）反证法。假设存在无穷多个<spanclass="math inline">\(n\)</span>，满足<span class="math inline">\(a_n\ge x\)</span>，则存在一个<span class="math inline">\(y \inE\)</span>，使得<span class="math inline">\(y \ge x &gt;a^*\)</span>，这与<span class="math inline">\(a^*\)</span>是<spanclass="math inline">\(E\)</span>的上确界矛盾。<br />（3）反证法。假设存在两个不同的数<spanclass="math inline">\(p，q\)</span>同时满足（1）（2），不妨设<spanclass="math inline">\(p&lt;q\)</span>，取<spanclass="math inline">\(x\)</span>，使得<spanclass="math inline">\(p&lt;x&lt;q\)</span>，由（2）可知，存在<spanclass="math inline">\(N \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n \ge N\)</span>时，有<spanclass="math inline">\(a_n &lt; x\)</span>，易知<spanclass="math inline">\(E\)</span>中的点不可能超过<spanclass="math inline">\(x\)</span>，这是<spanclass="math inline">\(q\)</span>不能满足（1）。</p><p>Q.E.D.</p><h4 id="定理2">定理2</h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>是一个数列，<spanclass="math inline">\(E\)</span>与<spanclass="math inline">\(a_*\)</span>的含义与<ahref="#define1">定义1</a>中一样，那么<br />（1）<span class="math inline">\(a_* \in E\)</span>;<br />（2）若<span class="math inline">\(x &lt; a_*\)</span>，则存在<spanclass="math inline">\(N&gt;\mathbb{N^{*}}\)</span>，当<spanclass="math inline">\(n \ge N\)</span>时，有<spanclass="math inline">\(a_n &gt; x\)</span>;<br />（3）<spanclass="math inline">\(a_*\)</span>是满足前两条性质的唯一的数。即由（1）（2）也可以定理下极限。</p></blockquote><p>证法与<a href="#theorem1">定理1</a>的证明方法几乎一样（从略）。</p><h4 id="定理3">定理3</h4><blockquote><p>设<spanclass="math inline">\(\{a_n\},\{b_n\}\)</span>是两个数列，<br />（1）<span class="math inline">\(\liminf \limits_{n \to \infty}a_n \le\limsup \limits_{n \to \infty}a_n\)</span><br />（2）<span class="math inline">\(\lim \limits_{n \to \infty}a_n =a\)</span>当且仅当<span class="math inline">\(\liminf \limits_{n \to\infty}a_n = \limsup \limits_{n \to \infty}a_n = a\)</span><br />（3）若<span class="math inline">\(N\)</span>是某个正整数，当<spanclass="math inline">\(n&gt;N\)</span>时，有<spanclass="math inline">\(a_n \le b_n\)</span>，那么<br /><span class="math display">\[    \liminf \limits_{n \to \infty}a_n \le \liminf \limits_{n \to\infty}b_n，\quad \limsup \limits_{n \to \infty}a_n \le \limsup\limits_{n \to \infty}b_n\]</span></p></blockquote><p>证：（1）（2）显然，下面只证（3）的右边等式，左边等式可以相似的证明。记<br /><span class="math display">\[    \limsup \limits_{n \to \infty}a_n = a^*, \quad \limsup \limits_{n\to \infty}b_n = b^*\]</span><br />若<spanclass="math inline">\(b^*=+\infty\)</span>，不等式自然成立；当<spanclass="math inline">\(a^*=+\infty\)</span>，存在子列<spanclass="math inline">\(a_{k_n} \to +\infty (n \to\infty)\)</span>，这时也有<span class="math inline">\(b_{k_n} \to+\infty (n \to \infty)\)</span>，从而有<span class="math inline">\(b^* =+\infty\)</span>，不等式等号成立；同样若<spanclass="math inline">\(a^*\)</span>与<spanclass="math inline">\(b^*\)</span>中有一个为<spanclass="math inline">\(-\infty\)</span>时，结论也成立。现在设<spanclass="math inline">\(a^*\)</span>与<spanclass="math inline">\(b^*\)</span>都是有限数，采用反证法，假设<spanclass="math inline">\(b^* &lt; a^*\)</span>，取<spanclass="math inline">\(x\)</span>，使得<span class="math inline">\(b^*&lt; x &lt; a^*\)</span>，由<ahref="#theorem1">定理1</a>（2）可知，存在正整数<spanclass="math inline">\(N_1\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<spanclass="math inline">\(b_n &lt; x\)</span>，取<spanclass="math inline">\(n&gt;\max(N, N_1)\)</span>时，有<br /><span class="math display">\[    a_n \le b_n &lt; x &lt; a^*\]</span><br />这与<span class="math inline">\(a^*\)</span>的定义矛盾。</p><p>（3）也可以不采用反证法。由<spanclass="math inline">\(a^*\)</span>的性质可知，可从<spanclass="math inline">\(\{a_n\}\)</span>中取出一个子列<spanclass="math inline">\(\{a_{k_n}\}\)</span>，使得<spanclass="math inline">\(\lim \limits_{n \to \infty}a_{k_n} =a^*\)</span>，又当<span class="math inline">\(k_n \ge n &gt;N\)</span>，<span class="math inline">\(a_{k_n} \leb_{k_n}\)</span>，这时可以从<spanclass="math inline">\(b_{k_n}\)</span>中取出一个收敛子列<spanclass="math inline">\(\{b_{i_{k_{n}}}\}\)</span>，相应的<spanclass="math inline">\(\{a_{k_n}\}\)</span>的子列为<spanclass="math inline">\(\{a_{i_{k_{n}}}\}\)</span>，由<spanclass="math inline">\(\lim \limits_{n \to \infty}a_{k_n} =a^*\)</span>，可得<br /><span class="math display">\[    \lim \limits_{n \to \infty}a_{i_{k_n}} = a^*\]</span><br />又由<span class="math inline">\(a_{i_{k_{n}}} \leb_{i_{k_{n}}}\)</span>，可得<br /><span class="math display">\[    \lim \limits_{n \to \infty}b_{i_{k_n}} \ge a^*\]</span><br />而<span class="math inline">\(\{b_{i_{k_{n}}}\}\)</span>显然也是<spanclass="math inline">\(\{b_n\}\)</span>的子列，从而有<br /><span class="math display">\[    b^* \ge \lim \limits_{n \to \infty}b_{i_{k_n}} \ge a^*\]</span><br />Q.E.D.</p><h4 id="定理4">定理4</h4><blockquote><p>对数列<span class="math inline">\(\{a_n\}\)</span>，定义<spanclass="math inline">\(\alpha_n=\inf \limits_{k \ge n}a_k，\beta_n = \sup\limits_{k \ge n}a_k\)</span>，那么<br />（1）<span class="math inline">\(\{\alpha_n\}\)</span>是递增数列，<spanclass="math inline">\(\{\beta_n\}\)</span>是递减数列；<br />（2）<span class="math inline">\(\lim \limits_{n \to \infty} \alpha_n =a_*，\lim \limits_{n \to\infty} \beta_n =a^*\)</span>。</p></blockquote><p>证：（1）按定义，有<span class="math inline">\(\alpha_n =\inf\{a_n,a_{n+1},\cdots\}, \quad \alpha_{n+1}=\inf\{a_{n+1}, a_{n+2},\cdots\}\)</span>，显然有<span class="math inline">\(\alpha_n \le\alpha_{n+1}\)</span>，同理可得<span class="math inline">\(\beta_n \ge\beta_{n+1}\)</span>。<br />（2）这里只证明右边等式，左边等式的证明是类似的。<br />（a）先设<span class="math inline">\(a^*\)</span>是一个有限数，由<ahref="#theorem1">定理1</a>（1）可知<span class="math inline">\(a^* \inE\)</span>，所以存在<spanclass="math inline">\(\{a_n\}\)</span>的一个子列<spanclass="math inline">\(\{a_{k_n}\}\)</span>，使得<spanclass="math inline">\(\lim \limits_{n \to \infty}a_{k_n} =a^*\)</span>，而<span class="math inline">\(k_n \gen\)</span>，所以<span class="math inline">\(a_{k_n} \le\sup\{a_n,a_{n+1},\cdots\}=\beta_n\)</span>，从而有<br /><span class="math display">\[    \lim \limits_{n \to \infty}a_{k_n} \le \lim \limits_{n \to\infty}\beta_n \Rightarrow a^* \le \lim \limits_{n \to \infty}\beta_n\tag 1\]</span><br />对任意的<span class="math inline">\(\varepsilon&gt;0\)</span>，由<ahref="#theorem1">定理1</a>（2）可知，存在<span class="math inline">\(n_0\in N^*\)</span>，当<span class="math inline">\(n \gen_0\)</span>时，有<span class="math inline">\(a_n \le a^* +\varepsilon\)</span>，因此<span class="math inline">\(\sup \limits_{k\ge n_0}a_n \le a^* + \varepsilon\)</span>，即<spanclass="math inline">\(\beta_{n_0} \le a^* + \varepsilon\)</span><br />，又由于<spanclass="math inline">\(\{\beta_n\}\)</span>是递减的，所以当<spanclass="math inline">\(n&gt;n_0\)</span>时，<spanclass="math inline">\(\beta_n \le \beta_{n_0} \le a^* +\varepsilon\)</span>，再令<span class="math inline">\(\varepsilon \to0\)</span>，从而有<span class="math inline">\(\lim \limits_{n \to\infty}\beta_n \le a^* + \varepsilon\)</span>，得<br /><span class="math display">\[    \lim \limits_{n \to \infty}\beta_n \le a^* \tag 2\]</span><br />由（1）（2）可得<span class="math inline">\(\lim \limits_{n \to\infty}\beta_n = a^*\)</span><br />（b）设<span class="math inline">\(a^* =+\infty\)</span>，则有一子列趋于<spanclass="math inline">\(+\infty\)</span>，从而有<br /><span class="math display">\[    \beta_n = \sup\{a_n, a_{n+1},\cdots\} = +\infty\]</span><br />从而有<span class="math inline">\(\lim \limits_{n \to \infty}\beta_n =+\infty\)</span>。</p><p>Q.E.D.</p><h4 id="定理5stolz定理">定理5：Stolz定理</h4><blockquote><p>设<span class="math inline">\(\{b_n\}\)</span>是严格递增且趋于<spanclass="math inline">\(+\infty\)</span>的数列，如果<br /><span class="math display">\[    \lim \limits_{n \to \infty}\frac{a_n - a_{n-1}}{b_n - b_{n-1}}=A\]</span><br />那么<br /><span class="math display">\[    \lim \limits_{n \to \infty}\frac{a_n}{b_n} = A\]</span><br />其中<span class="math inline">\(A\)</span>可以是<spanclass="math inline">\(+\infty,-\infty\)</span>或有限数。</p></blockquote><p>证：（a）先设<spanclass="math inline">\(A\)</span>是有限数，由极限定义可知，对任意<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(n_0 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n \ge n_0\)</span>时，有<br /><span class="math display">\[    A-\varepsilon &lt; \frac{a_n-a_{n-1}}{b_n-b_{n-1}} &lt;A+\varepsilon\]</span><br />从而有<br /><span class="math display">\[    \begin{aligned}    A-\varepsilon &amp; &lt; \frac{a_{n_0}-a_{n_0-1}}{b_{n_0}-b_{n_0-1}}&lt; A+\varepsilon \Rightarrow (A-\varepsilon)(b_{n_0}-b_{n_0-1}) &lt;a_{n_0} - a_{n_0-1} &lt; (A+\varepsilon)(b_{n_0}-b_{n_0}-1) \\    A-\varepsilon &amp; &lt; \frac{a_{n_0+1}-a_{n_0}}{b_{n_0+1}-b_{n_0}}&lt; A+\varepsilon \Rightarrow (A-\varepsilon)(b_{n_0+1}-b_{n_0}) &lt;a_{n_0+1} - a_{n_0} &lt; (A+\varepsilon)(b_{n_0+1}-b_{n_0}) \\    &amp; \cdots \\    A-\varepsilon &amp;&lt; \frac{a_{n}-a_{n-1}}{b_{n}-b_{n-1}} &lt;A+\varepsilon \Rightarrow (A-\varepsilon)(b_{n}-b_{n-1}) &lt; a_{n} -a_{n-1} &lt; (A+\varepsilon)(b_{n}-b_{n-1})    \end{aligned}\]</span><br />得<br /><span class="math display">\[    (A-\varepsilon)(b_n - b_{n_0-1}) &lt; a_n - a_{n_0-1} &lt;(A+\varepsilon)(b_n - b_{n_0-1}) \Rightarrow A-\varepsilon &lt;\frac{a_n - a_{n_0-1}}{b_n - b_{n_0-1}} &lt; A+\varepsilon\]</span><br />即<br /><span class="math display">\[    A-\varepsilon &lt; \frac{\frac{a_n}{b_n} -\frac{a_{n_0-1}}{b_n}}{1-\frac{b_{n_0-1}}{b_n}} &lt; A+\varepsilon\]</span><br />于是得<br /><span class="math display">\[    (A-\varepsilon)(1-\frac{b_{n_0-1}}{b_n}) + \frac{a_{n_0-1}}{b_n}&lt; \frac{a_n}{b_n} &lt; (A+\varepsilon)(1-\frac{b_{n_0-1}}{b_n}) +\frac{a_{n_0-1}}{b_n}\]</span><br />从而得<br /><span class="math display">\[    A - \varepsilon \le \liminf \limits_{n\to\infty} \frac{a_n}{b_n} \le\limsup \limits_{n\to\infty} \frac{a_n}{b_n} \le A + \varepsilon\]</span><br />此时令<span class="math inline">\(\varepsilon \to 0\)</span>，即得<br /><span class="math display">\[    \liminf \limits_{n\to\infty} \frac{a_n}{b_n} = \limsup\limits_{n\to\infty} \frac{a_n}{b_n} = A\]</span><br />所以<br /><span class="math display">\[    \lim \limits_{n\to\infty} \frac{a_n}{b_n} = A\]</span><br />（b）设<span class="math inline">\(A=+\infty\)</span>，当<spanclass="math inline">\(n\)</span>充分大时，<spanclass="math inline">\(a_n - a_{n-1} &gt; b_n - b_{n-1} &gt;0\)</span>，所以<spanclass="math inline">\(\{a_n\}\)</span>从某项开始也是严格递增且趋于<spanclass="math inline">\(+\infty\)</span>，从而有<br /><span class="math display">\[    \lim \limits_{n \to \infty}\frac{b_n - b_{n-1}}{a_n - a_{n-1}}=0\]</span><br />由（a）可知，<span class="math inline">\(\lim \limits_{n\to\infty}\frac{b_n}{a_n} = 0\)</span>，从而有<span class="math inline">\(\lim\limits_{n\to\infty} \frac{a_n}{b_n} = +\infty\)</span>；</p><p>（c）设<span class="math inline">\(A=-\infty\)</span>，设<spanclass="math inline">\(c_n = -a_n\)</span>，可知<br /><span class="math display">\[    \lim \limits_{n \to \infty}\frac{c_n - c_{n-1}}{b_n - b_{n-1}} = -\lim \limits_{n \to \infty}\frac{a_n - a_{n-1}}{b_n - b_{n-1}}=+\infty\]</span><br />由（b）可知，有<span class="math inline">\(\lim \limits_{n\to\infty}\frac{c_n}{b_n} = +\infty\)</span>，从而有<spanclass="math inline">\(\lim \limits_{n\to\infty} \frac{a_n}{b_n} =-\infty\)</span></p><p>Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 上极限与下极限 </tag>
            
            <tag> 点列极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限二：实数连续性</title>
      <link href="/2020/09/24/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%902/"/>
      <url>/2020/09/24/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%902/</url>
      
        <content type="html"><![CDATA[<h4 id="前言">前言</h4><p>在点列极限一的定理7证明了单调有界的数列必收敛，此命题是实数连续性的表现之一，本篇将会说明实数连续性的6个等价命题，即这6个命题可以互相推出，而<code>单调有界的数列必收敛</code>命题前面已经证明，所以只需要在这6个命题中做循环论证即可。本篇将会首先列出这6个命题的描述，然后证明其相互等价。</p><span id="more"></span><h4 id="定理1单调且有界的数列一定收敛"><spanid="theorem1">定理1：单调且有界的数列一定收敛。</span></h4><h4 id="定理2闭区间套定理"><spanid="theorem2">定理2：闭区间套定理</span></h4><blockquote><p>设<span class="math inline">\(I_n=[a_n,b_n] (n \in\mathbb{N^+})\)</span>，并且有<span class="math inline">\(I_1 \supsetI_2 \supset I_3 \supset \cdots \supset I_n \supset I_{n+1}\supset\cdots\)</span>，如果这一列区间的长度<spanclass="math inline">\(|I_n|=b_n-a_n \to 0(n \to\infty)\)</span>，那么交集<span class="math inline">\(\bigcap\limits_{n=1}^NI_n\)</span>含有唯一的点。</p></blockquote><h4 id="定理3bolzano-weierstrass列紧性定理"><spanid="theorem3">定理3：（Bolzano-Weierstrass）列紧性定理</span></h4><blockquote><p>从任何有界数列中必可以选出一个收敛的子列。</p></blockquote><h4 id="定义1基本列"><span id="define1">定义1：基本列</span></h4><blockquote><p>设<spanclass="math inline">\(\{a_n\}\)</span>是一个实数数列，若对<spanclass="math inline">\(\forall \varepsilon&gt;0\)</span>，<spanclass="math inline">\(\exists N \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(m,n&gt;N\)</span>时，有<br /><span class="math display">\[    |a_m-a_n| &lt; \varepsilon\]</span><br />则称该数列是一个基本列或Cauchy列。<br />该定义的一个等价叙述为：<span class="math inline">\(\forall \varepsilon&gt; 0\)</span>，<span class="math inline">\(\exists N \in\mathbb{N^+}\)</span>，使得当<span class="math inline">\(n &gt;N\)</span>时，有<br /><span class="math display">\[    |a_{n+p} - a_n| &lt; \varepsilon\]</span><br />对一切<span class="math inline">\(p \in\mathbb{N^+}\)</span>对成立，则称该数列为基本列。</p></blockquote><h4 id="定理4cauchy收敛原理"><spanid="theorem4">定理4：Cauchy收敛原理</span></h4><blockquote><p>一个数列收敛的充分必要条件是，它是基本列。</p></blockquote><h4 id="定义2上确界与下确界">定义2：上确界与下确界</h4><blockquote><p>设<spanclass="math inline">\(E\)</span>为一非空的由上界的集合，实数<spanclass="math inline">\(\beta\)</span>满足以下两个条件：<br />（1）<span class="math inline">\(\forall x \in E\)</span>，有<spanclass="math inline">\(x \le \beta\)</span><br />（2）<span class="math inline">\(\forall \varepsilon &gt; 0，\existsx_{\varepsilon} \in E\)</span>，使得<spanclass="math inline">\(x_{\varepsilon} &gt; \beta -\varepsilon\)</span><br />则称<span class="math inline">\(\beta\)</span>为集合<spanclass="math inline">\(E\)</span>的<strong>上确界</strong>，记为<spanclass="math inline">\(\beta = \sup E\)</span>；<br />若另一实数<spanclass="math inline">\(\alpha\)</span>满足以下两个条件：<br />（1）<span class="math inline">\(\forall x \in E\)</span>，有<spanclass="math inline">\(x \ge \alpha\)</span><br />（2）<span class="math inline">\(\forall \varepsilon &gt; 0，\existsy_{\varepsilon} \in E\)</span>，使得<spanclass="math inline">\(y_{\varepsilon} &lt; \alpha +\varepsilon\)</span><br />则称<span class="math inline">\(\alpha\)</span>为集合<spanclass="math inline">\(E\)</span>的<strong>下确界</strong>，记为<spanclass="math inline">\(\alpha = \inf E\)</span>。</p></blockquote><h4 id="定理5确界存在原理"><spanid="theorem5">定理5：确界存在原理</span></h4><blockquote><p>非空的有上界的集合必有上确界；非空的有下界的集合必有下确界。</p></blockquote><h4 id="定义3开覆盖">定义3：开覆盖</h4><blockquote><p>若<span class="math inline">\(A\)</span>是实数集，<spanclass="math inline">\(\mathscr{I}=\{I_{\lambda}\}\)</span>是一个开区间族，其中<spanclass="math inline">\(\lambda \in \Lambda\)</span>，这里<spanclass="math inline">\(\Lambda\)</span>称为指标集。如果<br /><span class="math display">\[    A \subset \bigcup \limits_{\lambda \in \Lambda}I_{\lambda}\]</span><br />则称开区间族<span class="math inline">\(\{I_\lambda\}\)</span>是<spanclass="math inline">\(A\)</span>的一个开覆盖。</p></blockquote><h4 id="定理6heine-borel有限覆盖定理或紧致性定理"><spanid="theorem6">定理6：（Heine-Borel）有限覆盖定理或紧致性定理</span></h4><blockquote><p>设<spanclass="math inline">\([a,b]\)</span>是一个有限闭区间，并且它有一个开覆盖<spanclass="math inline">\(\{I_\lambda\}\)</span>，那么从这个开区间族中必可以选出有限个元素（开区间），使得这有限个开区间构成的族仍是<spanclass="math inline">\([a,b]\)</span>的开覆盖。</p></blockquote><h4 id="六条定理的等价证明">六条定理的等价证明</h4>以下图的证明顺序来证明定理的等价<br /><pre class="mermaid">graph LR定理1 --> 定理2 --> 定理3 --> 定理4 --> 定理5 --> 定理6 --> 定理1</pre><h5 id="定理1rightarrow定理2">定理1<spanclass="math inline">\(\Rightarrow\)</span>定理2</h5><p>证：由闭区间族<spanclass="math inline">\(\{I_n\}\)</span>的性质可知，数列<spanclass="math inline">\(\{a_n\}\)</span>单调递增，<spanclass="math inline">\(\{b_n\}\)</span>单调递减，显然<spanclass="math inline">\(b_1\)</span>是<spanclass="math inline">\(\{a_n\}\)</span>的一个上界，<spanclass="math inline">\(a_1\)</span>是<spanclass="math inline">\(\{b_n\}\)</span>的一个下界，所以由<ahref="#theorem1">定理1</a>可知，<spanclass="math inline">\(\{a_n\}\)</span>与<spanclass="math inline">\(\{b_n\}\)</span>都收敛，不妨设<br /><span class="math display">\[    \lim \limits_{n \to \infty}a_n = a, \quad \lim \limits_{n \to\infty}b_n = b\]</span><br />又显然有<span class="math inline">\(a_n \le b_n (n \in\mathbb{N^+})\)</span>，所以由极限保号性可知<spanclass="math inline">\(a \le b\)</span>，从而<br /><span class="math display">\[    a_n \le a \le b \le b_n (n \in \mathbb{N^+})\]</span><br />此时有<br /><span class="math display">\[     0 \le |b-a| \le |b_n-a_n| = |I_n| \to 0 (n \to \infty)\]</span><br />可知<span class="math inline">\(a=b\)</span>，又因为<spanclass="math inline">\(a_n \le a \le b_n (n\in\mathbb{N^+})\)</span>，即<span class="math inline">\(a_n \in I_n (n \in\mathbb{N^+})\)</span>，所以<br /><span class="math display">\[    a \in \bigcap \limits_{n=1}^\infty I_n\]</span><br />假设还存在<span class="math inline">\(c \ne a\)</span>，使得<spanclass="math inline">\(c \in \bigcap \limits_{n=1}^\inftyI_n\)</span>，则有<span class="math inline">\(c,a \in [a_n,b_n]\)</span>，从而<br /><span class="math display">\[    |I_n|=|b_n-a_n| \ge |c-a|\]</span><br />由于<span class="math inline">\(|c-a|\)</span>是个常数，从而与<spanclass="math inline">\(|I_n| \to 0 (n \to\infty)\)</span>矛盾，从而这样的<spanclass="math inline">\(a\)</span>唯一。<br />Q.E.D.</p><h5 id="定理2rightarrow定理3">定理2<spanclass="math inline">\(\Rightarrow\)</span>定理3</h5><p>证：由于数列<spanclass="math inline">\(\{x_n\}\)</span>有界，不妨设<spanclass="math inline">\(m \le x_n \le M (n \in\mathbb{N^+})\)</span>，令区间<spanclass="math inline">\([a_1,b_1]=[m,M]\)</span>，将区间<spanclass="math inline">\([a_1,b_1]\)</span>按中点<spanclass="math inline">\((a+b)/2\)</span>分成两个闭子区间，显然必有一个子区间包含<spanclass="math inline">\(\{x_n\}\)</span>中无穷多项，记该区间为<spanclass="math inline">\([a_2,b_2]\)</span>，接着对<spanclass="math inline">\([a_2,b_2]\)</span>进行上述分析，可以得到闭区间<spanclass="math inline">\([a_3,b_3]\)</span>包含数列<spanclass="math inline">\(\{x_n\}\)</span>的无穷多项，若此继续分析下去，可以得到一列闭区间套<spanclass="math inline">\(I_n=[a_n,b_n] (n \in\mathbb{N^+})\)</span>，有<span class="math inline">\(I_1 \supset I_2\supset I_3 \supset \cdots\)</span>，<spanclass="math inline">\(|I_n|=(M-m)/2^{n-1} (n \in\mathbb{N^+})\)</span>，并且对所有<span class="math inline">\(n \in\mathbb{N^+}\)</span>，<span class="math inline">\(I_n\)</span>包含<spanclass="math inline">\(\{x_n\}\)</span>的无穷多项。<br />根据<a href="#theorem2">定理2</a>可知，<spanclass="math inline">\(\exists x \in \mathbb{R}\)</span>，使得<br /><span class="math display">\[    \lim \limits_{n\to\infty} a_n = x, \quad \lim \limits_{n\to\infty}b_n = x\]</span><br />从而<span class="math inline">\(\forall \varepsilon &gt; 0, \exists N\in \mathbb{N^+}\)</span>，使得当$ n&gt; N$时有<br /><span class="math display">\[    x-\varepsilon \le a_{n} \le x \le b_{n} \le x + \varepsilon\]</span><br />可知，<span class="math inline">\(\forall k \in \mathbb{N^+}，\existsn_k \in \mathbb{N^+}\)</span>，使得<br /><span class="math display">\[    x - \frac{1}{k} \le a_{n_k} \le x \le b_{n_k} \le x + \frac{1}{k}\]</span><br />由于<span class="math inline">\([a_{n_1}, b_{n_1}]\)</span>包含<spanclass="math inline">\(\{x_n\}\)</span>的无穷多项，从而存在<spanclass="math inline">\(x_{r_1} \in [a_{n_1},b_{n_1}]\)</span>，此时有<br /><span class="math display">\[    x - 1 \le a_{n_1} \le x_{r_1} \le b_{n_1} \le x + 1\]</span><br />又因为<span class="math inline">\([a_{n_2}, b_{n_2}]\)</span>包含<spanclass="math inline">\(\{x_n\}\)</span>的无穷多项，从而存在<spanclass="math inline">\(r_2 &gt; r_1\)</span>，使得<spanclass="math inline">\(x_{r_2} \in [a_{n_2},b_{n_2}]\)</span>，此时有<br /><span class="math display">\[    x - \frac{1}{2} \le a_{n_2} \le x_{r_2} \le b_{n_2} \le x +\frac{1}{2}\]</span><br />如此下去，可知存在<span class="math inline">\(x_{r_i} \in[a_{n_i},b_{n_i}] (1,2,\cdots)\)</span>，满足<spanclass="math inline">\(x_{r_1} &lt; x_{r_2} &lt; x_{r_3} &lt;\cdots\)</span>，且有<br /><span class="math display">\[    x - \frac{1}{i} \le x_{r_i} \le x + \frac{1}{i}\]</span><br />所以有<br /><span class="math display">\[    \lim \limits_{i \to \infty} x_{r_i} = x\]</span><br />即找到了数列<span class="math inline">\(\{x_n\}\)</span>的一个子列<spanclass="math inline">\(\{x_{r_i}\}\)</span>收敛于<spanclass="math inline">\(x\)</span>。<br />Q.E.D.</p><h5 id="定理3rightarrow定理4">定理3<spanclass="math inline">\(\Rightarrow\)</span>定理4</h5><p>证：必要性。设<spanclass="math inline">\(\{a_n\}\)</span>是一个收敛数列，其极限为<spanclass="math inline">\(a\)</span>，则<span class="math inline">\(\forall\varepsilon&gt;0，\exists N\in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N\)</span>时，有<br /><span class="math display">\[    |a_n - a| &lt; \frac{\varepsilon}{2}\]</span><br />当<span class="math inline">\(n,m&gt;N\)</span>时，可知<br /><span class="math display">\[    |a_n - a_m| = |a_n - a + a - a_m| \le |a_n-a| + |a_m - b| &lt;\varepsilon\]</span><br />从而<span class="math inline">\(\{a_n\}\)</span>是基本列。<br />充分性。先证明Cauchy基本列有界，由<ahref="#define1">基本列定义</a>可知，存在$ N<spanclass="math inline">\(，使得当\)</span>n&gt;N$时，有<br /><span class="math display">\[    |a_n - a_{N+1}| &lt; 1\]</span><br />可知<br /><span class="math display">\[    |a_n| \le |a_n - a_{N+1}| + |a_{N+1}| &lt; 1 + |a_{N+1}|\]</span><br />令<span class="math inline">\(M =\max(|a_1|,|a_2|,\cdots,|a_{N}|,1+|a_{N+1}|)\)</span>，显然有<spanclass="math inline">\(|a_n| \le M (n \in\mathbb{N^+})\)</span>，表明<spanclass="math inline">\(\{a_n\}\)</span>有界。<br />根据<a href="#theorem3">定理3</a>可知，<spanclass="math inline">\(\{a_n\}\)</span>中可以选出一个收敛子列<spanclass="math inline">\(\{a_{i_n}\}\)</span>，设<spanclass="math inline">\(\lim \limits_{n \to \infty}a_{i_n} =a\)</span>，下面证明<span class="math inline">\(a\)</span>就是数列<spanclass="math inline">\(\{a_n\}\)</span>的极限。<br /><span class="math inline">\(\forall \varepsilon &gt;0\)</span>，存在<span class="math inline">\(N_1 \in\mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<spanclass="math inline">\(|a_{i_{n}}-a| &lt;\frac{\varepsilon}{2}\)</span>；同时存在<span class="math inline">\(N_2\in \mathbb{N^+}\)</span>，使得当<span class="math inline">\(n,m &gt;N_2\)</span>时，有<span class="math inline">\(|a_n-a_m| &lt;\frac{\varepsilon}{2}\)</span>，取<span class="math inline">\(N=\max(N_1, N_2)\)</span>，可知当<span class="math inline">\(n &gt;N\)</span>时有<br /><span class="math display">\[    |a_n - a| \le |a_n - a_{i_n}| + |a_{i_n} - a| &lt; \varepsilon\]</span><br />说明<span class="math inline">\(\lim \limits_{n \to \infty}a_n =a\)</span>。<br />Q.E.D.</p><h5 id="定理4rightarrow定理5">定理4<spanclass="math inline">\(\Rightarrow\)</span>定理5</h5><p>下面只证明有上界必有上确界。有下界必有下确界可以类似证明（从略）。<br />证：设非空集合<span class="math inline">\(E\)</span>的一个上界为<spanclass="math inline">\(\gamma\)</span>，任取一点<spanclass="math inline">\(x \in E\)</span>，可知最小上界只可能在<spanclass="math inline">\([x,\gamma]\)</span>中，记<spanclass="math inline">\([a_1,b_1]=[x,\gamma]\)</span>，用<spanclass="math inline">\([a_1,b_1]\)</span>的中点<spanclass="math inline">\((a+b)/2\)</span>将该区间一分为二，若右边闭区间包含<spanclass="math inline">\(E\)</span>中的点，则将该区间记为<spanclass="math inline">\([a_2,b_2]\)</span>，否则将左边闭区间记为<spanclass="math inline">\([a_2,b_2]\)</span>，接着对<spanclass="math inline">\([a_2,b_2]\)</span>做上述类似的讨论，可得到区间<spanclass="math inline">\([a_3,b_3]\)</span>，若此继续下去，可以得到一列闭区间套<spanclass="math inline">\(I_n=[a_n,b_n] (n \in \mathbb{N^+})\)</span>，<spanclass="math inline">\(I_1 \supset I_2 \supset I_3 \supset\cdots\)</span>，且<span class="math inline">\(|I_n|=b_n-a_n=(\gamma -x)/2^{n-1} \to 0 (n\to \infty)\)</span>，则<spanclass="math inline">\(\forall \varepsilon &gt; 0，\exists N \in\mathbb{N^+}\)</span>，且该区间套包含两个重要的特征：<br />（a）<span class="math inline">\(I_n\)</span>的右端点<spanclass="math inline">\(b_n\)</span>的右边没有<spanclass="math inline">\(E\)</span>中的点，即<spanclass="math inline">\([b_n,+\infty] (n=1,2,\cdots)\)</span>都是<spanclass="math inline">\(E\)</span>的上界。<br />（b）<span class="math inline">\(I_n\)</span>总是包含<spanclass="math inline">\(E\)</span>中的点。<br />使得当<span class="math inline">\(n &gt; N\)</span>时，有<spanclass="math inline">\(b_n - a_n &lt; \varepsilon\)</span>，此时<spanclass="math inline">\(\forall p \in \mathbb{N^+}\)</span>，有<br /><span class="math display">\[    |b_{n+p} - b_n| = b_n - b_{n+p} &lt; b_n - a_{n+p} &lt; b_n - a_n&lt; \varepsilon\]</span><br />所以<span class="math inline">\(\{b_n\}\)</span>是基本列，有<ahref="#theorem4">定理4</a>可知，数列<spanclass="math inline">\(\{b_n\}\)</span>收敛，设<spanclass="math inline">\(\lim\limits_{n\to\infty}b_n=\beta\)</span>，下面证明<spanclass="math inline">\(\beta=\sup E\)</span>。</p><p>（1）证明<span class="math inline">\(\beta\)</span>是上界。任取<spanclass="math inline">\(c \in E\)</span>，由（a）可知，有<spanclass="math inline">\(c \le b_n\)</span>，令<spanclass="math inline">\(n \to \infty\)</span>，得到<spanclass="math inline">\(c \le \beta\)</span><br />（2）证明<span class="math inline">\(\beta\)</span>是上确界。由<spanclass="math inline">\(\lim \limits_{n \to \infty}(b_n - a_n) =0\)</span>，<span class="math inline">\(\lim \limits_{n \to \infty}b_n =\beta\)</span>，可知<span class="math inline">\(\forall \varepsilon &gt;0, \exists N_1 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<br /><span class="math display">\[    b_n - a_n &lt; \frac{\varepsilon}{2}\]</span><br />同时<span class="math inline">\(\exists N_2 \in\mathbb{N}\)</span>，使得当<span class="math inline">\(n &gt;N_2\)</span>时，有<br /><span class="math display">\[    |b_n - \beta| &lt; \frac{\varepsilon}{2} \Rightarrow b_n &gt; \beta- \frac{\varepsilon}{2}\]</span><br />从而有<br /><span class="math display">\[    a_n = b_n - (b_n - a_n) &gt; \beta - \frac{\varepsilon}{2} -\frac{\varepsilon}{2} = \beta - \varepsilon\]</span><br />则由（b）可知，存在<span class="math inline">\(E\)</span>中的点记为<spanclass="math inline">\(d\)</span>，满足<span class="math inline">\(d \in[a_n,b_n]\)</span>，从而有<span class="math inline">\(d \ge a_n &gt;\beta - \varepsilon\)</span>，所以<spanclass="math inline">\(\beta\)</span>是最小上界。<br />Q.E.D.</p><h5 id="定理5rightarrow定理6">定理5<spanclass="math inline">\(\Rightarrow\)</span>定理6</h5><p>证：设<span class="math inline">\([a,b]\)</span>有一个开覆盖<spanclass="math inline">\(H\)</span>，令<span class="math inline">\(S=\{x| a&lt; x \le b,[a,x]可以被H的有限个元素覆盖\}\)</span>，可知<spanclass="math inline">\(S\)</span>由上界。<br />（1）证明<span class="math inline">\(S\)</span>非空。因为<spanclass="math inline">\(a \in [a,b] \subset H\)</span>，所以存在<spanclass="math inline">\([\alpha, \beta] \in H\)</span>，使得<spanclass="math inline">\(a \in [\alpha, \beta]\)</span>，取<spanclass="math inline">\(x \in (\alpha, \beta)\)</span>，则<spanclass="math inline">\([a,x] \subset [\alpha, \beta]\)</span>，记<spanclass="math inline">\(x \in S\)</span>，所以<spanclass="math inline">\(S\)</span>非空。<br />（2）由<a href="#theorem5">定理5</a>可知，<spanclass="math inline">\(S\)</span>有上确界，令<spanclass="math inline">\(\sup S = \eta\)</span>，证明<spanclass="math inline">\(b=\eta\)</span>。反证法。假设<spanclass="math inline">\(\eta &lt; b\)</span>，则有<spanclass="math inline">\(a &lt; \eta &lt; b\)</span>，可知存在<spanclass="math inline">\([\alpha_1, \beta_1] \in H\)</span>，使得<spanclass="math inline">\(\eta \in [\alpha_1, \beta_1]\)</span>，由于<spanclass="math inline">\(\eta\)</span>是<spanclass="math inline">\(E\)</span>的上确界，所以必存在<spanclass="math inline">\(x_1 \in S\)</span>，使得<spanclass="math inline">\(\alpha_1 &lt; x_1 &lt; \eta\)</span>，取<spanclass="math inline">\(x_2 \in R\)</span>，使得<spanclass="math inline">\(\eta &lt; x_2 &lt; \beta_1\)</span>，有<br /><span class="math display">\[    \alpha_1 &lt; x_1 &lt; \eta &lt; x_2 &lt; \beta_1\]</span><br />从而有<br /><span class="math display">\[    [a,x_2] \subset [a,x_1] \cup [\alpha_1, \beta_1]\]</span><br />由于<span class="math inline">\(x_1 \in S\)</span>，所以<spanclass="math inline">\([a,x_1]\)</span>可以被<spanclass="math inline">\(H\)</span>中有限个元素覆盖，而<spanclass="math inline">\([\alpha_1, \beta_1] \in H\)</span>，所以<spanclass="math inline">\([a,x_2]\)</span>可以被<spanclass="math inline">\(H\)</span>中有限个元素覆盖，即<spanclass="math inline">\(x_2 \in S\)</span>，与<spanclass="math inline">\(\eta\)</span>是<spanclass="math inline">\(E\)</span>的最小上界矛盾。所以<spanclass="math inline">\(b=\sup S\)</span>，所以<spanclass="math inline">\([a,b)\)</span>能被<spanclass="math inline">\(H\)</span>有限个元素覆盖，而<spanclass="math inline">\(b \in H\)</span>，所以存在<spanclass="math inline">\([\alpha_2, \beta_2] \in H\)</span>，使得<spanclass="math inline">\(b \in [\alpha_2, \beta_2]\)</span>，所以<spanclass="math inline">\([a,b]\)</span>能被<spanclass="math inline">\(H\)</span>有限个元素覆盖。<br />Q.E.D.</p><h5 id="定理6rightarrow定理1">定理6<spanclass="math inline">\(\Rightarrow\)</span>定理1</h5><p>证：反证法。假设数列<spanclass="math inline">\(\{a_n\}\)</span>单调并有界，但没有极限。不妨设<spanclass="math inline">\(a_n \in [a, b] (n=1,2,\cdots)\)</span>，由于<spanclass="math inline">\(\{a_n\}\)</span>没有极限，从而<spanclass="math inline">\(\forall x \in [a,b]，\exists\varepsilon_x&gt;0，\forall N \in \mathbb{N^+}，\exists M &gt;N\)</span>，使得<br /><span class="math display">\[|a_{M} - x| \ge \varepsilon_x \Rightarrow a_{M} \gex+\varepsilon_x或a_{M} \le x-\varepsilon_x\]</span><br />（1）先证明<spanclass="math inline">\(\{a_n\}\)</span>无论是单调递增还是单调递减，区间<spanclass="math inline">\((x - \varepsilon_x, x +\varepsilon_x)\)</span>只包含<spanclass="math inline">\(\{a_n\}\)</span>中的有限多项或者0项。<br />（1.a）若<span class="math inline">\(\{a_n\}\)</span>单调递增，当<spanclass="math inline">\(n&gt;M\)</span>时，有<spanclass="math inline">\(a_n \ge a_{M} \ge x +\varepsilon_x\)</span>，所以<spanclass="math inline">\((x-\varepsilon_x,x+\varepsilon_x)\)</span>区间内只可能含有<spanclass="math inline">\(\{a_n\}\)</span>中的有限多项，也可能不包含<spanclass="math inline">\(\{a_n\}\)</span>的项即0个；<br />（1.b） 若<span class="math inline">\(\{a_n\}\)</span>单调递减，当<spanclass="math inline">\(n&gt;M\)</span>时，有<spanclass="math inline">\(a_n \le a_{M} \le x -\varepsilon_x\)</span>，也可以知道<span class="math inline">\((x -\varepsilon_x, x + \varepsilon_x)\)</span>只包含<spanclass="math inline">\(\{a_n\}\)</span>中的有限多项或者0项。<br />（2）取<span class="math inline">\(H=\{(x-\varepsilon_x,x+\varepsilon_x)| x\in [a,b]\}\)</span>，可知<spanclass="math inline">\(H\)</span>是<spanclass="math inline">\([a,b]\)</span>的一个开覆盖，由<ahref="#theorem6">定理6</a>可知，存在<span class="math inline">\(\existsn_0 \in \mathbb{N^+}\)</span>，使得<br /><span class="math display">\[\bigcup \limits_{i=1}^{n_0}(x_i-\varepsilon_i,x_i+\varepsilon_i) \supset[a,b]\]</span><br />其中<span class="math inline">\((x_i-\varepsilon_i,x_i+\varepsilon_i)\in H (i=1,2,\cdots)\)</span>，记<span class="math inline">\(H_{n_0} =\bigcup\limits_{i=1}^{n_0}(x_i-\varepsilon_i,x_i+\varepsilon_i)\)</span>；<br />由于<span class="math inline">\(n_0\)</span>是有限数，且属于<spanclass="math inline">\(H_{n_0}\)</span>每个开区间也只包含<spanclass="math inline">\(\{a_n\}\)</span>中的有限项，所以<spanclass="math inline">\(H_{n_0}\)</span>只包含<spanclass="math inline">\(\{a_n\}\)</span>的有限项，从而<spanclass="math inline">\([a, b]\)</span>只包含<spanclass="math inline">\(\{a_n\}\)</span>的有限项，与<spanclass="math inline">\(a_n \in [a, b](n=1,2,\cdots)\)</span>矛盾。所以<spanclass="math inline">\(\{a_n\}\)</span>有极限。<br />Q.E.D.</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 点列极限 </tag>
            
            <tag> 实数连续性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点列极限一：数列极限定义与基本性质</title>
      <link href="/2020/09/20/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%901/"/>
      <url>/2020/09/20/%E7%82%B9%E5%88%97%E6%9E%81%E9%99%901/</url>
      
        <content type="html"><![CDATA[<h4 id="定义1"><span id="define1">定义1</span></h4><blockquote><p>在<span class="math inline">\(\mathbb{R}\)</span>上，设<spanclass="math inline">\(\{a_n\}\)</span>是一个数列，<spanclass="math inline">\(a \in \mathbb{R}\)</span>，若<spanclass="math inline">\(\forall \varepsilon&gt;0\)</span>，<spanclass="math inline">\(\exists N(\varepsilon)\in\mathbb{N^+}\)</span>，使得<span class="math inline">\(\foralln&gt;N(\varepsilon)\)</span>，有<spanclass="math inline">\(|a_n-a|&lt;\varepsilon\)</span>，则称<spanclass="math inline">\(\{a_n\}\)</span>当<spanclass="math inline">\(n\)</span>趋于无穷大时以<spanclass="math inline">\(a\)</span>为极限，记为<br /><span class="math display">\[    \lim_{n\to \infty} a_n = a\]</span><br />或<br /><span class="math display">\[a_n \to a \quad (n \to \infty)\]</span><br />也称数列<span class="math inline">\(\{a_n\}\)</span>收敛于<spanclass="math inline">\(a\)</span>；存在极限的数列称为收敛数列，否则称为发散数列。</p></blockquote><span id="more"></span><h4 id="定理1数列极限唯一性">定理1：数列极限唯一性</h4><blockquote><p>如果数列<spanclass="math inline">\(\{a_n\}\)</span>收敛，那么极限只有一个。</p></blockquote><p>证：反证法。假设存在两个不同的极限<span class="math inline">\(a,b\)</span>，不妨设 <span class="math inline">\(a &lt; b\)</span>，由<ahref="#define1">定义1</a>可知，对<spanclass="math inline">\(\frac{b-a}{2}&gt;0\)</span>，存在<spanclass="math inline">\(N_1 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<br /><span class="math display">\[    |a_n-a|&lt;\frac{b-a}{2} \tag 1\]</span><br />同理存在<span class="math inline">\(N_2 \in\mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_2\)</span>时，有<br /><span class="math display">\[    |a_n-b|&lt;\frac{b-a}{2} \tag 2\]</span><br />令<span class="math inline">\(N=\max(N_1,N_2)\)</span>，可知当<spanclass="math inline">\(n&gt;N\)</span>时，式(1)(2)同时成立，由式(1)可得<spanclass="math inline">\(a_n&lt;\frac{a+b}{2}\)</span>，由式(2)可得<spanclass="math inline">\(a_n&gt;\frac{a+b}{2}\)</span>，从而矛盾，所以假设不成立，记极限唯一。<br />Q.E.D.</p><h4 id="定义2">定义2</h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>是一个数列，若<spanclass="math inline">\(\exists A \in \mathbb{R}\)</span>，使得 <spanclass="math inline">\(\forall n \in \mathbb{N^+}\)</span> ，有<spanclass="math inline">\(a_n \le A\)</span>，则称<spanclass="math inline">\(\{a_n\}\)</span>有上界，<spanclass="math inline">\(A\)</span>是此数列的一个上界；若<spanclass="math inline">\(\exists B \in \mathbb{R}\)</span>，使得<spanclass="math inline">\(\forall n \in \mathbb{N^+}\)</span>，有<spanclass="math inline">\(a_n \ge B\)</span>，则称<spanclass="math inline">\(\{a_n\}\)</span>有下界，<spanclass="math inline">\(B\)</span>是此数列的一个下界；若数列既有上界又有下界，则称此数列是一个有界数列。</p></blockquote><h4 id="定理2"><span id="theorem2">定理2</span></h4><blockquote><p>收敛数列是有界的。</p></blockquote><p>证：设数列<span class="math inline">\(\{a_n\}\)</span>收敛于<spanclass="math inline">\(a\)</span>，由<ahref="#define1">定义1</a>可知，对于<spanclass="math inline">\(1&gt;0\)</span>，存在<span class="math inline">\(N\in \mathbb{N^+}\)</span>，使得当<span class="math inline">\(n &gt;N\)</span>时，有<span class="math inline">\(|a_n-a| &lt;1\)</span>，从而<spanclass="math inline">\(|a_n|=|a_n-a+a|&lt;=|a_n-a|+|a|&lt;1+|a|\)</span>，令<spanclass="math inline">\(M=|a_1|+|a_2|+\cdots+|a_N|+|a|+1\)</span>，可知对所有的<spanclass="math inline">\(n \in \mathbb{N^+}\)</span>，有<spanclass="math inline">\(|a_n|&lt;M\)</span>。<br />Q.E.D.</p><h4 id="定义3">定义3</h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>是一个数列，<spanclass="math inline">\(k_i \in \mathbb{N^+}(i=1,2,3,\cdots)\)</span>，且满足<spanclass="math inline">\(k_1&lt;k_2&lt;k_3&lt;\cdots\)</span>，那么数列<spanclass="math inline">\(\{a_{k_n}\}\)</span>称为<spanclass="math inline">\(\{a_n\}\)</span>的一个子列。</p></blockquote><h4 id="定理3">定理3</h4><blockquote><p>设数列<span class="math inline">\(\{a_n\}\)</span>的极限为<spanclass="math inline">\(a\)</span>，那么该数列的任何一个子列都收敛于<spanclass="math inline">\(a\)</span>。</p></blockquote><p>证：任取<span class="math inline">\(\{a_n\}\)</span>的一个子列<spanclass="math inline">\(\{a_{k_n}\}，\)</span>由<ahref="#define1">定义1</a>可知，任取<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(N\in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N\)</span>时，有<spanclass="math inline">\(|a_n-a|&lt;\varepsilon\)</span>，而<spanclass="math inline">\(k_n \ge n\)</span>，所以当<spanclass="math inline">\(k_n \ge n &gt; N\)</span>时， 有<spanclass="math inline">\(|a_{k_n}-a|&lt;\varepsilon\)</span>，所以<spanclass="math inline">\(\{a_{k_n}\}\)</span>收敛于<spanclass="math inline">\(a\)</span>。<br />Q.E.D.</p><h4 id="定理4极限的四则运算">定理4：极限的四则运算</h4><blockquote><p>设<span class="math inline">\(\{a_n\}\)</span>与<spanclass="math inline">\(\{b_n\}\)</span>都是收敛数列，则<spanclass="math inline">\(\{a_n+b_n\}\)</span>，<spanclass="math inline">\(\{a_nb_n\}\)</span>也是收敛数列，如果<spanclass="math inline">\(\lim \limits_{n\to\infty}b_n \ne0\)</span>，则<spanclass="math inline">\(\{\frac{a_n}{b_n}\}\)</span>也收敛，并且有：<br />（1）<span class="math inline">\(\lim \limits_{n\to\infty}(a_n \pmb_n)=\lim \limits_{n\to\infty}a_n \pm \lim\limits_{n\to\infty}b_n\)</span><br />（2）<span class="math inline">\(\lim \limits_{n\to\infty}(a_nb_n)=\lim\limits_{n\to\infty}a_n \cdot \lim\limits_{n\to\infty}b_n\)</span><br />（3）<span class="math inline">\(\lim\limits_{n\to\infty}\frac{a_n}{b_n}=\frac{\lim\limits_{n\to\infty}a_n}{\lim \limits_{n\to\infty}b_n}\)</span></p></blockquote><p>证：设<span class="math inline">\(\lim\limits_{n\to\infty}a_n=a\)</span>，<span class="math inline">\(\lim\limits_{n\to\infty}b_n=b\)</span></p><p>（1）由<a href="#define1">定义1</a>可知，任取<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(N_1 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<spanclass="math inline">\(|a_n-a|&lt;\frac{\varepsilon}{2}\)</span>；存在<spanclass="math inline">\(N_2 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_2\)</span>时，有<spanclass="math inline">\(|b_n-b|&lt;\frac{\varepsilon}{2}\)</span>；取<spanclass="math inline">\(N=\max(N_1,N_2)\)</span>，可知当<spanclass="math inline">\(n&gt;N\)</span>时，有<br /><span class="math display">\[\begin{aligned}    |(a_n \pm b_n) - (a \pm b)| &amp; = |(a_n-a) \pm (b_n-b)| \\    &amp; \le |a_n-a| + |b_n-b| \\    &amp; &lt; \frac{\varepsilon}{2} + \frac{\varepsilon}{2} =\varepsilon\end{aligned}\]</span></p><p>（2） 由于<span class="math inline">\(\{a_n\}\)</span>收敛，由<ahref="#theorem2">定理2</a>可知<spanclass="math inline">\(\{a_n\}\)</span>有界，即存在<spanclass="math inline">\(M \in N^*\)</span>，使得<spanclass="math inline">\(|a_n|&lt;M\)</span>对一切<spanclass="math inline">\(n \in N^*\)</span>成立，从而有<br /><span class="math display">\[\begin{aligned}    |a_nb_n-ab| &amp; = |a_nb_n-a_nb+a_nb-ab| \\    &amp; \le |a_n||b_n-b| + |b||a_n-a| \\    &amp; \le M|b_n-b| + |b||a_n-a|\end{aligned}\]</span><br />类似（1），因为<span class="math inline">\(\{a_n\}\)</span>，<spanclass="math inline">\(\{b_n\}\)</span>分别收敛于<spanclass="math inline">\(a,b\)</span>，所以对任意的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(n \in N^*\)</span>，使得当<spanclass="math inline">\(n&gt;N\)</span>时，有<br /><span class="math display">\[    |a_n-a|&lt;\frac{\varepsilon}{2(|b|+1)}，|b_n-b|&lt;\frac{\varepsilon}{2M}\]</span><br />同时成立；从而<br /><span class="math display">\[    |a_nb_n-ab| &lt; M \frac{\varepsilon}{2M} +|b|\frac{\varepsilon}{2(|b|+1)} &lt; \varepsilon\]</span></p><p>（3）先证明，当<span class="math inline">\(b\ne0\)</span>时，有<br /><span class="math display">\[   \lim \limits_{n\to\infty}\frac{1}{b_n}=\frac{1}{b}\]</span><br />对<span class="math inline">\(\frac{|b|}{2}&gt;0\)</span>，存在<spanclass="math inline">\(N_1 \in N^*\)</span>，当<spanclass="math inline">\(n&gt;N^*\)</span>时，有<br /><span class="math display">\[    |b_n-b|&lt;\frac{|b|}{2}\]</span><br />此时，有<span class="math inline">\(|b_n| \ge |b| - |b_n-b| &gt;\frac{|b|}{2} &gt; 0\)</span>，并且有<br /><span class="math display">\[    \left|\frac{1}{b_n} - \frac{1}{b}\right| = \frac{|b_n - b|}{|b_nb|}\le \frac{2}{b^2} |b_n-b|\]</span><br />由于<span class="math inline">\(\{b_n\}\)</span>收敛于<spanclass="math inline">\(b\)</span>，对任意的<spanclass="math inline">\(\varepsilon&gt;0\)</span>，存在<spanclass="math inline">\(N_2\in N^*\)</span>，使得当<spanclass="math inline">\(n&gt;N_2\)</span>时，有<spanclass="math inline">\(|b_n-b|&lt;\frac{b^2}{2}\varepsilon\)</span>；从而当<spanclass="math inline">\(n&gt;\max(N_1,N_2)\)</span>时，有<br /><span class="math display">\[    \left|\frac{1}{b_n} - \frac{1}{b}\right| &lt;\frac{2}{b^2}\frac{b^2}{2}\varepsilon=\varepsilon\]</span><br />所以<br /><span class="math display">\[\lim \limits_{n\to\infty}\frac{1}{b_n}=\frac{1}{b}\]</span><br />再由前面已证的（2），可知<br /><span class="math display">\[    \lim \limits_{n\to\infty}\frac{a_n}{b_n}=\lim\limits_{n\to\infty}a_n(\frac{1}{b_n})=\frac{b}{a}\]</span><br />Q.E.D.</p><h4 id="定理5极限保号性"><spanid="theorem5">定理5</span>：极限保号性</h4><blockquote><p>（1）设<span class="math inline">\(\lim\limits_{n\to\infty}a_n=a\)</span>，<spanclass="math inline">\(\alpha，\beta\)</span>满足<spanclass="math inline">\(\alpha &lt; a &lt; \beta\)</span>，那么当<spanclass="math inline">\(n\)</span>充分大时，有<spanclass="math inline">\(\alpha &lt; a_n &lt; \beta\)</span>。<br />（2）设<span class="math inline">\(\lim \limits_{n\to\infty}a_n=a，\lim\limits_{n\to\infty}b_n=b\)</span>，且<span class="math inline">\(a &lt;b\)</span>，那么当<spanclass="math inline">\(n\)</span>充分大时，一定有<spanclass="math inline">\(a_n &lt; b_n\)</span>。<br />（3）设<span class="math inline">\(\lim \limits_{n\to\infty}a_n=a，\lim\limits_{n\to\infty}b_n=b\)</span>，并且当<spanclass="math inline">\(n\)</span>充分大时<span class="math inline">\(a_n\le b_n\)</span>，那么有<span class="math inline">\(a \leb\)</span>。</p></blockquote><p>证：（1）对<span class="math inline">\(\varepsilon =\beta-a&gt;0\)</span>，则存在<span class="math inline">\(N_1 \in\mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_1\)</span>时，有<br /><span class="math display">\[    |a_n-a|&lt;\beta-a \Rightarrow a_n&lt;\beta\]</span><br />同理，对<span class="math inline">\(\varepsilon =a-\alpha&gt;0\)</span>，则存在<span class="math inline">\(N_2 \in\mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N_2\)</span>时，有<br /><span class="math display">\[    |a_n-a|&lt;a-\alpha \Rightarrow a_n&gt;\alpha\]</span><br />从而当<spanclass="math inline">\(n&gt;\max(N_1,N_2)\)</span>时，有<br /><span class="math display">\[    \alpha &lt; a &lt;\beta\]</span></p><p>（2）取<spanclass="math inline">\(m=\frac{a+b}{2}\)</span>，则有<spanclass="math inline">\(a&lt;m&lt;b\)</span>，此时由（1）可知，当<spanclass="math inline">\(n\)</span>充分大时，有<br /><span class="math display">\[    a_n &lt; m &lt; b_n\]</span></p><p>（3）反证法。假设<spanclass="math inline">\(a&gt;b\)</span>，则由（2）可知，当<spanclass="math inline">\(n\)</span>充分大时，有<spanclass="math inline">\(a_n&gt;b_n\)</span>，与条件<spanclass="math inline">\(a_n \le b_n\)</span>矛盾，所以<spanclass="math inline">\(a \le b\)</span>。</p><p>Q.E.D.</p><h4 id="定理6夹逼定理">定理6：夹逼定理</h4><blockquote><p>三个实数域上的数列<spanclass="math inline">\(\{a_n\},\{b_n\},\{c_n\}\)</span>，若满足<br /><span class="math display">\[    a_n \le b_n \le c_n \quad  (n \in \mathbb{N^+})\]</span><br />若<span class="math inline">\(\lim \limits_{n\to\infty}a_n=\lim\limits_{n\to\infty}c_n=a\)</span>，那么<br /><span class="math display">\[    \lim \limits_{n\to\infty}b_n = a\]</span></p></blockquote><p>证：由<a href="#theorem5">定理5</a>的（3）可知，有<br /><span class="math display">\[    a = \lim \limits_{n\to\infty}a_n \le \lim \limits_{n\to\infty}b_n\le \lim \limits_{n\to\infty}c_n = a\]</span><br />从而有<br /><span class="math display">\[\lim \limits_{n\to\infty}b_n = a\]</span><br />Q.E.D.</p><h4 id="定义4">定义4</h4><blockquote><p>如果数列<spanclass="math inline">\(\{a_n\}\)</span>满足条件，对任何正数<spanclass="math inline">\(A\)</span>，都存在<span class="math inline">\(N\in\mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N\)</span>时，有<spanclass="math inline">\(a_n&gt;A\)</span>，则称数列<spanclass="math inline">\(\{a_n\}\)</span>趋向于<spanclass="math inline">\(+\infty\)</span>，记作<br /><span class="math display">\[    \lim \limits_{n\to\infty}a_n = +\infty\]</span></p></blockquote><blockquote><p>如果对任何正数<span class="math inline">\(A\)</span>，都存在<spanclass="math inline">\(N\in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n&gt;N\)</span>时，有<spanclass="math inline">\(a_n&lt;-A\)</span>，则称数列<spanclass="math inline">\(\{a_n\}\)</span>趋向于<spanclass="math inline">\(-\infty\)</span>，记作<br /><span class="math display">\[    \lim \limits_{n\to\infty}a_n = -\infty\]</span></p></blockquote><h4 id="定义5">定义5</h4><blockquote><p>如果收敛数列<spanclass="math inline">\(\{a_n\}\)</span>的极限为0，则称该数列为无穷小数列，简称无穷小；如果<spanclass="math inline">\(\lim\limits_{n\to\infty}|a_n|=\infty\)</span>，则称该数列趋向于<spanclass="math inline">\(\infty\)</span>，记作<spanclass="math inline">\(\lim\limits_{n\to\infty}a_n=\infty\)</span>，也称该数列为无穷大数列，简称无穷大。</p></blockquote><h4 id="定义6单调数列">定义6：单调数列</h4><blockquote><p>如果数列<span class="math inline">\(\{a_n\}\)</span>满足<br /><span class="math display">\[    a_n \le a_{n+1} \quad (n=1,2,\cdots)\]</span><br />则称此数列为递增数列；如果<spanclass="math inline">\(\{a_n\}\)</span>满足<br /><span class="math display">\[    a_n \ge a_{n+1} \quad (n=1,2,\cdots)\]</span><br />则称此数列为递减数列；如果上面两个不等式都是严格的，即<spanclass="math inline">\(a_n &lt; a_{n+1}\)</span>（或<spanclass="math inline">\(a_n &gt; a_{n+1}\)</span>）（<spanclass="math inline">\(n=1,2,\cdots\)</span>），则称此数列为严格递增的（或严格递减的）</p></blockquote><h4id="定理7单调且有界的数列一定有界">定理7：单调且有界的数列一定有界。</h4><p>证：不妨设数列<spanclass="math inline">\(\{a_n\}\)</span>为递增的且有上界，利用实数都可以表示成十进制无尽小数的性质，将该数列的每项表示为无尽小数：<br /><span class="math display">\[    \begin{aligned}    a_1 &amp; = A_1.b_{11}b_{12}\cdots \\    a_2 &amp; = A_2.b_{21}b_{22}\cdots \\    a_3 &amp; = A_3.b_{31}b_{32}\cdots \\    &amp; \cdots    \end{aligned}\]</span><br />其中<spanclass="math inline">\(A_1,A_2,A_3,\cdots\)</span>都是整数，而<spanclass="math inline">\(b_{ij}\)</span>是0到9中的数。由于<spanclass="math inline">\(\{a_n\}\)</span>有上界，从而<spanclass="math inline">\(\{A_n\}\)</span>必有上界，记该数为<spanclass="math inline">\(A\)</span>，而<spanclass="math inline">\(\{a_n\}\)</span>又是单调递增的，从而存在<spanclass="math inline">\(N_0 \in \mathbb{N^+}\)</span>，使得当<spanclass="math inline">\(n \ge N_0\)</span>时，有<spanclass="math inline">\(A_n=A\)</span>；此时考虑<spanclass="math inline">\(\{a_n\}\)</span>数列<span class="math inline">\(n\ge N_0\)</span>的项，对<spanclass="math inline">\(b_{N_01},b_{(N_0+1)1},b_{(N_0+2)1},\cdots\)</span>类似前面的讨论，可知<spanclass="math inline">\(\{b_{i1}\}(i \ge N_0)\)</span>存在上界，记为<spanclass="math inline">\(x_1\)</span>，同时存在<spanclass="math inline">\(N_1 \ge N_0\)</span>，使得当<spanclass="math inline">\(n \ge N_1\)</span>时，有<spanclass="math inline">\(b_{n1}=x_1\)</span>；对其他列类比讨论，可以得到一列数<spanclass="math inline">\(x_1,x_2,x_3,\cdots\)</span>，以及相应的正整数<spanclass="math inline">\(N_0 \le N_1 \le N_2 \le \cdots\)</span>。令<spanclass="math inline">\(a=A.x_1x_2x_3\cdots\)</span>，下面证明<spanclass="math inline">\(a\)</span>就是数列<spanclass="math inline">\(\{a_n\}\)</span>的极限。任取<spanclass="math inline">\(\varepsilon&gt;0\)</span>，总存在<spanclass="math inline">\(m \in \mathbb{N^+}\)</span>，使得<spanclass="math inline">\(10^{-m}&lt;\varepsilon\)</span>，而当<spanclass="math inline">\(n&gt;N_m\)</span>，有<spanclass="math inline">\(a_n\)</span>的整数部分和小数点后的前<spanclass="math inline">\(m\)</span>位上的数与<spanclass="math inline">\(a\)</span>完全一致，所以<br /><span class="math display">\[    |a_n-a| &lt; 10^{-m} &lt; \varepsilon\]</span><br />从而证明了<br /><span class="math display">\[    \lim \limits_{n\to\infty}a_n = a\]</span></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学分析 </tag>
            
            <tag> 点列极限 </tag>
            
            <tag> 数列极限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim教程</title>
      <link href="/2020/03/20/vim%E6%95%99%E7%A8%8B/"/>
      <url>/2020/03/20/vim%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="vim逻辑">1 Vim逻辑</h2><blockquote><p>Vim命令逻辑为operation +motion的方式，首先输入主要操作（命令），然后可以输入行为，比如输入c，然后输入5→表示修改右边5个字符</p></blockquote><span id="more"></span><h2 id="快捷键">2 快捷键</h2><ul><li>普通模式</li></ul><table><colgroup><col style="width: 9%" /><col style="width: 30%" /><col style="width: 60%" /></colgroup><thead><tr class="header"><th style="text-align: center;">快捷键</th><th style="text-align: center;">含义</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">esc</td><td style="text-align: center;"></td><td style="text-align: center;">进入普通模式</td></tr><tr class="even"><td style="text-align: center;">h</td><td style="text-align: center;"></td><td style="text-align: center;">左</td></tr><tr class="odd"><td style="text-align: center;">j</td><td style="text-align: center;"></td><td style="text-align: center;">下</td></tr><tr class="even"><td style="text-align: center;">k</td><td style="text-align: center;"></td><td style="text-align: center;">上</td></tr><tr class="odd"><td style="text-align: center;">l</td><td style="text-align: center;"></td><td style="text-align: center;">右</td></tr><tr class="even"><td style="text-align: center;">i</td><td style="text-align: center;">insert</td><td style="text-align: center;">光标前一个字符插入</td></tr><tr class="odd"><td style="text-align: center;">gg</td><td style="text-align: center;"></td><td style="text-align: center;">到文件头部</td></tr><tr class="even"><td style="text-align: center;">G</td><td style="text-align: center;"></td><td style="text-align: center;">到文件尾部</td></tr><tr class="odd"><td style="text-align: center;">a</td><td style="text-align: center;">append</td><td style="text-align: center;">光标后一个字符插入</td></tr><tr class="even"><td style="text-align: center;">I</td><td style="text-align: center;">shift+insert</td><td style="text-align: center;">行首插入</td></tr><tr class="odd"><td style="text-align: center;">A</td><td style="text-align: center;">shift+append</td><td style="text-align: center;">行尾插入</td></tr><tr class="even"><td style="text-align: center;">u</td><td style="text-align: center;">undo</td><td style="text-align: center;">撤销</td></tr><tr class="odd"><td style="text-align: center;">d</td><td style="text-align: center;">delete(cut)</td><td style="text-align: center;">删除（剪切）</td></tr><tr class="even"><td style="text-align: center;">p</td><td style="text-align: center;">paste</td><td style="text-align: center;">粘贴</td></tr><tr class="odd"><td style="text-align: center;">y</td><td style="text-align: center;">yank</td><td style="text-align: center;">复制</td></tr><tr class="even"><td style="text-align: center;">c</td><td style="text-align: center;">change</td><tdstyle="text-align: center;">修改（删除光标中的内容并进入编辑模式）</td></tr><tr class="odd"><td style="text-align: center;">w</td><td style="text-align: center;">word</td><td style="text-align: center;">光标移动到下一个词</td></tr><tr class="even"><td style="text-align: center;">f</td><td style="text-align: center;">find</td><td style="text-align: center;">在行内查找</td></tr><tr class="odd"><td style="text-align: center;">%</td><td style="text-align: center;"></td><td style="text-align: center;">快速定位括号的另一半</td></tr><tr class="even"><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;"></td><td style="text-align: center;">向前缩进</td></tr><tr class="odd"><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;"></td><td style="text-align: center;">向后缩进</td></tr><tr class="even"><td style="text-align: center;">cw</td><td style="text-align: center;">change word</td><td style="text-align: center;">光标位于词开头，修改整个词</td></tr><tr class="odd"><td style="text-align: center;">ciw</td><td style="text-align: center;">change in word</td><td style="text-align: center;">光标位于中间，修改整个词</td></tr><tr class="even"><td style="text-align: center;">ci"</td><td style="text-align: center;">change in " "</td><td style="text-align: center;">光标位于单引号中，修改单引号中的词</td></tr><tr class="odd"><td style="text-align: center;">di"</td><td style="text-align: center;">delete in " "</td><td style="text-align: center;">光标位于单引号中，删除单引号中的词</td></tr><tr class="even"><td style="text-align: center;">yi"</td><td style="text-align: center;">yank in " "</td><td style="text-align: center;">光标位于单引号中，复制单引号中的词</td></tr><tr class="odd"><td style="text-align: center;">cf"</td><td style="text-align: center;">change until find "</td><td style="text-align: center;">修改从光标到找到单引号字符的内容</td></tr></tbody></table><ul><li>命令行模式</li></ul><table><colgroup><col style="width: 7%" /><col style="width: 6%" /><col style="width: 85%" /></colgroup><thead><tr class="header"><th style="text-align: center;">快捷键</th><th style="text-align: center;">含义</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">:</td><td style="text-align: center;"></td><td style="text-align: center;">命令行模式</td></tr><tr class="even"><td style="text-align: center;">:q</td><td style="text-align: center;">quit</td><td style="text-align: center;">命令行模式下，退出</td></tr><tr class="odd"><td style="text-align: center;">:r file</td><td style="text-align: center;"></td><tdstyle="text-align: center;">将file文件的内容读到当前文件中（从光标后一行插入）</td></tr><tr class="even"><td style="text-align: center;">:w</td><td style="text-align: center;">writen</td><td style="text-align: center;">命令行模式下，保存（写入）</td></tr><tr class="odd"><td style="text-align: center;">:w file</td><td style="text-align: center;"></td><tdstyle="text-align: center;">另存到file文件（如果在vision模型下选中的内容，会将这部分内容保存到file文件）</td></tr><tr class="even"><td style="text-align: center;">:s</td><td style="text-align: center;"></td><td style="text-align: center;">替换</td></tr><tr class="odd"><td style="text-align: center;">:!</td><td style="text-align: center;"></td><td style="text-align: center;">执行shell命令</td></tr></tbody></table><h2 id="搜索与替换">3 搜索与替换</h2><ul><li><p><code>/</code>搜索模式下，从光标开始往后搜索</p><table><thead><tr class="header"><th style="text-align: center;">快捷键</th><th style="text-align: center;">含义</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">n</td><td style="text-align: center;">next</td><td style="text-align: center;">下一个匹配的</td></tr><tr class="even"><td style="text-align: center;">N</td><td style="text-align: center;">shift+next</td><td style="text-align: center;">前一个匹配的</td></tr></tbody></table></li><li><p><code>?</code>搜索模式下，从光标开始往前搜索，快捷键的功能与<code>/</code>模型下刚好相反</p></li><li><p><code>:s</code>替换</p><table><thead><tr class="header"><th style="text-align: center;">语法</th><th style="text-align: center;">功能</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>:s/a/b/</code></td><td style="text-align: center;">光标后的第一个a替换成b</td></tr><tr class="even"><td style="text-align: center;"><code>:s/a/b/g</code></td><td style="text-align: center;">替换整行</td></tr><tr class="odd"><td style="text-align: center;"><code>:1,4s/a/b/g</code></td><td style="text-align: center;">1-4行的a换成b</td></tr><tr class="even"><td style="text-align: center;"><code>:%s/a/b/g</code></td><td style="text-align: center;">全文的a换成b</td></tr></tbody></table></li></ul><h2 id="vim基础配置">4 vim基础配置</h2><blockquote><ol type="1"><li>home目录下新建.vim目录</li><li>在.vim下新建vimrc文件</li><li>添加配置内容（map a b）（noremap a b）(set a)（let a）（color）</li></ol></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>        # 语法高亮</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>        # 显示行号</span><br><span class="line"><span class="keyword">set</span> relativenumber            # 显示相对行号</span><br><span class="line"><span class="keyword">set</span> norelativenumber        # 不显示显示相对行号</span><br><span class="line"><span class="keyword">set</span> wrap    # 避免超出行显示</span><br><span class="line"><span class="keyword">set</span> showcmd        # 右下角显示命令</span><br><span class="line"><span class="keyword">set</span> wildmenu    # 命令行模式下<span class="keyword">tab</span>提示</span><br><span class="line"><span class="keyword">set</span> hlsearch    # 高亮显示搜索结果</span><br><span class="line">exec <span class="string">&quot;nohlsearch&quot;</span>        # 退出重新进入后不高亮显示之前的结果</span><br><span class="line"><span class="keyword">set</span> incsearch        # 边输入边搜索</span><br><span class="line"><span class="keyword">set</span> ignorecase        # 搜索时忽略大小写</span><br><span class="line"><span class="keyword">set</span> smartcase        # 如果既含有小写又含有大写，则准确匹配</span><br><span class="line"></span><br><span class="line"># <span class="symbol">&lt;CR&gt;</span>代表回车</span><br><span class="line"><span class="keyword">map</span> S :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span>        # 大S快捷键映射为保存功能</span><br><span class="line"><span class="keyword">map</span> Q :q<span class="symbol">&lt;CR&gt;</span>        # 大Q快捷键映射为退出功能</span><br><span class="line"><span class="keyword">map</span> R :<span class="keyword">source</span> $MYVIMRC        # 大R快捷键映射为刷新该<span class="keyword">vim</span>配置</span><br><span class="line"></span><br><span class="line"><span class="keyword">noremap</span> J <span class="number">5</span><span class="keyword">j</span>        # 大J快捷键映射为光标向下移动<span class="number">5</span>行</span><br><span class="line"><span class="keyword">noremap</span> K <span class="number">5</span><span class="keyword">k</span>        # 大K快捷键映射为光标向上移动<span class="number">5</span>行</span><br><span class="line"></span><br><span class="line">color slate            # <span class="keyword">vim</span>配色改为slate</span><br></pre></td></tr></table></figure><h2 id="vim插件安装">5 vim插件安装</h2><h3 id="插件安装步骤">5.1 插件安装步骤</h3><ol type="1"><li>找到插件的github地址，然后clone下来放到<code>~/.vim/bundle</code>目录下</li><li>在<code>~/.vimrc</code>中写入<code>Plugin 'plugname'</code>，其中plugname为github中的项目名字</li></ol><h3 id="例子安装vim-airline插件">5.2 例子（安装vim-airline插件）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.vim/bundle</span><br><span class="line">git clone https://github.com/vim-airline/vim-airline.git</span><br><span class="line">vim ~/.vimrc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在vimrc中加入一行</span></span><br><span class="line">Plugin &#x27;vim-airline/vim-airline&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>也可以先安装vundle（插件管理工具）插件，只需要按照vundle的语法在vimrc中编辑语句后，执行PluginInstall可以自动下载插件，具体可以看vundle的github文档</p></blockquote><h3 id="vim主题安装">5.3 vim主题安装</h3><ol type="1"><li>下载相应的themename.vim到<code>~/.vim/colors</code>目录下</li><li>然后在<code>~/.vimrc</code>中写入<code>color themename</code>即可</li></ol><h2 id="附录.vimrc文件">6 附录（.vimrc文件）</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mapleader=<span class="string">&quot; &quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span></span><br><span class="line"><span class="keyword">set</span> norelativenumber</span><br><span class="line"><span class="keyword">set</span> wrap</span><br><span class="line"><span class="keyword">set</span> showcmd</span><br><span class="line"><span class="keyword">set</span> wildmenu</span><br><span class="line"><span class="comment">&quot;搜索相关</span></span><br><span class="line"><span class="keyword">set</span> hlsearch</span><br><span class="line">exec <span class="string">&quot;nohlsearch&quot;</span></span><br><span class="line"><span class="keyword">set</span> incsearch</span><br><span class="line"><span class="keyword">set</span> ignorecase</span><br><span class="line"><span class="keyword">set</span> smartcase</span><br><span class="line"><span class="keyword">noremap</span> <span class="symbol">&lt;LEADER&gt;</span><span class="symbol">&lt;CR&gt;</span> :<span class="keyword">nohlsearch</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot;缩进相关</span></span><br><span class="line"><span class="keyword">set</span> smartindent</span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span></span><br><span class="line"><span class="keyword">set</span> autoindent</span><br><span class="line"><span class="keyword">set</span> expandtab</span><br><span class="line"><span class="comment">&quot;保存退出快捷键</span></span><br><span class="line"><span class="keyword">map</span> S :<span class="keyword">w</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> Q :q<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> R :<span class="keyword">source</span> ~/.vimrc<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot;快速浏览</span></span><br><span class="line"><span class="keyword">noremap</span> J <span class="number">5</span><span class="keyword">j</span></span><br><span class="line"><span class="keyword">noremap</span> K <span class="number">5</span><span class="keyword">k</span></span><br><span class="line"><span class="comment">&quot;分屏相关</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">sl</span> :<span class="keyword">set</span> splitright<span class="symbol">&lt;CR&gt;</span>:<span class="keyword">vsplit</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">sh</span> :<span class="keyword">set</span> nosplitright<span class="symbol">&lt;CR&gt;</span>:<span class="keyword">vsplit</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> sk :<span class="keyword">set</span> splitbelow<span class="symbol">&lt;CR&gt;</span>:<span class="keyword">split</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> sj :<span class="keyword">set</span> nosplitbelow<span class="symbol">&lt;CR&gt;</span>:<span class="keyword">split</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot;分屏跳转</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;LEADER&gt;</span><span class="keyword">l</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">l</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;LEADER&gt;</span>h <span class="symbol">&lt;C-w&gt;</span>h</span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;LEADER&gt;</span><span class="keyword">k</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">k</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;LEADER&gt;</span><span class="keyword">j</span> <span class="symbol">&lt;C-w&gt;</span><span class="keyword">j</span></span><br><span class="line"><span class="comment">&quot;分屏大小调节</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;up&gt;</span> :<span class="keyword">res</span> +<span class="number">5</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;down&gt;</span> :<span class="keyword">res</span> -<span class="number">5</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;left&gt;</span> :<span class="keyword">vertical</span> <span class="keyword">resize</span>-<span class="number">5</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;right&gt;</span> :<span class="keyword">vertical</span> <span class="keyword">resize</span>+<span class="number">5</span><span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot;vundle插件相关</span></span><br><span class="line"><span class="keyword">set</span> nocompatible              <span class="comment">&quot; be iMproved, required</span></span><br><span class="line"><span class="keyword">filetype</span> off                  <span class="comment">&quot; required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; set the runtime path to include Vundle and initialize</span></span><br><span class="line"><span class="keyword">set</span> rtp+=~/.<span class="keyword">vim</span>/bundle/Vundle.<span class="keyword">vim</span></span><br><span class="line"><span class="keyword">call</span> vundle#begin()</span><br><span class="line"><span class="comment">&quot; alternatively, pass a path where Vundle should install plugins</span></span><br><span class="line"><span class="comment">&quot;call vundle#begin(&#x27;~/some/path/here&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; let Vundle manage Vundle, required</span></span><br><span class="line">Plugin <span class="string">&#x27;VundleVim/Vundle.vim&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;preservim/nerdtree&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;rstacruz/sparkup&#x27;</span>, &#123;<span class="string">&#x27;rtp&#x27;</span>: <span class="string">&#x27;vim/&#x27;</span>&#125;</span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;vim-airline/vim-airline-themes&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;connorholyday/vim-snazzy&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;dense-analysis/ale&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;Xuyuanp/nerdtree-git-plugin&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;nathanaelkane/vim-indent-guides&#x27;</span></span><br><span class="line">Plugin <span class="string">&#x27;ycm-core/YouCompleteMe&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> vundle#end()            <span class="comment">&quot; required</span></span><br><span class="line"><span class="keyword">filetype</span> plugin <span class="built_in">indent</span> <span class="keyword">on</span>    <span class="comment">&quot; required</span></span><br><span class="line"><span class="comment">&quot; nerdtree相关设置</span></span><br><span class="line"><span class="keyword">let</span> NERDChristmasTree=<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeChDirMode=<span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeIgnore=[<span class="string">&#x27;\~$&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> NERDTreeShowBookmarks=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeAutoCenter=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeShowLineNumbers=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeShowHidden=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeWinSize=<span class="number">25</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:nerdtree_tabs_open_on_console_startup</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeIgnore=[<span class="string">&#x27;\.pyc&#x27;</span>,<span class="string">&#x27;\~$&#x27;</span>,<span class="string">&#x27;\.swp&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:NERDTreeGitStatusIndicatorMapCustom</span> = &#123;</span><br><span class="line">    \ <span class="string">&quot;Modified&quot;</span>  : <span class="string">&quot;✹&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Staged&quot;</span>    : <span class="string">&quot;✚&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Untracked&quot;</span> : <span class="string">&quot;✭&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Renamed&quot;</span>   : <span class="string">&quot;➜&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Unmerged&quot;</span>  : <span class="string">&quot;═&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Deleted&quot;</span>   : <span class="string">&quot;✖&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Dirty&quot;</span>     : <span class="string">&quot;✗&quot;</span>,</span><br><span class="line">    \ <span class="string">&quot;Clean&quot;</span>     : <span class="string">&quot;✔︎&quot;</span>,</span><br><span class="line">    \ <span class="string">&#x27;Ignored&#x27;</span>   : <span class="string">&#x27;☒&#x27;</span>,</span><br><span class="line">    \ <span class="string">&quot;Unknown&quot;</span>   : <span class="string">&quot;?&quot;</span></span><br><span class="line">    \ &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">autocmd</span> bufenter * <span class="keyword">if</span> (<span class="built_in">winnr</span>(<span class="string">&quot;$&quot;</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">&quot;b:NERDTree&quot;</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree()) | q | <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">map</span> tt :NERDTreeMirror<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">map</span> tt :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">&quot; airline相关设置</span></span><br><span class="line"><span class="keyword">set</span> laststatus=<span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_theme</span> = <span class="string">&#x27;simple&#x27;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline_powerline_fonts</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:airline</span>#extensions#tabline#enabled = <span class="number">1</span></span><br><span class="line"><span class="comment">&quot; ale相关设置</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b:ale_linters</span> = [<span class="string">&#x27;pyline&#x27;</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">b:ale_fixers</span> = [<span class="string">&#x27;autopep8&#x27;</span>, <span class="string">&#x27;yapf&#x27;</span>]</span><br><span class="line"><span class="comment">&quot; intent_guides相关设置</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_guide_size</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_start_level</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_enable_on_vim_startup</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:indent_guides_color_change_percent</span> = <span class="number">1</span></span><br><span class="line">silent! <span class="keyword">unmap</span> <span class="symbol">&lt;LEADER&gt;</span>ig</span><br><span class="line"><span class="keyword">autocmd</span> WinEnter * silent! <span class="keyword">unmap</span> <span class="symbol">&lt;LEADER&gt;</span>ig</span><br><span class="line"><span class="comment">&quot; youcompleteme相关设置</span></span><br><span class="line"><span class="keyword">nnoremap</span> gd :YcmCompleter GoToDefinitionElseDeclaration<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> g/ :YcmCompleter GetDoc<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> gt :YcmCompleter GetType<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="keyword">gr</span> :YcmCompleter GoToReferences<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_autoclose_preview_window_after_completion</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_autoclose_preview_window_after_insertion</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_use_clangd</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_python_interpreter_path</span> = <span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ycm_python_binary_path</span> = <span class="string">&quot;/usr/bin/python3&quot;</span></span><br><span class="line"><span class="comment">&quot; 主题相关设置</span></span><br><span class="line"><span class="comment">&quot;color snazzy</span></span><br><span class="line"><span class="keyword">colorscheme</span> molokai</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux命令大全</title>
      <link href="/2019/12/28/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/12/28/linux%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="linux终端快捷键">linux终端快捷键</h2><p><code>ctrl+l</code>: 清屏</p><p><code>ctrl+c</code>: 中止</p><p><code>ctrl+d</code>： 退出</p><span id="more"></span><p><code>ctrl+a</code>: 光标移到命令行的头部</p><p><code>ctrl+e</code>: 光标移到命令行的尾部</p><p><code>ctrl+u</code>: 删除光标前所有字符</p><p><code>ctrl+k</code>: 删除光标后所有字符</p><p><code>ctrl+y</code>: 撤销</p><p><code>ctrl+r</code>: 搜索历史命令</p><p><code>ctrl+z</code>：暂停前台进程</p><p><code>esc+.</code>: 上一条命令的最后一个参数</p><p><code>up/down</code>：查看历史命令</p><p><code>ctrl+R</code>：搜索历史命令</p><h2 id="shell命令">shell命令</h2><h3 id="基础命令">基础命令</h3><h4 id="histroy">histroy/!</h4><p><code>history</code>: 历史命令</p><p><code>!20</code>：执行第20条历史命令</p><p><code>!str</code>：执行历史最近中以str开头的命令</p><p><code>!$</code>：上一个命令的最后一个参数</p><p><code>!!</code>：执行上一个命令</p><h4 id="man">man</h4><p><code>man command</code>: command手册</p><p><code>man -f command</code>: 查看command的所在所有章节</p><p><code>man 1 command</code>: 查看第1章节中的command手册</p><h4 id="alias">alias</h4><p><code>alias ll=ls -l</code>: 别名</p><p><code>unalias ll</code>: 取消别名</p><ul><li><p>查看命令的别名</p><p><code>type -a ls</code>: 查看所有<code>ls</code>命令的类型</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上述命令的输出</span></span><br><span class="line">ls is aliased to `ls --color=auto&#x27;</span><br><span class="line">ls is /bin/ls</span><br></pre></td></tr></table></figure></p><p><code>ls</code>： 系统默认使用别名<br /><code>\ls</code>: 使用原ls命令</p></li></ul><h4 id="echo">echo</h4><p><code>echo "123"</code>：返回或者输出123，会输出换行</p><p><code>echo -n "123"</code>：不换行输出</p><h4 id="whichwhereis">which/whereis</h4><p><code>which command</code>:查看命令的目录（根据<code>PATH</code>目录）</p><p><code>whereis command</code>: 整个文件索引数据库查找命令</p><h3 id="用户操作">用户操作</h3><p><code>id username</code>: 查看用户</p><p><code>whoami</code>: 显示当前用户</p><p><code>useradd cetrol</code>: 添加用户</p><h4id="groupaddgroupdeluseradduserdel">groupadd/groupdel/useradd/userdel</h4><p><code>groupadd groupname</code> 添加</p><p><code>userdel [-r] username</code>: 删除用户（去掉home目录）</p><h4 id="passwdgpasswd">passwd/gpasswd</h4><p><code>passwd username</code>: 为用户设置密码</p><p><code>gpasswd -a username groupname</code>: 将用户添加到组</p><p><code>gpasswd -d username groupname</code>: 将用户移除组</p><h3 id="目录与文件操作">目录与文件操作</h3><p><code>pwd</code>: 当前工作目录</p><h4 id="ls">ls</h4><p><code>ls</code>：当前目录内容</p><p><code>ls -a</code>: list all 所有，包含隐藏文件</p><p><code>ls dir</code>: dir目录下的内容</p><p><code>ll -h</code>: 人性化显示</p><p><code>ll -t</code>: 按照时间排序，最新在前</p><p><code>ll -rt</code>: reverse，逆序</p><p><code>ll dir</code>: 查看目录下所有文件的详情</p><p><code>ll -d dir</code>: 只查看目录的详情</p><h4 id="cd">cd</h4><p><code>cd</code>: 到<code>home</code>目录</p><p><code>cd ~</code>: 到<code>home</code>目录</p><p><code>cd dir</code>: 到<code>dir</code>目录</p><p><code>cd -</code>: 回到上一目录</p><h4 id="mkdir">mkdir</h4><p><code>mkdir dir1, dir2</code>: 创建目录</p><p><code>mkdir -v dir</code>: verbose，显示详细信息</p><p><code>mkdir -p dir</code>: 如果父目录不存在，会自动创建父目录</p><h4 id="touch">touch</h4><p><code>touch file1 file2</code>: 创建文件</p><p><code>touch file&#123;1..20&#125;</code>: 创建多个文件</p><h4 id="cp">cp</h4><p><code>cp file1 file2</code>: 拷贝文件</p><p><code>cp -r dir1 dir2</code>: 递归拷贝目录</p><h4 id="mv">mv</h4><p><code>mv file1 file2</code>: 剪切文件</p><h4 id="rm">rm</h4><p><code>rm -rf dir</code>: 递归删除目录</p><h4 id="chmodchownchgrp">chmod/chown/chgrp</h4><table><thead><tr class="header"><th style="text-align: center;">u</th><th style="text-align: center;">g</th><th style="text-align: center;">o</th><th style="text-align: center;"></th><th style="text-align: center;"></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">rwx</td><td style="text-align: center;">rw-</td><td style="text-align: center;">r--</td><td style="text-align: center;">user</td><td style="text-align: center;">group</td></tr><tr class="even"><td style="text-align: center;">属主权限</td><td style="text-align: center;">属组权限</td><td style="text-align: center;">其他人权限</td><td style="text-align: center;">属主</td><td style="text-align: center;">属组</td></tr></tbody></table><p><code>chown [-r] user file/dir</code>:改变file的所属组（递归修改目录）</p><p><code>chgrp [-r] group file/dir</code>:改变file的所属组（递归修改目录）</p><p><code>chown [-r] user.group file/dir</code>: 同时修改主和组</p><p><code>chmod u/g/o+w/r/x file</code>: 相应的u/g/o添加w/r/x权限</p><p><code>chmod [a]+w/r/x file</code>: 所有组添加w/r/x权限</p><p><code>chmod ug=rw file</code>: u和g添加rw权限</p><p><code>chmod o=-</code>: o去掉所有权限</p><p><code>chmod 777 file</code>: 所有组添加rwx权限</p><h4 id="tar">tar</h4><p><code>tar -czf test.tar.gz dir</code>:调用gzip将<code>dir</code>目录打包并压缩为<code>test.tar.gz</code></p><p><code>tar -cjf test.tar.bz2 dir</code>:调用bzip2将<code>dir</code>目录打包并压缩为<code>test.tar.bz2</code></p><p><code>tar -cJf test.tar.xz dir</code>:调用xz将<code>dir</code>目录打包并压缩为<code>test.tar.xz</code></p><p><code>tar -tf test.tar.xz</code>: 显示压缩包中的内容</p><p><code>tar -xzvf test.tar.gz</code>: 指定使用gzip解压</p><p><code>tar -xvf test.tar.gz</code>: 自行判断解压工具解压</p><p><code>tar -xvf test.tar.gz -C dir</code>:解压后重定向到<code>dir</code>目录下</p><p><code>tar -czf - /etc | tar -xzf - -C dir</code>:将/etc打包后保存在内存中，然后通过管道解压后<code>dir</code>目录下；相当于复制文件到另一个目录（许多小文件复制时速度快）</p><h4 id="du">du</h4><p><code>du -h dir</code>:查看目录<code>dir</code>下所有文件夹的大小</p><p><code>du -sh dir</code>: 查看目录<code>dir</code>总大小</p><h3 id="文件增删改查">文件增删改查</h3><h4 id="cat">cat</h4><p><code>cat file</code>: 查看文本文件</p><p><code>cat -n file</code>: 显示行号</p><h4 id="headtail">head/tail</h4><p><code>head -5 file</code>: 查看头5行</p><p><code>tail -5 file</code>: 查看尾5行</p><p><code>tail -f file</code>: 动态查看</p><h4 id="vivim">vi/vim</h4><p><code>vi file</code>: 编辑文件</p><h4 id="sort">sort</h4><p><code>sort file</code>: 按照字典序递增排序</p><p><code>sort -r file</code>: 递减排序</p><p><code>sort -n file</code>: 按照数字大小排序</p><p><code>sort -t":" -k3 -n /etc/passwd</code>:以<code>:</code>分割后按照第3列排序</p><h4 id="uniq">uniq</h4><p><code>uniq</code>:去重（只能把接近的去掉，所以一般先<code>sort</code>）</p><p><code>uniq -c</code>: 去重，并显示个数</p><h4 id="wc">wc</h4><p><code>wc -l</code>: 统计行数</p><h4 id="tr">tr</h4><blockquote><p>tr(translate) 可以用来替换、删除文本字符内容</p></blockquote><p><code>tr -d a file</code>: 将文本中所有字符<code>a</code>删掉</p><p><code>tr -d a-z file</code>: 将文本中所有小写字母删掉</p><p><code>tr -d ab file</code>:将文本中字符<code>a</code>和<code>b</code>删掉</p><p><code>tr -s a file</code>:将文本中连续出现多个的字符<code>a</code>压缩成单个字符<code>a</code></p><p><code>tr -s ab file</code>:将文本中连续出现多个字符<code>a</code>，多个字符<code>b</code>分别压缩成单个字符<code>a</code>和<code>b</code></p><p><code>tr -s a b file</code>:将文本中连续出现多个字符<code>a</code>压缩并替换成单个字符<code>b</code></p><p><code>tr a b file</code>:将文本中的每个字符<code>a</code>替换成<code>b</code></p><p><code>tr -s ab c file</code>: 将文本中连续出现多个字符<code>a</code>,多个字符<code>b</code>压缩并替换成单个字符<code>c</code></p><p><code>tr ab c file</code>:将文本中每个字符<code>a</code>,<code>b</code>替换成<code>c</code></p><p><code>tr ab cd file</code>:将文本中每个字符<code>a</code>,<code>b</code>分别替换成<code>c</code>和<code>d</code></p><p><code>tr -s a-z A-Z file</code>:将文本中连续出现多个字符<code>a</code>,多个字符<code>b</code>分别压缩并替换成单个字符<code>c</code>和单个字符<code>d</code></p><p><code>tr a-z A-Z file</code>: 将文本中每个字符<code>a</code>,<code>b</code>分别替换成<code>c</code>和<code>d</code></p><p><code>tr -c -d 'a\n' file</code>:将文本中除了<code>a</code>和<code>\n</code>外的字符都删掉</p><h4 id="awk">awk</h4><blockquote><p>awk是一种编程语言，用与逐行处理文本和数据</p></blockquote><p><code>awk -F":" '&#123;print $1&#125;' /etc/passwd</code>:以<code>:</code>分割输出第1列</p><p><code>awk 'BEGIN&#123;&#125; &#123;&#125; END&#123;&#125;'</code>：文件处理前 行处理 文件处理后</p><p><code>awk 'BEGIN&#123;FS=":",OFS="---"&#125; &#123;print $1,$2&#125;'</code>：输入字段以<code>:</code>分割，输出字段之间<code>---</code>输出，<code>FS</code>为输入分割符，<code>OFS</code>为输出字段分割符，<code>OFS</code>默认值为空格</p><p><code>awk 'BEGIN&#123;RS=":",ORS="---"&#125; &#123;print $1,$2&#125;'</code>：输入行以<code>:</code>分割，输出行之间<code>---</code>输出，<code>RS</code>为记录分割符，<code>ORS</code>为输出记录分割符，<code>RS</code>和<code>ORS</code>默认值为换行符</p><p><code>awk pattern filename</code>：正则匹配输出</p><p><code>awk '/root/&#123;action&#125;' filename</code>：匹配到<code>root</code>的行再执行<code>action</code></p><p><code>awk '&#123;print NR,FNR&#125;'</code>：<code>NR</code>表示总的记录行号，FNR表示当前文件的记录行号</p><p><code>awk '&#123;print NF&#125;'</code>：<code>NF</code>表示字段的个数</p><p><code>awk '&#123;printf "%-15s %-d %-f", $1,$2,$3&#125;'</code>：<code>printf</code>格式化输出，<code>%s</code>表示字符串，<code>%d</code>表示整形数据，<code>%f</code>表示浮点数，<code>-</code>表示左对齐，<code>15</code>表示长度为15</p><p><code>awk '$0~/root/' /etc/passwd</code>：正则匹配行，等效于<code>awk '/root/ /etc/passwd'</code></p><p><code>awk '$0!~/root/' /etc/passwd</code>：正则不匹配，等效于<code>awk '!/root/ /etc/passwd'</code></p><p><code>awk '$1=="root"' /etc/passwd</code>：关系运算符</p><p><code>awk '$1&gt;100' /etc/passwd</code>：关系运算符</p><p><code>awk '&#123;if($3&gt;100)&#123;print $3&#125; else if()&#123;&#125; else&#123;print $1&#125;&#125;'</code>：条件运算符</p><p><code>awk '&#123;$1*10&#125;'</code>：算术运算符</p><p><code>awk '&#123;if($1&gt;10 &amp;&amp; $2&lt;10)&#123;print $0&#125;&#125;'</code>：条件运算符</p><p><code>awk &#123;length($1)==10 &#123;print $1&#125;&#125;</code>：<code>length</code>函数表示字符串长度</p><p><code>awk '&#123;i=1; while(i&lt;=7) &#123;print $i; i++&#125;&#125;'</code>：while循环</p><p><code>awk '&#123;for(i=1;i&lt;=NF;i++) &#123;print $i&#125;&#125;'</code>：for循环</p><p><code>awk '&#123;color[++i]&#125;=$1' END&#123;for(i=1;i&lt;i;i++) &#123;print i,color[i]&#125;&#125;</code>：数组</p><p><code>awk '&#123;color[++i]&#125;=$1' END&#123;(for i in color) &#123;print i,color[i]&#125;&#125;</code>：数组，<code>for</code>循环使用<code>in</code>遍历获取的是索引</p><h4 id="sed">sed</h4><blockquote><p>sed是一种非交互式编辑器，一次处理一行内容</p></blockquote><p><code>sed action file</code>：从文件<code>file</code>中每次读入一行，执行<code>action</code>动作，不会修改文件内容，只做输出</p><p><code>sed -i action file</code>：会修改文件内容</p><p><code>sed "d" file</code>：删除输出（相当于什么都不输出）</p><p><code>sed "4d" file</code>：删除第四行</p><p><code>sed "3&#123;d;&#125;"</code>：<code>&#123;&#125;</code>里面的命令按照<code>;</code>分割，可以执行多个目录</p><p><code>sed "4,7d" file</code>：删除第4到7行</p><p><code>sed "4,$d" file</code>：删除第4到最后一行</p><p><code>sed -r "0~2d"</code>：从0开始，每2行删除，（相当于删除偶数行）</p><p><code>sed -r /root/,5d file</code>：删除从root到第5行</p><p><code>sed -r /root/,+5d file</code>：删除root，再删其后5行</p><p><code>sed -r /root/!d file</code>：删除非root行</p><p><code>sed "p" file</code>：打印输出（默认）</p><p><code>sed "4p" file</code>：只打印第4行输出（默认）</p><p><code>sed -r [s]/sth./sth./[gi]</code>：使用正则匹配</p><p><code>sed -r "s/red/yellow/" file</code>：查找<code>red</code>并替换为<code>yellow</code>，只替换每一行第一个</p><p><code>sed -r "s/red/yellow/g file"</code>：加上<code>g</code>，表示global，替换所有</p><p><code>sed -r "s/red/yellow/g file"</code>：加上<code>i</code>，表示ignore-case，忽略大小写</p><p><code>sed -r "s#red#yellow#g file"</code>：<code>/</code>其实可以替换成任意字符</p><p><code>sed -r "3,5s/red/yellow/g file"</code>：只有3到5行替换</p><p><code>sed -r "s/(.*)/#&amp;/ file"</code>：所有行前面加入<code>#</code>，<code>(.*)</code>表示匹配行所有内容，<code>&amp;</code>表示前面匹配的所有内容</p><p><code>sed -r "2r/new_file" file</code>：读到第2行时读取文件内容，<code>r</code>表示读入</p><p><code>sed -r "2w/new_file" file</code>：读到第2行时写入到新文件，<code>w</code>表示读入</p><p><code>sed -r "2a/new_file" file</code>：读到第2行时追加新内容或到新文件，<code>a</code>表示追加（行后）</p><p><code>sed -r "2i/new_file" file</code>：读到第2行时插入新内容或到新文件，<code>i</code>表示插入（行前）</p><p><code>sed -r "/root/&#123;n;d&#125; file"</code>：找到root行，然后去下一行并删除，<code>n</code>表示下一行</p><h3 id="时间相关命令">时间相关命令</h3><h4 id="date">date</h4><p><code>date +%F</code>: 格式化输出时间</p><h4 id="time">time</h4><p><code>time command</code>: 显示命令执行的时间</p><h3 id="进程相关命令">进程相关命令</h3><h4 id="pstop">ps/top</h4><p><code>ps aux</code>: 查看进程运行状态(快照模式)（process state）</p><p><code>ps aux --sort [-]%cpu</code>: 以cpu占用排序查看进程状态</p><p><code>ps auxf</code>: 加上f，显示进程的层级关系</p><p><code>ps -ef</code>: 查看PID（进程ID）和PPID（进程父ID）</p><p><code>top</code>: 动态模式</p><h4 id="kill">kill</h4><p><code>kill -1 PID</code>: 1为重启信号</p><p><code>kill [-15] PID</code>: 默认为15即停止信号</p><p><code>kill -9 PID</code>: 9为强制关闭信号</p><h4 id="fgbgjobs">fg/bg/jobs</h4><p><code>jobs</code>：查看所有后台进程</p><p><code>fg pid</code>：将后台pid任务切换至前台运行</p><p><code>bg pid</code>：将前台pid任务切换至后台运行</p><h3 id="硬件相关命令">硬件相关命令</h3><h4 id="lscpu">lscpu</h4><p><code>lscpu</code>: 查看cpu信息</p><h4 id="lsblk">lsblk</h4><p><code>lsblk</code>: 显示硬盘分区</p><h4 id="fdiskgdiskpartprobe">fdisk/gdisk/partprobe</h4><p><code>fdisk</code>: MBR分区工具</p><p><code>fdisk /dev/sda</code>: 硬盘分区工具</p><p><code>fdisk -l /dev/sda</code>: 查看分区信息</p><p><code>gdisk</code>: GPT分区工具</p><p><code>gdisk /dev/sda</code>: 硬盘分区工具</p><p><code>gdisk -l /dev/sda</code>: 查看分区信息</p><p><code>partprobe</code>：让kernel读取分区信息</p><h4 id="mkfs">mkfs</h4><p><code>mkfs</code>: 创建文件系统（格式化）</p><p><code>mkfs.ext4 /dev/sda1</code>:将硬盘sda的分区1格式化为ext4格式</p><h4 id="mountumount">mount/umount</h4><p><code>mount /dev/sda1 dir</code>将设备挂载到目录下<code>dir</code>下</p><blockquote><p>mount命令只是临时挂载，长期挂载需在/etc/fstab文件中设置</p></blockquote><p><code>mount -a</code>: 从<code>/etc/fstab</code>中查找并挂载所有</p><p><code>umount /dev/sda1</code>:</p><h4 id="df">df</h4><p><code>df</code>: 查看分区信息</p><p><code>df -T</code>: 显示分区文件系统格式</p><p><code>df -h</code>: 以<code>G,T</code>显示分区大小</p><h3 id="管道相关命令">管道相关命令</h3><h4 id="section">&gt;/&gt;&gt;/&lt;/&lt;&lt;</h4><table><thead><tr class="header"><th>描述符</th><th>含义</th><th>对应文件</th></tr></thead><tbody><tr class="odd"><td>0</td><td>标准输入</td><td>键盘设备文件</td></tr><tr class="even"><td>1</td><td>标准输出</td><td>终端设备文件</td></tr><tr class="odd"><td>2</td><td>标准错误</td><td>终端设备文件</td></tr></tbody></table><p><code>ls 1&gt;out.txt 2&gt;err.txt</code>:标准输出到<code>out.txt</code>，错误输出到<code>err.txt</code></p><p><code>ls &gt;out.txt</code>: 等效于<code>ls 1&gt;out.txt</code>:标准输出到<code>out.txt</code></p><p><code>ls &gt;&gt;out.txt</code>: 追加到文件</p><p><code>ls &amp;&gt;out.txt</code>:混合输出（包括标准输出和错误输出）</p><p><code>ls 2&gt;&amp;1</code>:错误输出（2）到标准输出（设备描述符1）中</p><p><code>ls &amp;&gt;/dev/null</code>: 混合输出到空设备（垃圾桶）</p><p><code>ls 2&gt;/dev/null</code>: 错误输出到空设备</p><p><code>cat &gt;out.txt</code>:将终端输入重定向到<code>out.txt</code></p><p><code>cat &gt;out.txt &lt;&lt;EOF</code>:输入直到遇到<code>EOF</code>结束输入</p><p><code>grep 'root' &lt; /etc/passwd</code>:输入重定向，<code>grep 'root'</code>的输入重定向到<code>/etc/passwd</code></p><h4 id="mkfifo">|/mkfifo</h4><p><code>|</code>: 匿名管道</p><p><code>command 1 | command 2</code>:管道，命令1的输出重定向为命令2的输入</p><p><code>mkfifo /tmp/fifo1</code>：命名管道，可以跨终端传输数据</p><h4 id="tee">tee</h4><p><code>ls -l | tee result.txt</code>：<code>ls -l</code>的结果不仅输出到<code>result.txt</code>中，而且会显示到屏幕上</p><p><code>ls -l | tee -a result.txt</code>：追加</p><h3 id="搜索相关命令">搜索相关命令</h3><h4 id="locatefind">locate/find</h4><p><code>locate string</code>:从数据库中查找包含<code>string</code>的文件</p><blockquote><p>数据库为/var/lib/mlocate/mlocate.db，可以使用<code>updatedb</code>命令手动更新该数据库</p></blockquote><p><code>find dir</code>: 查找<code>dir</code>目录下所有文件（显示所有文件）</p><p><code>find dir [-name] "string"</code>:查找<code>dir</code>目录下包含<code>string</code>的所有文件</p><p><code>find dir -iname "string"</code>: 查找文件，忽略大小写</p><p><code>find dir -size +5M: 查找大于</code>5M`的文件</p><p><code>find dir -maxdepth 3 -a -name "string"</code>:查找文件且深度为3（<code>-a</code>表示and，<code>-o</code>表示or）</p><p><code>find dir -mtime +5</code>: 修改时间超过5天内的文件</p><p><code>find dir -user username</code>:用户为<code>username</code>的文件</p><p><code>find dir -group groupname</code>:查看组为<code>groupname</code>的文件</p><p><code>find dir -nouser -o -nogroup</code>: 没用户没组的文件</p><p><code>find dir ! -user username</code>: <code>!</code>表示取反</p><p><code>find dir -type d</code>: 查找为<code>d</code>（目录）的文件</p><p><code>find dir -perm 666</code>: 查找权限大于等于666的文件</p><p><code>find dir -regex 'regular expression'</code>:以正则表达式查找</p><p><code>find &#123;sth&#125; -delete</code>: 查找后删除</p><p><code>find &#123;sth&#125; -print/-ls</code>:查找后打印（<code>ls</code>更详细）</p><p><code>find &#123;sth&#125; -exec/-ok command \;</code> :查找后执行<code>command</code>shell命令（<code>-ok</code>有交互，会询问是否如此操作）</p><h3 id="grep正则命令">grep正则命令</h3><h4 id="grepegrep">grep/egrep</h4><p><code>grep pattern file1 [file2]</code>：从文件中过滤出匹配到模式的字符串</p><p><code>grep -q pattern file1</code>：不打印结果，只返回输出码（0表示找到，1表示没找到，2表示文件不存在）</p><p><code>grep -v</code>：取反，未匹配到的打印输出</p><p><code>grep -i</code>：忽略大小写</p><p><code>grep -o</code>：只输出匹配到的内容</p><p><code>grep -n</code>：输出匹配到的行号</p><p><code>grep -r[-R] dir</code>：递归遍历<code>dir</code>目录匹配</p><p><code>grep -E(egrep)</code>：<code>egrep</code>可以直接使用扩展元字符<code>?</code>，<code>+</code>，<code>&#123;&#125;</code>，<code>|</code>，<code>()</code>，但是在<code>grep</code>中需要使用<code>\</code>转义才能使用扩展元字符</p><h3 id="其他">其他</h3><h4 id="screen">screen</h4><p><code>screen -S session_name</code>:新开一个名字叫session_name的screen作业</p><p><code>screen -ls</code>: 查看所有screen作业</p><p><code>screen -r</code>: 恢复上一次的作业</p><p><code>screen -r session_name</code>:恢复session_name的作业（attached）</p><p><code>screen -d</code>: 离线当前作业（detached）</p><p><code>ctrl+a d</code>：离线当前作业</p><p><code>screen -d session_name</code>:离线session_name作业（detached）</p><p><code>exit</code>:在attached的screen作业下输入该命令，终止该screen作业</p><p><code>kill pid</code>:<code>pid</code>为screen的进程id，终止该screen作业</p><p><code>screen -wipe</code>: 清理掉没用的（deaded）screen作业</p><h4 id="seq">seq</h4><p><code>seq 10</code>：产生1到10的序列</p><p><code>seq 2 10</code>：产生从2到10的序列</p><p><code>seq 1 2 10</code>：产生从1到10的序列，递增为2</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL和windows的zsh终端配置教程</title>
      <link href="/2019/12/23/WSL%E5%92%8Cwindows%E7%9A%84zsh%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/"/>
      <url>/2019/12/23/WSL%E5%92%8Cwindows%E7%9A%84zsh%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="wsl终端配置">1 WSL终端配置</h2><h3 id="更换配色">1.1 更换配色</h3><p>背景rgb（0，43，53），文字rgb(147,161,161)</p><h3 id="下载并安装字体firacode右键属性选择字体为firacode">1.2下载并安装字体FiraCode，右键属性选择字体为FiraCode</h3><span id="more"></span><h3 id="下载zsh">1.3 下载zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install zsh</span><br></pre></td></tr></table></figure><h3 id="重启wsl安装zsh">1.4 重启wsl安装zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</span><br></pre></td></tr></table></figure><h3 id="配置">1.5 配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义主题</span></span><br><span class="line">cp ~/.oh-my-zsh/themes/agnoster.zsh-theme ~/.oh-my-zsh/custom/themes/agnoster_wsl.zsh-theme</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">找到下面内容，并将blue替换为0.75</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Dir: current working directory</span></span><br><span class="line">prompt_dir() &#123;</span><br><span class="line">  prompt_segment blue $CURRENT_FG &#x27;%~&#x27;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置主题</span></span><br><span class="line">vim ~/.zshrc</span><br><span class="line">ZSH_THEME=&quot;agnoster_wsl&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">隐藏用户名+主机名</span></span><br><span class="line">DEFAULTUSER=&#x27;cetrol</span><br></pre></td></tr></table></figure><h2 id="powershell终端配置">2 powershell终端配置</h2><h3 id="管理员运行powershell">2.1 管理员运行powershell</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许powershell运行任何脚本</span></span><br><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass</span><br></pre></td></tr></table></figure><h3 id="下载chocolatey安装包管理工具">2.2下载chocolatey安装包管理工具</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;https://chocolatey.org/install.ps1&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="安装colortools修改配色">2.3 安装colortools修改配色</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">choco install colortool</span><br><span class="line"><span class="comment"># 查看所有配色</span></span><br><span class="line">colortool <span class="literal">-s</span></span><br><span class="line"><span class="comment"># 设置配色</span></span><br><span class="line">colortool 配色名字</span><br></pre></td></tr></table></figure><h3 id="安装oh-my-posh">2.4 安装oh-my-posh</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">Install-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span> <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure><h3 id="设置主题熟悉的用户直接到第7步即可">2.5设置主题（熟悉的用户直接到第7步即可）</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> <span class="built_in">oh</span><span class="literal">-my-posh</span></span><br><span class="line"><span class="built_in">Set-Theme</span> Agnoster</span><br></pre></td></tr></table></figure><h3 id="隐藏用户名主机名">2.6 隐藏用户名主机名</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$DefaultUser</span> = <span class="string">&#x27;cetrol&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="配置字体">2.7 配置字体</h3><ul><li><p>下载<ahref="https://github.com/powerline/fonts/tree/master/DejaVuSansMono">powerline字体</a>并安装</p></li><li><p>在powershell中运行下面代码后，右键属性里才可以看到安装的字体</p></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> <span class="literal">-Name</span> PSReadLine <span class="literal">-Force</span> <span class="literal">-SkipPublisherCheck</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="built_in">Test-Path</span> <span class="literal">-Path</span> <span class="variable">$PROFILE</span> )) &#123; <span class="built_in">New-Item</span> <span class="literal">-Type</span> File <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Force</span> &#125;</span><br><span class="line"><span class="string">@&quot;</span></span><br><span class="line"><span class="string">#requires -Version 2 -Modules posh-git</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Write-Theme &#123;</span></span><br><span class="line"><span class="string">    param(</span></span><br><span class="line"><span class="string">        [bool]</span></span><br><span class="line"><span class="string">        `$lastCommandFailed,</span></span><br><span class="line"><span class="string">        [string]</span></span><br><span class="line"><span class="string">        `$with</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$lastColor = `$sl.Colors.PromptBackgroundColor</span></span><br><span class="line"><span class="string">    `$prompt = Write-Prompt -Object `$sl.PromptSymbols.StartSymbol -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #check the last command state and indicate if failed</span></span><br><span class="line"><span class="string">    If (`$lastCommandFailed) &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.FailedCommandSymbol) &quot; -ForegroundColor `$sl.Colors.CommandFailedIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #check for elevated prompt</span></span><br><span class="line"><span class="string">    If (Test-Administrator) &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.ElevatedSymbol) &quot; -ForegroundColor `$sl.Colors.AdminIconForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$user = [System.Environment]::UserName</span></span><br><span class="line"><span class="string">    `$computer = [System.Environment]::MachineName</span></span><br><span class="line"><span class="string">    `$path = Get-FullPath -dir `$pwd</span></span><br><span class="line"><span class="string">    if (Test-NotDefaultUser(`$user)) &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$user@`$computer &quot; -ForegroundColor `$sl.Colors.SessionInfoForegroundColor -BackgroundColor `$sl.Colors.SessionInfoBackgroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (Test-VirtualEnv) &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.SegmentForwardSymbol) &quot; -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.VirtualEnvSymbol) `$(Get-VirtualEnvName) &quot; -ForegroundColor `$sl.Colors.VirtualEnvForegroundColor -BackgroundColor `$sl.Colors.VirtualEnvBackgroundColor</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.SegmentForwardSymbol) &quot; -ForegroundColor `$sl.Colors.VirtualEnvBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    else &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$sl.PromptSymbols.SegmentForwardSymbol) &quot; -ForegroundColor `$sl.Colors.SessionInfoBackgroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ## Writes the drive portion</span></span><br><span class="line"><span class="string">    `$prompt += Write-Prompt -Object &quot;`$path &quot; -ForegroundColor `$sl.Colors.PromptForegroundColor -BackgroundColor `$sl.Colors.PromptBackgroundColor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$status = Get-VCSStatus</span></span><br><span class="line"><span class="string">    if (`$status) &#123;</span></span><br><span class="line"><span class="string">        `$themeInfo = Get-VcsInfo -status (`$status)</span></span><br><span class="line"><span class="string">        `$lastColor = `$themeInfo.BackgroundColor</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object `$(`$sl.PromptSymbols.SegmentForwardSymbol) -ForegroundColor `$sl.Colors.PromptBackgroundColor -BackgroundColor `$lastColor</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot; `$(`$themeInfo.VcInfo) &quot; -BackgroundColor `$lastColor -ForegroundColor `$sl.Colors.GitForegroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    ## Writes the postfix to the prompt</span></span><br><span class="line"><span class="string">    `$prompt += Write-Prompt -Object `$sl.PromptSymbols.SegmentForwardSymbol -ForegroundColor `$lastColor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$timeStamp = Get-Date -UFormat %r</span></span><br><span class="line"><span class="string">    `$timestamp = &quot;[`$timeStamp]&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$prompt += Set-CursorForRightBlockWrite -textLength (`$timestamp.Length + 1)</span></span><br><span class="line"><span class="string">    `$prompt += Write-Prompt `$timeStamp -ForegroundColor `$sl.Colors.PromptForegroundColor</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    `$prompt += Set-Newline</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if (`$with) &#123;</span></span><br><span class="line"><span class="string">        `$prompt += Write-Prompt -Object &quot;`$(`$with.ToUpper()) &quot; -BackgroundColor `$sl.Colors.WithBackgroundColor -ForegroundColor `$sl.Colors.WithForegroundColor</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    `$prompt += Write-Prompt -Object (`$sl.PromptSymbols.PromptIndicator) -ForegroundColor `$sl.Colors.PromptBackgroundColor</span></span><br><span class="line"><span class="string">    `$prompt += &#x27; &#x27;</span></span><br><span class="line"><span class="string">    `$prompt</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`$sl = `$global:ThemeSettings #local settings</span></span><br><span class="line"><span class="string">`$sl.PromptSymbols.StartSymbol = &#x27;&#x27;</span></span><br><span class="line"><span class="string">`$sl.PromptSymbols.PromptIndicator = [char]::ConvertFromUtf32(0x276F)</span></span><br><span class="line"><span class="string">`$sl.PromptSymbols.SegmentForwardSymbol = [char]::ConvertFromUtf32(0xE0B0)</span></span><br><span class="line"><span class="string">`$sl.Colors.PromptForegroundColor = [ConsoleColor]::White</span></span><br><span class="line"><span class="string">`$sl.Colors.PromptSymbolColor = [ConsoleColor]::White</span></span><br><span class="line"><span class="string">`$sl.Colors.PromptHighlightColor = [ConsoleColor]::DarkBlue</span></span><br><span class="line"><span class="string">`$sl.Colors.GitForegroundColor = [ConsoleColor]::Black</span></span><br><span class="line"><span class="string">`$sl.Colors.WithForegroundColor = [ConsoleColor]::DarkRed</span></span><br><span class="line"><span class="string">`$sl.Colors.WithBackgroundColor = [ConsoleColor]::Magenta</span></span><br><span class="line"><span class="string">`$sl.Colors.VirtualEnvBackgroundColor = [System.ConsoleColor]::Red</span></span><br><span class="line"><span class="string">`$sl.Colors.VirtualEnvForegroundColor = [System.ConsoleColor]::White</span></span><br><span class="line"><span class="string">&quot;@</span>&gt;<span class="variable">$env:userprofile</span><span class="string">&quot;\Documents\WindowsPowerShell\Modules\oh-my-posh\2.0.263\Themes\Paradox.psm1&quot;</span>       <span class="comment"># 建议自己把代码放到记事本然后替换路径，此条路径要改。。</span></span><br><span class="line"><span class="string">@&quot;</span></span><br><span class="line"><span class="string">chcp 65001</span></span><br><span class="line"><span class="string">Set-PSReadlineOption -EditMode Emacs</span></span><br><span class="line"><span class="string">function which(<span class="variable">$name</span>) &#123; Get-Command <span class="variable">$name</span> | Select-Object Definition &#125;</span></span><br><span class="line"><span class="string">function rmrf(<span class="variable">$item</span>) &#123; Remove-Item <span class="variable">$item</span> -Recurse -Force &#125;</span></span><br><span class="line"><span class="string">function mkfile(<span class="variable">$file</span>) &#123; &quot;&quot; | Out-File <span class="variable">$file</span> -Encoding ASCII &#125;</span></span><br><span class="line"><span class="string">Import-Module posh-git</span></span><br><span class="line"><span class="string">Import-Module oh-my-posh</span></span><br><span class="line"><span class="string">Set-Theme Agnoster</span></span><br><span class="line"><span class="string"><span class="variable">$DefaultUser</span> = &#x27;cetrol&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Chocolatey profile</span></span><br><span class="line"><span class="string"><span class="variable">$ChocolateyProfile</span> = &quot;<span class="variable">$env:ChocolateyInstall</span>\helpers\chocolateyProfile.psm1&quot;</span></span><br><span class="line"><span class="string">if (Test-Path(<span class="variable">$ChocolateyProfile</span>)) &#123;</span></span><br><span class="line"><span class="string">  Import-Module &quot;<span class="variable">$ChocolateyProfile</span>&quot;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="vscode终端配置">3 Vscode终端配置</h2><ul><li>设置-&gt;用户-&gt;功能-&gt;终端设置可以正确显示Agnoster的字体，比如fira code retina字体</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> zsh </tag>
            
            <tag> WSL </tag>
            
            <tag> windows </tag>
            
            <tag> 终端美化 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
